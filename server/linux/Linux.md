# Linux

RHEL（企业、服务器）、CentOS（企业、服务器）、Fedora（个人桌面版）、Ubuntu（桌面版）

# 1 系统安装

在新建虚拟机的时候，请选择稍后安装操作系统，先要对安装设置选项进行设置，然后再去安装系统。否则直接安装系统，将会默认安装最精简的配置。

## VMWare

Ctrl+Alt 返回到自己的电脑

IDE硬盘 hd[a-d]表示不同硬盘，hda[1-4]表示硬盘a的不同分区

STATA/SCSI硬盘 sd[a-p],同样用数字表示不同硬盘下的不同分区

网卡用eth[0-]表示，window是通过本地连接1，本地连接2表示

Linux 只有一个盘符"/"，不像windows有很多个盘符(A-Z)。

![windows的磁盘管理](./legend/disc_partition.png)

不同文件系统采用不同的方法来管理磁盘空间，各有优劣；**文件系统是具体到分区的**，所以格式化针对的是分区，**分区格式化**是指采用指定的文件系统类型对分区空间进行登记、索引并建立相应的管理表格的过程。

交换分区swap，在磁盘中划分一定的空间来模拟内存，当系统的内存不够用的时候，就会使用交换分区。

重新引导-重启系统

centos默认的桌面系统是gnome

# 3 首次登陆与man page

双击计算机，点开文件夹将会跳出很多窗口，不友好，

计算机->编辑->首选项->行为->总是在浏览器窗口打开

计算机->编辑->首选项->视图->显示隐藏和备份文件夹，**linux里面凡是以点开头的文件都是隐藏文件**

linux中之所以能看到图形化界面是因为startx的进程在运行，windows之所以能看到图形化界面也是有一个explorer的进程在运行。

## 3.1图形化界面X window和命令行模式的切换

centos和rehat有7个控制台，第一个到第六个都是字符界面，其中第七个控制台是图形化界面（x window）

从X window 转命令行模式：快捷键【Ctrl + Alt + Fn】，F1就是第一个控制台，依次类推。

系统是一间房子，它有七个入口。用户登录后，输入tty可以查看当前处于哪个控制台。在字符界面的控制台，可以直接敲命令。

如果想在图形化界面上进入命令行，可参考下面的操作

从命令行切换xwindow：执行startx命令，开启图形化界面服务

## 3.2 打开终端

1. 右击桌面->打开终端 
2. 或者应用程序->附件->终端

【Ctrl + space 】切换输入法

**在命令行中，$符号就代表你是普通权限。如果是#符号就代表你已经是管理员权限啦**

**切换用户**：

1. 输入“su -”回车->输入管理员密码，在界面上密码是不显示的，
2. 或者login 重新登录。使用login命令会退出当前用户，重新进度登录操作界面
3. **管理员用户切换至普通用户**：su [用户名] 使用su命令从高级别用户切换至低级别用户无需输入密码

取消当前命令的执行：【Ctrl + c】或者 逐字删除命令

命令的格式：`命令 -选项 ... 参数`，多个选项可以连写，如果`-`后面是一个单词，我们通常用`--`来指定后面的选项是一个整单词而不是多个选项的缩写

```cmd
ls -l
ls -a
ls -s
ls -las
ls --help
```

命令补全：command_sub 按tab，唯一匹配则自动补全，如不能唯一匹配，连续按两下tab键，系统将列下所有以command_sub**开头**的命令或目录文件名

历史命令调取：上下键，history历史输入命令列表

命令中光标的移动：

 	1. 【Ctrl + A】命令开头，
 	2. 【Ctrl + E】命令结尾，
 	3. 【Ctrl + ←→】一个单词一个单词的跳跃，
 	4. 【Ctrl + U】从当前光标删到本行开头，
 	5. 【Ctrl + K】从当前光标删到本行结束，

引用上一个命令中的参数：按ESC ，松手之后按**" . "**

参数替换：^xx^yy，用yy参数替换上一行命令中的xx参数，并执行

复制选中内容并输入：选中内容，按鼠标中间键。会执行复制并粘贴的动作

打开多个终端：

1. 【Ctrl + Shift + T】本终端窗口打开新的标签终端。【Ctrl + Shift + pageup】移到左终端标签，
2. 【Ctrl + Alt + T】新终端窗口打开新的标签终端。
3. 【Ctrl + D】退出终端，退出当前命令域（相当于Exit）

大小写：linux中大小写严格区分，windows中不区分

## 3.3 命令求助

查看命令的是什么功能：**whatis command_name** ，他会列出三列，第一列命令，第二列命令出现在manpage的第几章，第三列命令的功能描述

查看命令的用法：command_name --help

### man page

man 是 manual 操作手册的缩写，它是以章节的信息显示的，默认查看的是第一章。

1. man [chapter_index] command_name 
   - 它有name、语法、描述
   - 命令行的左下角有个冒号，
   - 
   - 
   - g输入"/keyword"，可以查找关键词，n查找下一个，N查找上一个，q离开本次man查询
2. man -k command_keyword
   - 通过关键字找相关命令

/usr/share/doc，里面存放了很多帮助文档。

info page和man page差不多，可以后面好好看看

## 3.4 文本编辑器

nano、gedit、vim

命令行输入gedit，会打开gedit 文本编辑窗，里面我们可以编写文本，gedit filename 在文本编辑窗打开对应文本文件。

nano的操作gedit差不多，只是它的打开是直接在命令行窗，然后直接在窗口编辑。在窗的底部有一些命令（Ctrl + command），用于操作此文档。

## 3.5 关机方法

sync ——数据同步写到到磁盘中去

shutdown——关机，

reboot——重启，poweroff——关机，正常的关机，会把系统的服务一一的关掉，也可以使用相应的选项做相应的关机操作

## 3.6 init

在不同文件系统，它会开启不同的服务，每个文件系统有7个服务级别（0~6，重启——切换到第6个运行级别，关机——切换到第0个级别，级别5图形化界面），默认处在5级别。

查看上一次运行级别和当前运行的级别：runlevel，

进入其它运行级别用：init N

/etc/init.d 和 /etc/rc.d/init.d 包含了所有服务，在/etc/rc.d下有7个名为rcN.d的**目录**，对应系统的7个运行级别。进入rcN.d的文件后可以看见，每个凡是以k开头的都是不运行的服务，以S开头的都是运行的服务。

## 3.7 忘记root密码

重启系统，在倒计时内按任意键->下面有注释，按e->选中kernel行，按e编辑该选中项

# 4 文件权限与目录配置

windows操作系统将用户名和密码放在：C:\Windows\System32\config\SAM这个数据库中

而linux系统关于用户的账户信息都放在：/etc/passwd，用户的密码存放在：/etc/shadow，用户组的信息是放在：/etc/group

注：**/etc目录一般用来存放程序所需的整个文件系统的配置文件**

## 4.1 文件权限

查看文件属性：**ls -al**

`-rw-r--r-- 1 root root 42304 Sep 4 18:26 install.log`

1. 第一列第一个字符：文件类型
   - d是目录，-为文件，l为连接文件，b为接口设备
2. 第一列接下来每3位一组的九个字符：文件的权限，每三位对应一个**rwx**——可读可写可执行（具体解释，参看p147）
   - 第一个三位：文件拥有者（User），第二个三位：用户组（Group），第三个三位：其他用户（Others），
3. 第二列表示有多少文件名连接到此节点inode
4. 第三列文件所有者的账号
5. 第四列文件所属用户组
6. 第五列文件大小，单位B
7. 第六列文件最后修改时间
8. 第七列文件名

### 权限rwx

1. rwx对文件的意义
   - r，可读取此文件的实际内容
   - w，编辑文件的实际内容，不具备删除文件的能力
   - x，可被系统执行的权限
2. rwx对目录的意义
   - r，读取目录结构列表的权限
   - w，新建或删除，重命名，移动文件位置
   - x，可否cd，称为工作目录

**改变文件权限：**

1. **chgrp**：改变文件用户组，`格式：chgrp [-R] 用户组 文件或目录`
2. **chown**：改变文件所有者，`格式：chown [-R] 账户名称[.用户组] 文件或目录`
3. **chmod**：改变文件的权限
   - 方式一：rwx-421，每三位用0-7表示，共9位，需要用三个0-7的数（eg：777）表示权限，nnn，格式：`chmod nnn 文件或文件名`
   - 方式二：`chmod u+rwx g-w o=r [a=rwx] 文件或目录`  ，这里面a表示全部，包括ugo，+（加入权限），-（除去权限），=（设置权限）

## 4.2 目录说明

为了规范系统不同目录的功能，linux采用了目录配置标准FHS。

FHS的重点在于规范每个特定的目录下应该要放什么样子的数据而已。

FHS针对目录树架构仅定义了三层目录下面应该放置什么数据。分别是下面这三个目录的定义

1. **/（root，根目录）**：与开机系统有关，相当于windows的c盘
2. **/usr（unix software resource）**：与**软件**安装和执行有关
3. **/var（variable）**：与系统运作过程有关（日志）

### 4.2.1 根目录

与开机过程有关

主要与linux系统有关的文件，相当于windows的C盘。

| 目录       | 说明                     | 应放置文件内容                                               |
| ---------- | ------------------------ | ------------------------------------------------------------ |
| **/**      | 系统根目录               | 与开机、还原、系统修复等操作有关、根目录所在分区越小越好     |
| **/bin**   | 执行文件目录             | 放置各种可执行命令                                           |
| **/boot**  | 开机文件                 | 包括linux内核文件以及开机菜单与开机所需配置文件等            |
| **/dev**   | 设备与接口设备文件       | device，只要通过访问这个目录下的某个文件，就相当于访问某个设备 |
| **/etc**   | 系统配置文件             | etc不是什么缩写，是and so on的意思 来源于 法语的 et cetera 翻译成中文就是 等等 的意思. <br />至于为什么在/etc下面存放配置文件<br /> 按照原始的UNIX的说法，这下面放的都是一堆零零碎碎的东西, 就叫etc, 这其实是个历史遗留.<br />eg：人员的用户信息/etc/passwd，个人密码/etc/shadow，环境变量/etc/profile |
| **/home**  | 用户主文件               | 用户个人的文件夹                                             |
| **/lib**   | 开机的函数库             |                                                              |
| **/media** | 放置可删除的设备         | 包括可删除的软盘、光盘                                       |
| **/mnt**   | 挂载的某些额外设备       | mount，与media用途相同，只是有了media后，这个目录用来临时挂载用 |
| **/opt**   | **第三方软件放置的目录** | 如果你想要自行安装额外的软件（非系统原本distribution提供的），那么也能够将你的软件安装到这里来。<br />不过以前的linux系统中，有的还是习惯将第三方软件放置在/usr/local目录下。 |
| **/root**  | 系统管理员主文件         |                                                              |
| **/sbin**  | 开机所需要的相关命令     | system bin                                                   |
| **/srv**   | 服务所需要的数据目录     | service，是一些网络服务启动之后，这些服务所需要取用的数据目录。 |
| **/tmp**   | 存放临时文件             | 这是让一般用户或者正在执行的程序暂时放置文件的地方。FHS建议在开机时，应该要将tmp下的数据清理一下。 |
| **/proc**  | 记录进程状态             | process，一个虚拟文件系统，放在内存当中。例如系统内核，进程，外部设备的状态及网络状态等。 |
| **/sys**   | 记录与内核相关信息       | 一个虚拟文件系统，放在内存中，记录与系统内核相关的东西。     |
|            |                          |                                                              |
|            |                          |                                                              |

**开机过程中仅有根目录会被挂载**，其他分区则是在开机完成后才会持续挂载的行为。

所以这些**/etc（配置文件）、/bin（重要执行文件）、/dev（设备文件）、/lib（执行文件所需函数库与内核所需的模块）、/sbin（重要系统执行文件） 不能与根目录分开放在不同分区里面**

### 4.2.2 /usr

Unix Software Resource

所有系统默认的软件（distribution发布者提供的软件）都会放置到/usr下，因此这个目录有点像windows系统的`C:\Windows和C:\Program files`

| 目录             | 说明                                                         | 应放置的文件内容                                             |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **/usr/bin**     | 绝大多数用户可以使用的命令                                   | 与开机过程无关的绝大多数命令                                 |
| **/usr/local**   | 本地自行下载的软件，建议安装到此目录                         | 非distribution默认提供者<br />该目录下也是具有bin、etc、include、lib子目录的。 |
| **/usr/lib**     | 各应用软件的函数库、目标文件以及不被用户惯用的执行文件或脚本 |                                                              |
| **/usr/sbin**    | 非系统正常运行所需要的系统命令                               | 最常见的就是某些网络服务器软件的服务命令（daemon）           |
| **/usr/share**   | 放置共享文件的地方                                           |                                                              |
| **/usr/src**     | 一般源码建议放到这里                                         |                                                              |
| **/usr/include** | c/c++等程序语言的头文件（header）与包含文件（include）放置处 |                                                              |

### 4.2.3 /var

如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。

因为/var目录主要针对常态性变动文件，包括缓存（cache）、登录文件（log file）以及软件运行所产生的文件。

| 目录           | 说明                 | 应放置的文件内容                                             |
| -------------- | -------------------- | ------------------------------------------------------------ |
| **/var/cache** | 缓存文件             | 应用程序本身运行过程中会产生一些缓存文件                     |
| **/var/lib**   | 程序使用到的数据文件 | eg：mysql的数据库放置到/var/lib/mysql，而rpm的数据库在/var/lib/rpm目录下 |
| **/var/run**   | 程序或服务启动       | 启动后会将他们的pid放置在这个目录下                          |
| **/var/spool** | 程序队列数据         | 排队等待其他程序使用的数据，这些数据被使用后通常都会被删掉   |
| **/var/mail**  | 个人电子邮件         | 与/var/spool/mail互为连接文件                                |
|                |                      |                                                              |

### 4.2.4 目录树架构示意图

![](./legend/linux目录树架构示意图.png)

# 5 文件与目录管理

操作与管理文件与目录，包括在不同的目录间切换、创建与删除目录、创建文件与删除文件，还有查找文件、查看文件内容等。

## 5.1 目录管理

1. **cd**：切换目录（change directory）
   - [相对路径或绝对路径]
2. **pwd**：显示当前目录（print working directory）
3. **mkdir**：新建一个目录（make directory）
   - -m 711 配置文件权限
   - -p test/test1/test2 自行创建多层目录
4. **rmdir**：删除一个目录，只能删除空目录
   - -rf 强制删除，不做任何提示
   - f参数少用

## 5.2 文件与目录管理

1. **ls** ：查看当前目录下的文件与目录
   - -al 详细信息
2. **cp**：复制文件或目录
   - cp -rf 源目录 目标目录
3. **rm**：删除文件或目录
   - rm -rf 递归强制删除文件、目录及其子目录和子文件
   - -r 只能删除文件
   - -R 既能删除文件又能删除文件夹
4. **mv**：移动文件与目录，或更名
   - [-fiu] source distination
   - -f，强制，如有则覆盖
   - -i，询问后，覆盖
   - -u，文件较新，则覆盖
5. **touch**：创建新文件，修改文件时间
   - touch 文件名
   - [-am ] a——access访问时间，m——编辑时间
6. 

## 5.3 文件内容查阅

#### 查看所有文件内容

- **cat** 正向列示，由前至后

  - cat可以借助数据流重定向直接创建文本文档

  - ```bash
    cat > introduce
    ni hao, my name is lxx, hen gao xin ren shi ni men
    #写完内容后，[ctrl + d]结束输入，就会在当前文件夹下，生成introduce的文件
    ```

  - 

- **tac** 反向列示，由后往前

- **nl** 添加行号打印

#### 分页查看文件内容

- **more**
  - q 离开关闭文件
  - space 向下翻一页
  - b 回翻一页
  - enter 向下滚动一行
  - /字符串 查询字符串
- **less** 
  - pageup
  - pagedown
- **head**
  - -n number 文件，取出文件前number行，默认10行
- **tail**
  - -n number 文件，取出文件末尾number行，默认10行
- **od**：查看二进制文件内容
  - [-t type] 文件
  - type：a、c、d、f、o、x
- **file**：查看文件类型
  - file 文件

## 5.4 查找文件

#### 查找脚本文件

- **which**：根据path环境变量所规范的路径去查询"执行文件"
  - -a，将path环境变量中所有可查找的命令均列出
- **type**：判断每个命令是否为bash的内置命令
  - **type [-tpa] name**
  - t，命令输出这些字眼：`file（外部命令）/alias（命令别名）/builtin（bash内置的命令）`
  - p，如果name为外部命令式，才会输出完整的文件名
  - a，会在path变量定义的路径中查找
- 

#### 查找文件名

- 利用数据库（**/var/lib/mlocate**，数据库每天更新一次，手动更新用updatedb）查找名称

  - **whereis 文件名**

  - **locate [-ir ] 文件keyword**，i忽略大小写差异，r正则表达式

- 直接查找硬盘

  - **find [path] [option]**
  - path 限定查找文件的范围
  - 关于文件时间的参数，-mtime [+- n]， +n代表n天前，-n代表前n天之内，n代表前第n+1天之内 修改过的文件
  - 关于用户的参数
    - -uid n
    - -gid n
    - -user name
    - -group name
    - -nogroup
  - 关于文件的参数
    - -name filename
    - -size [+-] size，查找比size还要大【+】或小【-】的文件，size的单位c（byte），k（1024bytes）
    - -type 查找文件类型
    - perm [+-] mode，+大于当下mode指定的权限，-小于，无符号等于。
  - 

## 5.6 权限与命令间的关系

什么命令在什么样的权限下才能够运行

1. 让用户进入某目录成为“可工作目录”的基本权限
   - 可使用命令：cd等切换工作目录的命令
   - 目录所需权限：用户对这个目录**至少需要x的权限**，如果还要用ls查阅文件名，那么还需要r权限
2. 用户在某个目录内读取一个文件基本权限
   - 可使用命令：cat、more、less等
   - 目录所需权限：**至少x**
   - 文件所需权限：用户需要对文件**至少r权限**
3. 修改文件
   - 可使用命令：nano、vim等
   - 目录所需：至少x
   - 文件所需：至少rw
4. 创建一个文件
   - 目录所需：要具有wx权限，重点在于w
5. 在目录下执行某个命令
   - 目录所需：至少x
   - 文件所需：至少x

# 6 磁盘与文件系统管理

## 6.1 磁盘

![](legend/磁盘结构组成.png)

整个磁盘的第一个扇区特别重要，记录了整块磁盘的重要信息，分别是：

1. 主引导分区（MBR，Master Boot Record）：446bytes，安装引导加载程序的地方。
2. 分区表：64bytes，记录硬盘分区状态。

### 6.1.1 分区表

- 分区的最小单位为柱面，每组记录区记录了该区段的"开始柱面与结束柱面"的柱面号码。

- 分区表最多只能容纳四个分区（硬盘所限），这四个分区被称为**主分区和扩展分区**
- 扩展分区最多只能有一个（操作系统限制），**逻辑分区**是由扩展分区持续切割出来的分区，逻辑分区的数量依操作系统的不同而不同。
- 格式化只能在主分区和逻辑分区。
- 分区的优点：安全性（分区之间互无影响），性能高（在柱面范围内搜寻，而不是整个磁盘进行搜索）

### 6.1.2 MBR

整个开机流程到操作系统之前的动作应该是：

![](legend/开机流程.png)

1. BIOS：
   - 开机的时候计算机系统会主动执行的第一个程序（在主板上）
   - 它会分析计算机有哪些存储设备，会依据用户的设置去取得能够开机的硬盘，并且读取硬盘的MBR
2. MBR：
   - 内包含引导加载程序
3. 引导加载程序（boot loader）：一支可以读取内核文件的程序
4. 内核文件：开启操作系统的功能

## 6.2 文件系统

文件系统是操作系统用于明确**存储设备或分区**上的**文件的方法和数据结构**，即在存储设备上**组织文件的方法**。

每种操作系统能够使用的文件系统并不相同，**Linux的正规文件系统为EXT2，Windows为NTFS，U盘为FAT**。

传统磁盘一个分区只能有一个文件系统，但现在通过**LVM与RAID**技术，可以将一个分区格式化为多个文件系统，也能将多个分区合为一个文件系统。

**inode/block数据访问示意图**

![](./legend/inode-block%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

**FAT文件系统数据访问示意图**

![](legend/FAT数据访问示意图.png)

碎片整理——需要碎片整理的原因就是文件写入的block太过于分散，此时文件的读取性能将会变得很差，通过碎片整理将同一文件所属的block汇合在一起。

### 6.2.1 EXT2

文件系统会将文件数据分为两个部分：**文件权限和属性（权限，所有者，群组，时间参数等）与文件内容**，把这两个部分放在不同的块中，权限和属性放在inode中，文件内容放在data block中。另外还有一个superblock 会记录整个文件系统的整体信息（包括inode与block总量，使用量，剩余量，文件系统的格式与相关信息）。

EXT2在格式化的时候基本是区分为多个**block group块组**，每个块组都有**独立的inode/block/ super block系统**

![](legend/EXT2块组.png)

#### data block

用于放置文件内容

- block的大小与数量在格式化后就不能再改变了（除非重新格式化）
- **block大小决定了最大单一文件的大小和最大文件系统总容量。**
- 每个block内最多只能够放置一个文件的数据，文件若大于block的容量，就会占用多个，若小于，则剩余的block的容量就不能再使用。

#### inode table

主要记录文件的属性以及该文件实际是放置在哪几号block中

- 每个inode大小固定为128bytes，每个文件仅会占用一个inode。
- 文件系统能够创建的文件数量和inode数量有关
- 记录一个block号码需要4byte，Inode里有12个直接指向block块的，一个一次间接（指向存有block号码的block），一个二次间接，一个三次间接

![](./legend/inode结构示意.png)

#### block bitmap

block 使用情况映射表，用于记录哪个block为空或不为空，删除文件时会自动更新该表。inode bitmap亦如是。

## 6.3 文件系统简单操作

### 6.3.1 磁盘与目录的容量

1. **df [-hi] [目录或文件名]**
   - 列出文件系统的整体磁盘使用量
   - h，以空间容量的形式列出（数字后会带上相应的K，M，G的容量单位）
   - i，以inode的容量的形式列出
   - 可以列出
   - **filesystem（文件系统，分区） 1K-blocks（block的个数） Used（已使用） Available（剩余可用），Use%（使用的百分比%），Mounted on（挂载点）**
   - 读取的范围主要是在Super block内信息
2. **du [-hs] [目录或文件]**
   - 会显示指定的目录或文件所占用的磁盘空间。
   - s，仅列出当前文件所占用的空间
   - 这个命令会直接到文件系统内去查找所有文件数据，所以耗时稍长

记录整个文件系统相关信息的地方

### 6.3.2 连接文件ln

1. **hard link**
   - **ln existfile newfile** 建立硬连接
   - 限制：不能跨文件系统，不能连接到目录
   - 创建一个硬连接相当于新建了一个**文件名**（所有文件名都存在目录的block中，当前目录的block还未存满时，不会增加目录的block。）指向了同一个inode，由inode指向实际内容的block。
   - 删除：所有文件名都是一个硬连接，当指向inode的文件名数目为零的时候就会删除inode和实际内容的block。所以当指向inode的文件名不为0时，仅仅会删除相应的硬连接（文件名），而不会删除实际的inode和block
   - 编辑：无论使用哪一个硬连接（文件名）来编辑，最终结果都会都会写入到相同的inode和block中
2. **symbolic link**
   - **ln -s source_file softlink_file** 建立符号连接（快捷方式）
   - 一种类似于windows的快捷方式功能的**文件**（会占用inode和block），可以让你快速的连接到目录或文件
   - 删除：仅删除符号文件
   - 编辑：同样会修改目标的文件。

![](./legend/连接文件.png)

## 6.4 磁盘操作

### 6.4.1 磁盘分区

1. **fdisk [ -l ]  [ 设备名称 ]**
   - **fdisk -l** 系统将会把整个系统能找到的设备的分区均列出来
2. **fdisk /dev/hdc** 回车
   - m，输入m查看帮助
   - p，**查看**分区表
   - n，**新增**一个分区
   - d，**删除**一个分区
   - q，不保存操作离开
   - w，操作写入分区表并离开

### 6.4.2 分区格式化

分区后，自然要对分区进行格式化

1. **mkfs [-t 文件系统格式] 设备文件名**
   - t，可以接文件系统格式，eg：ext3，ext2，vfat等（系统有支持才会生效）
2. **mke2fs**，命令可以设置很详细的参数，但是很麻烦。

### 6.4.3 磁盘检验

如果文件系统真的发生错乱，就可以使用fsck（file system check）来仔细分析一下。

**fsck [ -t 文件系统 ] [-ACay] 设备名称**

- A，依据/etc/fstab的内容，将需要的设备扫描一次
- a，自动修复检查到有问题的扇区
- C，用一个直方图检验进度
- 通常只有身为root且你的文件系统有问题的时候才使用这个命令，否则在正常情况下使用此命令，可能会造成对系统的危害。
- 执行fsck时，被检查的分区务必不可挂载到系统上，即需要在卸载的状态下进行

### 6.4.4 磁盘挂载与卸载

挂载点是目录，而这个目录是进入磁盘分区（文件系统）的入口，在挂载前需要确定：

- 单一文件系统不应该被重复挂载在不同的挂载点中
- 单一目录不应该重复挂载多个文件系统
- 作为挂载点的目录理论上应该都是空目录

挂载：**mount [ -t 文件系统] [ -L label名 ] [ -o 其他options] [ -n ] 设备文件名 挂载点**

卸载：**umount [ -fn] 设备文件名或挂载点**

- 如若进行卸载需要将工作目录移到挂载点之外

### 6.4.5 磁盘参数修改

### 6.4.6 设置开机挂载

我们总是需要让系统"自动"在开机的时候进行挂载

其实**/etc/fstab（file system table）**就是将我们利用mount命令进行挂载时，将所有参数写入到这个文件中就可以。

```bash
#Device                                    Mount point             file system    parameters   dump fsck    
UUID=32f2af94-a1cd-4880-bb61-9ede22264d88      /                     xfs           defaults     0     0

#这个文件的内容共有六个字段，这六个字段非常重要，背下来当然好
Device：磁盘设备文件名或该设备的Label
Mount point：挂载点
File system：磁盘分区的文件系统
parameters：文件系统参数
dump：能否被dump备份命令作用，我们可以通过fstab指定那个文件系统必须要进行dump备份。0不做dump备份，1每天dump，2不定期dump
fsck：是否能被fsck磁盘检验命令作用，0不要检验，1最早检验（一般/才会设置为1），2要检验
```

### 6.4.7 内存交换空间的构建

swap的功能就是在应付物理内存不足的情况下所造成的内存扩展记录的功能

首先，这两个概念分别对应windows和linux，即：

- windows：虚拟内存
- linux：swap分区
- windows的虚拟内存是电脑自动设置的，Linux的swap分区是你装系统的时候分好的

windows即使物理内存没有用完也会去用到虚拟内存，而Linux不一样，Linux只有当物理内存用完的时候才会去动用虚拟内存（即swap分区）

linux的swap类似于windows的虚拟内存，不同之处在于，Windows可以设置在windows的任何盘符下面，默认是在C盘，可以和系统文件放在一个分区里。而linux则是独立占用一个分区，方便由于内存需求不够的情况下，把一部分内容放在swap分区里，待内存有空余的情况下再继续执行，也称之为交换分区，交换空间是其中的部分

## 6.5 磁盘配额



# 7 文件压缩与备份

## 7.1 文件压缩

compress已经很少使用了。

gzip可以说是应用最广泛的压缩命令了，bzip2为了取代gzip并提供更高压缩比而来。

以上仅可对单一文件来进行压缩，tar可以将多个文件和目录打包成一个大文件，并且可以对大文件提供压缩。

1. **compress or ncompress** 
   - **compress [-rcv] 文件或目录**
   - **uncompress 文件.Z**
   - 压缩为***.Z**为后缀的文件
   - r，连同目录下的文件同时压缩
   - c，将压缩输出到standard output （屏幕）
2. **gzip** 
   - **gzip  [ -cdtv#] 文件名**
   - 压缩为***.gz**为后缀的文件，可解\*.Z、\*.gz文件
   - #，指代1-9之间的数字，1最快但压缩比最小，9最慢但压缩比最大，默认6
   - v，显示压缩比等信息
   - **文件还原（解压缩）**：d，**gzip -d 文件名.gz**，与gzip相反，会将原来的.gz删除，产生原来的文件
   - **文件备份并压缩**：c，**gzip -9 -c 文件名 > 压缩后文件名.gz** 
   - **zcat**，用来读取纯文本被压缩后的压缩文件
3. **bzip2**
   - **bzip2 [ -cdkzv#] 文件名**
   - 压缩为***.bz2**为后缀的文件
   - z，压缩
   - d，解压缩
   - k，保留原文件
   - **bzcat**，用来读取纯文本被压缩后的压缩文件
4. **tar**
   - j，通过bzip2的支持进行压缩/解压缩，此时文件名最好*.tar.bz2。z参数是通过gzip
   - t，查看打包文件的内容含有哪些文件名，用于查看压缩文件的文件结构
   - c，新建打包文件
   - x，解打包
   - v，在压缩/解压缩的过程中，将正在处理的文件名显示出来
   - f，处理后的文件名
   - p，保留备份数据的原本权限和属性
   - C，用在解压缩时，若要在指定目录解压缩，可以使用这个参数
   - --exclude=FILE，将FILE过滤不进行打包处理
   - 备份并压缩：**tar -jcv -f   压缩后的文件名.tar.bz2    需要压缩的文件名**
   - 解压缩：**tar -jxv -f   需要解压缩的文件名.tar.bz2    -C   欲解压的目录**
   - 查询（查看文件结构）：**tar -jtv -f 压缩文件名.tar.bz2**

## 7.2 备份

1. **dump**
   - 备份
2. **restore**
   - 恢复
3. 

# 8 vim文本编辑器

vim视作vi的高级版本。

## 8.1 vi模式

1. 一般模式（Normal）：以vi打开一个文件就是一般模式（删除，复制，粘贴）

   - 可以使用上下左右键移动光标，你可以删除字符或删除整行，也可以复制、粘贴你的整行文件数据
   - 一般模式下输入**:wq**保存内容并离开vi
   - **Esc**：由其他模式进入一般模式
   - 模式的切换都必须通过一般模式才能切换到其他模式
2. 编辑模式（Insert）：一般模式+编辑内容

   - 输入**i**：由一般模式进入编辑模式
3. 命令行模式（Command）：提供命令操作的额外功能
   - **输入：号**：进入命令行模式
   - 查找数据、替换字符等命令操作
4. 可视模式（Visual）：
   - 输入v：进入可视模式
   - 通过移动上下左右，选中文本，y复制，p粘贴，^选中光标当前位置到行首，$选中光标当前位置到行末
   - 输入**Ctrl + v** 进入可视模式的块选择
   - 输入V：进入可视模式的行选择
5. 选择模式（select）
   - 在gvim的常用模式
   - 输入gh：进入选择模式
   - 用鼠标拖选区域，选择完了高亮区域后，敲任何按键就直接输入并替换选择的文本了

## 8.2 按键说明

| 按键              | 说明                             |
| ----------------- | -------------------------------- |
|                   |                                  |
| 一般模式          |                                  |
| 【**home**】      | 光标移至行首                     |
| 【**end**】       | 光标移至行末                     |
| 【**↑ ↓ ← →**】   | 上下左右移动一个字符             |
| 【 **u** 】       | 撤销操作                         |
| 【**Ctrl + r**】  | 还原上一步操作                   |
| 【**p**】         | 将已复制数据，粘贴在光标后       |
| 【**P**】         | 将已复制数据，粘贴在光标前       |
|                   |                                  |
| 命令行模式        |                                  |
| 【**:w**】        | 将数据写入硬盘                   |
| 【**:q**】        | 离开vim                          |
| 【**:q!**】       | 修改了文本，不想保存，想强制离开 |
| 【**:wq**】       | 保存并离开                       |
|                   |                                  |
| 编辑模式          |                                  |
| 【 **i** 】       | 一般模式切换到编辑模式           |
| 【**dd**】        | 删除光标所在行                   |
| 【**yy**】        | 复制光标所在行                   |
|                   |                                  |
| 可视模式          |                                  |
| 【**↑ ↓ ← →**】   | 从光标处选中内容                 |
| 【**y**】         | 复制选中的内容                   |
| 【**^ or home**】 | 从光标处到行首选中内容           |
| 【**$ or end** 】 | 从光标处到行末选中内容           |
|                   | 块选择                           |
|                   |                                  |

## 8.3 多文件编辑

**场景：**

如果需要将A文件中文本复制到B文件中去，通常需要开两个vim窗口来复制，偏偏每个vim都是独立的，因此没有办法将A文件中执行的“nyy”再跑到B文件中去执行“p”。

**解决：多文件编辑**

**vim 文件1 文件2 文件3**

按键：

- **:n**，编辑下一个文件
- **:N**，编辑上一个文件
- **:files**，列出当前这个vim打开的所有文件

当然这个功能也可以通过多窗口功能达到。

## 8.4 多窗口功能

**场景：**

1. 当有一个文件特别大，查阅到后面的内容的时候，想要对照前面的数据，又不想通过翻页前后来回查阅
2. 有两个需要对照着看的文件，不想使用到前面的多文件编辑功能

**解决：多窗口**

在vim命令行模式下输入

1. **:sp [filename]**
   - 打开新窗口，如果有加filename，表示在新窗口打开一个新文件，否则两个窗口显示的是同一个文件的内容。
2. **Ctrl+w+ ↑ ↓**，先按下Ctrl + w，然后放开，在按下↑或↓，移动光标到上下面的窗口。
3. **Ctrl+w+q**，结束下方的窗口

## 8.5 vim环境设置

如果曾经使用过vim，那么在你的主文件夹内就会存在一个记录操作的文件：**~/.viminfo**，下次再打开vim他会记住你之前的操作。

整体的vim配置文件一般放置在**/etc/vimrc**文件中，不过不建议它，可以修改**~/.vimrc**这个文件（默认不存在，可以自行创建）将你所希望的值写入。

![](./legend/vim常用命令示意图.png)

# 9 bash

![](./legend/硬核、内核与用户的相关性示意图.png)

只要能够操作应用程序的接口都能够称为shell，我们必须要通过“shell”将我们输入的命令与内核通信，好让内核可以控制硬件来正确无误的工作。

shell是看不见摸不着的，终端不是shell。

shell的版本众多，可以在**/etc/shells**文件中看到，我们可以使用哪些shell。

**“Bourne Again SHell（简称bash）”**就是比较流行的一个shell版本，bash是GNU计划中重要的工具软件之一。

## 9.1 bash初步

### bash功能

1. 命令记忆功能（history），前一次登录以前执行的命令记录在主文件夹内的**.bash_history**
2. 命令与文件补全功能（Tab），Tab按键用于补全
3. 命令别名设置功能（alias），eg：**alias lm=' ls -al '**
4. 作业控制、前台、后台控制（job control，foreground ，background）
5. 程序脚本（shell script），可以将平时管理系统常需要用的连续命令写成一个文件，该文件支持交互的方式
6. 支持统配符

### bash内置命令判断：type

**type**：判断每个命令是否为bash的内置命令

- **type [-tpa] name**
- t，命令输出这些字眼：`file（外部命令）/alias（命令别名）/builtin（bash内置的命令）`
- p，如果name为外部命令式，才会输出完整的文件名
- a，会在path变量定义的路径中查找

### 命令的执行

`\`反斜杠的应用在命令太长时，换行便于查看编辑

## 9.2 shell变量

命令别名，自定义的变量在你注销bash后就会失效，所以你想要保留你的设置，就得将这些设置写入配置文件才行

### 9.2.1 变量的显示与设置

1. **echo**：显示变量

   - **echo $变量名**
   - **echo ${变量名}**，常用于数字参数的变量，以及对变量进行删除替换等操作时（相当于计算变量）
   - echo 功能有很多，这里只是用到了查看变量的功能
   - 列出当前环境变量）——env
   - 列出所有变量（包含环境变量与自定义变量）——set

2. 设置自定义变量

   - 格式：**var_name=var_val**

   - 变量间赋值：**var1=${var2}**

   - 规则：

     - 等号两边不能直接接空格，变量命名只能是英文和数字（数字不能开头）

     - 变量的值若有空格，可用双引号或单引号将值罩起来。

       - 双引号可以解析值中的变量（占位符），而单引号不行

         ```bash
         qi=kh
         mine="my name is $qi" 
         echo $mine
         # my name is kh
         mine='my name is $qi' #重新赋值
         echo $mine
         # my name is $qi
         ```

     - 特殊符号用反斜杠`\`转义

     - **追加变量内容**

       ```bash
       PATH="$PATH":/home/bin
       ```

     - **环境变量**（全局变量）：**export var_name**

3. **取消变量unset**

   - **unset var_name**

### 9.2.2 环境变量env

#### 变量列表

**env——查看所有环境变量**

**常见环境变量**

- HOME：代表用户主文件夹的位置，通过cd ~或者直接cd就可以切换到这个文件夹
- SHELL：当前这个环境使用的shell是那个程序
- PATH：就是执行文件查找的路径，目录与目录间通过冒号**":"**相隔

**set——查看所有变量（包含环境变量与自定义变量）**

常见自定义变量

- **PS1**：命令提示符，在命令之前的部分，也可以修改，可以查看相关资料修改

  ```bash
  [root@iZbp1a1nnstgr4w2bu73ovZ ~]# cd ../etc
  ```

- **$：关于本shell的线程号PID**

- **?：关于上个命令的回传码**

- OSTYPE，HOSTTYPE，MACHTYPE：主机硬件与内核等级

#### 自定义变量转环境变量

**export var_name**

环境变量与自定义变量的区别在于：该变量是否会被子进程所继续引用。

当你登录linux并取得一个bash后，你的bash就是一个独立的进程。

在一个bash（父进程）中执行另一个bash（子进程），父进程就会处于暂停sleep的情况，只有子进程结束或被exit才能回到父进程中。

**子进程会继承父进程的环境变量，而不继承自定义变量**

**变量作用域**：被export后的变量，我们称为环境变量（全局变量）。环境变量可以被子进程所引用，但是自定义变量（局部变量）则不会存在于子进程中。

### 9.2.3 键盘读取变量

- **read** 
  - `read [ -pt ] var_name`
  - p，后面接输入提示文本
  - t，输入等待时间，记住输入后一定要按回车，否则时间结束后依旧不能声明变量

### 9.2.4 declare声明变量类型

- **declare**

  - `declare [-aixr] var_name`

  - a，array，声明为数组变量

  - i，integer，声明为整形变量

    ```bash
    declare -i total=100+300+50
    echo $total
    #450
    ```

  - x，声明为环境变量，+-x，可以变换作用域

  - r，设置为只读

### 9.2.5 array变量

```bash
var[1]="first 1"
var[2]="second 2"
var[3]='last 3'
echo ${var[1]},${var[2]},${var[3]}

```

### 9.2.6 变量内容的删除、替代与替换、追加

**删除与替代，对原变量没有影响**

| 变量设置方式          | 说明                                                   |
| --------------------- | ------------------------------------------------------ |
| ${var#关键字}         | 变量内容从开头匹配"关键字"，将符合的最短数据删除       |
| ${var##关键字}        | 从头，最长匹配删除                                     |
| ${var%关键字}         | 从尾，最短匹配删除                                     |
| ${var%%关键字}        | 从尾，最长匹配删除                                     |
| ${var/旧子串/新子串}  | 变量内容符合旧子串，替换第一个被匹配到的旧子串为新子串 |
| ${var//旧子串/新子串} | 匹配旧子串，将变量内容中的所有旧子串替换为新子串       |

**变量的测试与内容的替换**

在某些时刻我经常需要判断某个变量是否存在，若存在，使用既有设置，若不存在则给予一个新值。

**冒号:**能识别str是否为空字符串`''`，将空字符串也认定为变量str未设置。

**减号-**为str为未设置（未定义）时，起到赋值作用

**加号+**为str为已设置时，起到赋值作用

**等号=**与减号的作用相似，**只是赋值的作用会影响到str**

**var=${str [ : ] [ +-= ]  expr }**

**追加内容**

```bash
PATH="$PATH":/home/bin
```



## 9.3 命令别名与历史命令

命令别名，自定义的变量在你注销bash后就会失效，所以你想要保留你的设置，就得将这些设置写入配置文件才行

### 9.3.1 命令别名

命令别名是一个很有趣的东西，特别是你惯用的命令特别长的时候

1. 设置别名**alias**：
   - **alias  other_name='replace_operation'**
   - alias定义规则与变量定义规则几乎相同
   - 替代既有命令：`alias rm='rm -i'`
   - 查看别名列表：`alias`
   - `eg：alias lm='ls -l | more'`，以后输入lm的命令就和`ls -l | more `的命令是一样的效果
2. 取消别名**unalias**：
   - **unalias other_name**
3. 

### 9.3.2 历史命令

**history**

- **n**：列出最近的n条命令
- **-c**：将目前shell中的所有history内容全部清除（当前登录的历史）
- -r：将histfiles中的内容读到目前的shell的history记忆中
- -w：将目前shell中history记忆内容更新到histfiles中，历史命令在我注销后，会将最近的HISTSIZE条记录到~/.bash_history中
- -a：将目前新增的history命令新增到histfiles中，若没有histfiles，则增加到**~/.bash_history**中

**历史命令执行**

- !!：执行上一个命令
- !n：执行第那条命令
- !command：由最近的命令向前搜寻以command开头的命令，并执行

## 9.4 bash shell操作环境

### 9.4.1 路径与命令查找顺序

命令执行顺序

1. 以相对/绝对路径执行命令，
2. 由alias找到该命令来执行
3. 由bash内置的（builtin）命令来执行
4. 通过$PATH这个变量的顺序找到第一个命令来执行

### 9.4.2 bash登录与欢迎信息

**登录之前显示**：/etc/**issue** 和 /etc/issue.net ：

- 前者/etc/issue：一个负责本地登录前显示， 是显示在TTY控制台登录前（非图形界面）
- 后者/etc/issue.net ：负责网络登录前显示。是显示在 Telnet (SSH默认不开启)远程登录前

登录之后显示（欢迎信息）：/etc/**motd**，不管你是 TTY 还是 PTS 登录，也不管是  Telnet 或 SSH 都显示这个文件里面的信息。

### 9.4.3 环境配置文件

环境配置文件让bash在启动是直接读取这些配置文件，以规划好bash的操作环境。

配置文件又可以分为全体系统配置文件以及用户个人的偏好配置文件

login shell与non-login shell

1. login shell ：取得bash时需要完整流程的，就称login shell，eg：你要由tty登录，需要输入账号和密码，此时取得的bash就称login shell
2. non-login shell：取得bash接口的方法不需要重复登录的举动，
   - eg1：在x window图形界面中启动终端机（此时没有再输入账号密码）
   - eg2：在原本的bash环境下在次执行bash这个命令（此时没有再输入账号密码），那第二个bash（子进程）也为non-login shell

这两种情况会导致读取的配置文件不一样，我们首先谈谈**login shell**会读取以下文件

1. 系统整体配置
   - `/etc/profile`：login shell 必读，他还会调取外部设置数据，centos5.x会默认依序被调用进来
     - `/etc/inputrc`：自定义输入按键功能
     - `/etc/profile.d/*.sh`：这个目录下面的文件规定了bash操作接口的颜色、语系、ll与ls、vi、which的命令别名等**，如果想帮所有用户设置一些共享的命令别名可以在这个目录下自行创建扩展名为.sh的文件，并将所需写入即可**
2. 个人偏好设置
   - bash在读完整体环境配置后，接下来就会读取用户个人的配置文件
   - 依序读取`/~/.bash_profile > /~/.bash_login > /~/.profile`，前面的文件如存在，就不会再读后面的文件
   - `/~/.bash_profile会再调取/~/.bashrc`。**所以我们可以在此将自己的偏好设置写入该文件（`/~/.bashrc`）**
3. login_shell的配置文件读取流程

![](./legend/login_shell的配置文件读取流程.png)

**手动更新配置：source**

- **source 配置文件**

**non-login shell会读：**`~/.bashrc，而bashrc还会调用/etc/bashrc`

**其他相关配置文件**

- `/etc/man.config`：执行man时man page的路径到哪里去找
- `~/.bash_history`：历史命令
- `~/.bash_logout`：当我注销bash后系统再帮我做完什么操作才离开

### 9.4.4 终端机快捷键

**快捷键设置**

查看终端机**"特殊功能"**按键列表：**stty -a**，stty（setting tty）

输出的**^**代表【Ctrl】的意思，其他的eof，erase，intr等自行查阅便知

**按键修改**，eg：**stty erase ^h**

修改终端机设置值，**set [ -uvCHhmBx ]**

**常用快捷键**

| 组合键        | 意义                                                     |
| ------------- | -------------------------------------------------------- |
| Ctrl + C      | 终止当前输入的命令，终止运行的程序                       |
| Ctrl + D      | 退出bash子进程，or 输入结束（eof），从光标删右方一个字符 |
| Ctrl + Z      | j将运行的程序送到后台                                    |
| Ctrl + L      | q清屏                                                    |
| Ctrl + R      | s搜索历史命令，搜索到回车即可执行                        |
| Ctrl + U or K | c从光标位删至行首or行尾                                  |
| Ctrl + S or Q | 暂停or 恢复屏幕输出                                      |



### 9.4.5 通配符与特殊符号

| 通配符       | 意义                           |
| ------------ | ------------------------------ |
| *****        | 0到多个任意字符                |
| **？**       | 至少一个任意字符               |
| **[ ]**      | 字符集，eg：[abceft]           |
| **[ - ]**    | 字符段，eg：[a-z]              |
| **[ ^ ]**    | 取非，eg：`[^a-z]`，非小写字母 |
|              |                                |
| **特殊符号** | **意义**                       |
| #            | 批注                           |
| \            | 转义                           |
| **\|**       | 管道符                         |
| **;**        | 命令分割符                     |
| **~**        | 用户主文件                     |
| **$**        | 变量前导符                     |
| **&**        | 作业控制                       |
| **!**        | 非                             |
| **/**        | 目录符号，路径分割符           |
| **>,>>**     | 数据流重定向，输出导向         |
| **<,<<**     | 数据流重定向，输入导向         |
| **''**       | 不具占位符                     |
| **""**       | 具占位符                       |
| **``**       |                                |
| **( )**      | 子shell的起始与结束            |
| **{ }**      | 命令块组合                     |
|              |                                |
|              |                                |

## 9.5 数据流重定向

数据流重定向就是将某个命令执行后应该要出现在屏幕上的数据传输到其他地方去，例如文件或设备

![](./legend/命令执行过程的数据传输情况.png)

1. **标准输入stdin**：需要由键盘输入的数据改由文件内容来替代，代码为**0**，使用 <（指定内容输入文件） 或 <<（设置终止符）；
2. **标准输出stdout**：命令执行所回传的正确信息，代码为**1**，使用 **>（覆盖内容） 或 >>（追加内容）**
3. **标准错误输出stderr**：命令执行失败后，所传回的错误信息，代码为**2**，使用 2>（覆盖内容） 或 2>>（追加内容）



```bash
####标准输出####

#屏幕不输出任何信息，~下有一个mine文件创建。
ls -al / > ~/mine 
#若~下mine文件不存在，则创建
#若存在，则清空文件，在写新数据
# >> 追加数据到原文件

#将stdout写入list_right文件，将stderr写入list_error
find /home -name .bashrc > list_right 2> list_error

#stdout与stderr写入同一个文件
find /home -name .bashrc > list 2>&1
find /home -name .bashrc &> list

#垃圾黑洞设备/dev/null
find /home -name .bashrc 2> /dev/null

####标准输入####

cat > introduce << "eof"
my name is lxx, hen gao xin ren shi da jia
eof
#eof作为文本输入的结束，而不需要按Ctrl+d

#将introduce的内容复制到catfile文件中
cat > catfile < introduce
```

### 命令执行的判断

很多命令我想要一次输入去执行，而不想要分次执行。除了通过shell script，可以通过 **;  &&  ||**

- 如若命令之间**无相关性**可以通过命令间间隔**`;`**分号，
  - **cmd1 ; cmd2 ; cmd3**
- 如若命令之间**有相关性**可以通过 **`&&  ||`**来实现
  - **cmd1 && cmd2**，cmd1执行成功才执行cmd2
  - **cmd1 || cmd2**，cmd1执行失败才执行cmd2
  - cmd1 || cmd2 && cmd3，cmd1执行成功后执行cmd3，cmd1执行失败执行cmd2，cmd2执行成功后执行cmd3

## 9.6 管道命令（pipe）

![](./legend/管道命令的处理示意图.png)

命令输出的数据需要经过几个连续命令的处理，才是我们想要的数据，就会用到管道命令。

**注意**：

- 管道命令仅会处理stdout，对stderr会予以忽略
- 管道命令必须要能够处理来自前一个命令的stdout作为自己的stdin才行。
- 在管道命令里**“  -  ”**可以表示stdin或者stdout

### 9.6.1 选取命令

一般来说，选取信息通常是针对**“行”**来分析的，并不是整篇信息分析的。

1. **cut**
   - 从一行信息中取出我们想要的某些段
   - **cut  -d  'divider'  -f  field1 [, field2, field3 ] **：d 后面接分隔符（' ' 表示空白符），f 后面接我们以分隔符分割的第几段，用整数n
   - **cut -c n1-[n2**]：以字符数为单位，显示字符区间的内容
2. **grep**
   - 分析一行的信息，若有我们想要的信息，则取出该行
   - **grep [ -acinv ] [ --color=auto ]  '查找字符串'  filename**
   - i，忽略大小写
   - n，顺便输出行号
   - v，反向选择，即显示出没有"查找字符串"的行
   - c，计算“关键字”在所在行出现的次数

### 9.6.2 排序去重统计命令

计算数据里相同类型的数据总数，类似于数据库里的聚合函数般。

1. **sort**
   - **sort[ -tkuf ] filename**
   - t，分隔符，默认tab
   - k，以分割符分割的第几个字段排序
   - u，相同数据取其一，去重
   - f，忽略大小写
2. **uniq**
   - 内容排序完成，去重
   - uniq [ -ic ]
     - i，忽略大小写
     - c，重复项计数
3. **wc**
   - 统计内容数据（word count）
   - **wc [-lwm]**
   - l，列出行数
   - w，流出单词数
   - m，列出字符数

### 9.6.3 字符转换命令

比如说将内容中大写改小写，tab转空格键

1. **tr**
   - 删除或替换
   - **tr [ -ds ] SET_OR_STR**
   - d，删除
   - s，替换
2. **col**
   - **col [ -xb ]**
   - x，将tab转换成对等的空格键
3. **join**
   - 处理两个文件之间的关联数据，将两个文件中有相同数据的那一行续接在一起。类似于数据库中的**关联查询**
   - **join [ -ti12 ] file1 file2**
   - t，分隔符，默认以空格，并且对比两个文件的第一个字段
   - i，忽略大小写
   - 1，第一个文件用哪个字段
   - 2，第二个文件用哪个字段
4. **paste**
   - 直接将两个文件的同行，连接在一起
   - **paste [-d] file1 file2**
   - d，分割符，默认tab
   - -，如果file写成-，表示stdin

### 9.6.4 切割命令

如果一个文件太大，导致一个携带式设备无法复制的问题，通过split，就可以将一个大文件依据文件的**大小或行数分割成小文件**

**split [-bl] file prefix_name**

- b，按文件内存大小进行分割，例如b，k，m等
- l，按行数进行分割
- prefix_name，小文件名的前缀

### 9.6.5 参数代换

xargs可以产生某个命令的参数，xargs 可以读入stdin的数据，并且以空格符或断行字符进行分辨，将stdin的数据分割成arguments。

**xargs [ -0epn ] command**

- 将stdin的内容经xargs分析后，处理成参数（或者多组参数），一组参数作为command的参数使用
- eof，停止分析符
- n，多少个参数为一组
- p，每输入一组参数执行command前询问用户是不是要执行，执行输入y

### 9.6.6 双向重定向

**tee**

- **tee会同时将数据流送予文件与屏幕**
- **tee [-a] file**
- a，以累加（append）的方式

## 9.7 shell script

shell script 是利用shell的功能所写的一个“程序”，这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式，管道命令与数据流重定向等功能，以达到我们所想要批处理的目的。

### 9.7.1 script 基本

注意：

1. 命令的执行从上而下，从左而右。
2. 命令、参数间的多个空白，空白行会被忽略，tab会视为空白
3. 读到enter就会执行，"\\[enter]"让一条命令扩展至下一行
4. #用来做批注

#### 1 第一个script

```bash
#!/bin/bash
# Program:
# This program shows ...
# History：
# 2005/08/23
PATH=/bin:/sbin:/usr/sbin/:/usr/local/sbin
export PATH
echo -e "Hello World! \a \n"
exit 0
```

1. **#!/bin/bash**：第一行是声明这个script使用的shell名称
   - 通过这一句，当这个程序被执行时，它就能够加载bash的相关配置环境配置文件
2. **PATH**：
   - 主要环境变量的声明
   - 这里相当于一般程序里的**import**的功能
   - 建议务必要将一些重要的环境变量设置好（设置PATH与LANG等)，如此一来，则可让我们这个程序在进行时直接执行一些外部命令，而不必写绝对路径。
3. **echo**
   - 主要程序部分
4. **exit**
   - 告知执行结果。
   - 讨论一个命令执行成功与否，可以使用**$?**这个变量来看看。
   - exit n相当于一个return flag，我们可以通过查看$?这个flag来查看程序的执行情况如何

#### 2 script执行方式

假设现在写了一个程序文件名是/home/scripts/myshell.sh

1. 直接命令执行：myshell.sh文件必须要具备可读与可执行**（rx）**的权限
   - 绝对路径：命令行直接输入：**/home/scripts/myshell.sh**
   - 相对路径：假设工作目录在/home/scripts，则命令行直接输入：**./myshell.sh**
   - 变量PATH的功能：将myshell.sh放到PATH指定的目录内，例如：/bin。然后在命令行直接输入：**myshell.sh**即可
2. 以bash进程来执行
   - 假设工作目录在/home/scripts，命令行直接输入：**bash myshell.sh** 或者 **sh myshell.sh**
3. 利用source来执行脚本
   - 假设工作目录在/home/scripts，命令行直接输入：**source myshell.sh**

**区别：**

1. 前二者：他们都会使用一个新的bash环境来执行script（**子进程的bash内执行**），script执行完毕后，bash内的数据都会被删除
2. 后者：**在父进程中执行**，各项操作数据都会在原本的bash内生效

![script执行方式的区别.jpg](./legend/script执行方式的区别.jpg)

### 9.7.2 判断式

判断式就如同其他程序语言中用于输出true or false的条件判断句，然而在bash中是通过执行命令，命令返回**$?**这个变量来判断的。

这里还有其他一些常用的判断式

#### 1. 判断命令test

1. 判断文件名的类型，
   - **test [ -efdbcSpL ] filename**，
   - e—filename是否存在，f一判断是否存在并为file类型，d—directory，b—block device，c一character device，S一socket文件
2. 检验文件的权限
   - **test [ -rwxugks ] filename**
   - r一判断文件是否存在并具有可读权限，w一可写，x—可执行，u一SUID属性，g—SGID属性，s—非空白文件
3. 两个文件之间比较
   - **test file1 [-nt ot ef] file2**
   - nt—newer than判断file1是否比file2更新，ot一older than，ef一判断是否为同一个文件
4. 关于两个整数之间的判定
   - **test n1 [-eq nq gt lt ge le] n2**
   - eq一equal，ne一not equal，gt一greater than，lt一less than，ge—greater or equal，le—less or equal
5. 判定字符串的数据
   - **test [-zn] string**
   - z一若为为空字符串，则true，n一若为非空字符串，则true
   - **test str1[!]=str2**
   - 判断两个字符串是否相等
6. 多重条件判定
   - **test cond1 [-ao] cond2**
   - a—and 两个条件必须同时成立，则为true。o—or 任一条件成立，则为true
   - **test ! cond**
   - 条件取非
7. 

#### 2. 判断符号[ ]

中括号就相当于test，上面的命令判断语句，可以通过让中括号括起来而去掉test关键字，形成判断句。

中括号常用在条件判断式中if...then...fi中

注意：

1. **中括号[ ]内的每一个组件都需要有空格键来分割**
2. 中括号内的变量和常量，都需要用双引号括起来（否则有可能会出现一些意想不到的错误）

```bash
eg:
[ "$HOME" == "/bin" ]
```

### 9.7.3 命令的位置参数

这个概念就如同javascript，或python函数的参数列表一样，只不过在bash中这个函数概念换成了命令。当然bash中也有函数这个概念，后面会说到。

shell script 可以在脚本文件名后面带参数。而不需要像read命令在执行过程中再去输入参数。

eg：**/~/scripts/myshell.sh param1 param2 param3 param4**

在script脚本中可以使用以下变量去引用位置参数的值

- $0：这个变量用于获取执行脚本的名字
- $#：获取参数的个数
- $@：获取整个参数字符串，每个参数间通过空格键分割
- $n：n为位置的索引，$1，$2

**shift未知参数的移除和偏移**

**shift [n]**，这个就如同javascript数组的shift函数功能，用于移除位置参数序列的前n个元素。

### 9.7.4 条件语句

条件书写：

```bash
[cond1 -a cond2 ] && [ cond3 ] || [ cond4 ]
```



```bash
#单判断条件语句
if [ cond1 ]; then
	程序段1
else
	程序段2
fi #条件语句结束

#多判断条件语句
if [ cond1 ]; then
	程序段1
elif [ cond2 ]; then
	程序段2
else
	程序段3
fi #条件语句结束

case $var in
"state1")
 	程序段1
 	;;
"state2")
 	程序段2
 	;;
*)#用*表示其他状态
 	程序段n
 	exit 1
 	;;
esac
```

### 9.7.5 循环语句

```bash
#while循环
while [ condition ]
do
	程序段
done

#do循环
until [ condition ]
do
	程序段
done

#foreach循环
for var in constant1 constant2 constant3
do
	程序段$var可以获取constant列表的内容
done

#for循环
s=0
for ((i=0; i<$var; i=i+1 ))
do
	s=$(($s+$i))
done
```

### 9.7.6 函数

```bash
#函数声明
function fname(){
    程序段,同样程序段里可以获取位置参数
    #$1,$2
}
#函数调用
fname one two three

```

### 9.7.7 script调试

**sh [ -nvx ] myshell.sh**

- n，不要执行script，仅检查语法的问题
- v，在执行script前，先将script的内容输出到屏幕
- x，将使用到的script内容显示到屏幕

# 10 系统用户管理

## 10.1 用户与用户组

每个登录的用户都会拥有UID（userID）和GID（groupID）。

- **用户的属性信息放在/etc/passwd中**
- **用户的密码信息放在/etc/shadow中**
- **用户组信息放在/etc/group中**

在tty或pts上登录，输入账号及密码后：

- 会在passwd中核对账号信息，
- 如果有该账号读出在group中读出用户组信息，获得shell以及主文件设置，
- 最后在shadow中核对密码，如通过，进入shell

### 10.1.1 用户属性/etc/passwd

```bash
#/etc/passwd中的内容

#系统管理员
root:x:0:0:root:/root:/bin/bash
#系统账户
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin

#1.用户名:2.密码占位符:3.UID:4.GID:5.用户描述信息:6.用户主文件夹:7.shell

#密码占位符，为防止密码数据被窃取所以用x代替并占位
```

1. UID

   用户标识符，通常有下面表格的限制

   - **UID：0（系统管理员）**
     - root
     - 如果想让其他账号也拥有root的权限，即可以将该账号的UID设为0
     - 不过不建议一个系统有多个UID是0
   - **UID：1~499（系统账户）**
     -   保留给系统使用的ID
     - 其实除了0除外，UID的权限与特性并没有什么不同
     - 由于系统上面的服务希望使用较小的的权限去运行，因此不希望使用root的身份去执行这些服务，所以我们就得要提供这些运行中程序的所有者账号才行。
     - 这些系统账号通常是不可登录的，所以才有/sbin/nologin这个特殊的shell存在
     - 系统账号又被分为两种：
       - 1~99：distribution自行创建的系统账号
       - 100~499：若用户有系统账号又需求时，可以使用的账号UID
   - **UID：500~65535（可登录账号）**
     - 给一般用户使用的，Linux内核2.6.x版已经可以支持（2^32-1）个账户

### 10.1.2 用户密码/etc/shadow

```bash
root:$6$X5uAD/PT$L2FvLYS3/0yLiaWg6le214Hj5fJpiNeT8Giw25rFjPn9YPfFQKTmlalbUfJylQJO7EoGPz1P1drDPo75l3eX1.:18542:0:99999:7:::
#1.用户名:2.密码:3.最近改动密码的时间
#:4.密码(再次)更改需要等待的最短时间:5.密码需要再次更改的时间（过期时间）:6.密码过期前几天开始警告提醒
#:7.过期后宽限时间段（失效时间，宽限时间内在登陆时，强制修改密码的时间区间）:8.账号失效日期(无论是否过期，账号无法使用的日期，常用于收费的系统中）
#:9.账号保留字段
```

### 10.1.3 用户组/etc/group

```bash
root:x:0:
bin:x:1:
daemon:x:2:
#1.用户组名称:2.用户组密码的占位符（一般给用户组管理员使用，现在已很少使用了，密码已经移动/etc/gshadow去了）
#:3.GID
#:4.此用户组支持的账号名称列表（user1,user2...）
```

有效用户组与初始用户组

1. /etc/passwd中的GID就是**初始用户组**，
   - 一登录就会立刻拥有此用户组的权限
   - 创建的时候若指定用户组，那么初始用户组就是此用户组。
   - 若没有指定那么初始用户组，就是系统就会创建一个与用户名同名的用户组，
2. 当用户加入一个非初始用户组的时候，**需要在/etc/group的该非初始用户组上的第四列添上该用户组支持的用户名**
3. 当用户拥有多个用户组时，那么在创建文件的时候，文件所属用户组该是哪一个用户组呢？这时的用户组指向**有效用户组**

#### 当前用户的用户组相关命令

1. **groups**
   - 查看当前登录用户的有效用户组与支持用户组
   - 输出的信息中，第一个用户组名为登录用户的有效用户组，其余为该登录用户的所支持的用户组
2. **newgrp**
   - **newgrp switch_group**
   - 有效用户组的切换
   - 用户只能在支持的用户组中切换
   - 这个命令是启动了一个**子shell**来提供此功能的，要想回到原来的环境需要通过**exit**回到原本的用户组
   - 如何**修改用户的支持用户组**，通过系统管理员（root）usermod帮你定义多个用户组。

## 10.2 账号管理

### 10.2.1 系统管理员管理用户列表

系统管理员能够使用的命令

#### 1 新增用户

登录系统会输入账号与密码，**账号可以用useradd来新建，密码的给予则使用passwd**

##### 增加用户名

**useradd**

- **useradd [-ugGmMcds] 用户名**
- u一UID，g—初始用户组，G—支持用户组列表，m—要创建用户主文件夹，M—不要创建用户主文件夹，
- c—用户描述文本，d—用户主文件夹的绝对路径（不使用默认值），s—shell环境，e—账号失效日期
- r—创建系统用户（不会创建主文件夹）
- 此时账号创建后，账号是暂时封锁的，该账号无法登录

**useradd 默认值**

- **useradd -D**：default，查看useradd默认值
- 数据在**/etc/default/useradd**，默认值在这个文件中
- GROUP：两种机制
  - 私用用户组机制（创建一个与用户名的同名用户组，代表性distribution为Rhel，Fedora，Centos等，此项在centos不生效）
  - 公共用户组机制（创建用户的GID默认值，就是此项设置的值，代表性的distribution为SuSe）
- HOME：用户主文件夹基准目录
- INACTIVE：密码过期后是否会失效的设置值，-1代表密码永远不会失效，如果是正整数，那么在过期后对应天数会失效
- EXPIRE：账号失效日期
- SHELL：默认使用的shell程序名（/bin/bash）
- SKEL：用户组文件夹内的内容参考文件
  - 新建用户主文件夹内的各项数据都是有**/etc/skel** 所复制过去的
  - 将来如果我想要新增用户是，该用户的~/.bashrc设置妥当的话，你可以去/etc/skel/.bashrc编辑一下，新建一个文件，以后新增用户后，就会默认在它的主文件夹内就会有那个文件
- PASS_xxx_xxx：密码相关的默认设置
- UID_xxx、GID_xxx：UID/GID相关默认设置
- USERGROUPS_ENAB：使用userdel删除用户时，是否会删除初始用户组



##### 给予密码

**passwd**

- passwd [ --stdin ] 所有人均可使用此来修改自己的密码
- passwd [ -luSnxwi] 用户名
- l—lock使密码失效，u—unlock，**S—列出该用户密码相关参数，**
- n—修改密码最小间隔（天数），x—密码过期时间（天数），w—密码过期前警告（天数），i—密码失效日期

**chage**

- 查看详细的用户密码相关信息
- **chage [-ldEImMW] 账户**
- l—列出该账号详细密码参数，d—最近改密时间，E—账号失效日（日期），I—密码失效日（天数）
- 天数：m—密码修改最短间隔，M—密码过期日，W—密码警告提醒日

#### 2 删除用户

目的在于删除用户的相关数据，而用户的数据有/etc/passwd，/etc/shadow，/etc/group，/etc/gshadow，/home/username等

**userdel [ -r ] username**

- r，连同用户的主文件夹一并删除
- 如果用户只是暂时不启用该账户，在/etc/shadow 里面的账号的第八个字段置为0（失效日期）即可，
- 如果用户在系统上用过一段时间后，会产生一些其他文件，可以查到这些文件后再删除（**find / -user username**）

#### 3 修改用户

**usermod [ - cdegGlsuLU ] username**

- c—用户描述，d—主文件夹绝对路径，e—失效日期，f—过期后宽限日期，g—初始用户组，G—支持用户组
- l—账号名称，s—shell，u—UID，L—lock，U—unlock

### 10.2.2 一般用户功能

一般用户身份常用的账号数据修改与查询命令

1. **finger**
   - 描述，**查阅**自身用户相关信息，大部分都是**/etc/passwd里的**
   - **finger [ -s ] username**
   - s—仅列出账号，全名，终端机代号与登录时间等
2. **chfn**
   - **chfn [ -foph ] username**
   - 修改的是用户描述信息（/etc/passwd的第五个字段）
   - f—全名，o—office，p—phone，h—座机
3. **chsh**
   - change shell
   - **chsh [ -ls ]**
   - l—列出目前系统上面可用的shell
   - s—setting，设置修改自己的shell
4. **id**
   - **id [ username ]**
   - 查询自己或某人的UID或GID的相关信息（uid，gid，groups）

### 10.2.3 用户组管理

用户组的内容与这两个文件有关：**/etc/group、/etc/gshadow**

1. **groupadd**
   - 新增用户组
   - **groupadd [ -gr] group_name**
   - g—指定GID，r—指定新建系统用户组
2. **groupmod**
   - 修改用户组
   - **groupmod [ -gn ] group_name**
   - g—修改GID，n—修改用户组名
3. groupdel
   - 删除用户组
   - **你必须确认/etc/passwd内的账号没有任何人使用该用户组作为初始用户组**

#### 用户组管理员

就是让某个用户组具有一个或多个管理员，这个用户组管理员可以管理哪些账户加入或移除该用户组

**gpasswd**

- **gpasswd group_name**：没有任何参数时，用于给该用户组一个密码**/etc/gshadow**
- **gpasswd [-A user1 , user2 , ... ] [ -M user3 , ... ] group_name**
  - A——将group_name的管理权授予后面的列表用户
  - M——将某些账号加入到这个用户组
- **gpasswd [ -rR]**
  - r—将密码删除，R—让密码栏失效
- **gpasswd [ -ad ] user group_name**
  - a—将用户加入用户组中，d—将用户移除出用户组
- 

## 10.3 ACL

ACL是**Access Control List** 的缩写，主要目的是提供**传统的**owner、group、others的read、write、execute**权限之外的具体权限设置。**

ACL是unix-like操作系统权限的额外支持项目，要使用ACL必须要有文件系统的支持才行，包括EXT2/EXT3，JFS，XFS这些文件系统。

ACL可以针对某个具体的user，group，mask来设置权限

### 权限设置

1. **setfacl**
   -  设置某个目录/文件的ACL
   -  **setfacl [ -bkRd ] [ { -m | -x } acl参数 ]  文件名**
   -  acl参数
     - **u:[ 用户列表 ]:[rwx]**，rwx如果没有那么就写**" - "**占位
     - **g:[ 用户组列表 ]:[rwx]**
     - **m:[rwx]**，**用户或组所设置的权限必须要存在于mask的权限设置范围内才会生效，此即有效权限**
   -  m—为文件设置acl参数，x—删除acl参数，b—删除所有acl，k—删除mask的默认权限，
   -  R—递归设置acl，d—设置默认acl，只对目录有效，在该目录里新建的数据会引用此默认值

## 10.4 用户切换

su 做身份切换，sudo以不同身份去执行命令

### 10.4.1 su

su是最简单的身份切换命令，他可以进行任何身份的切换。

**su [ -lm ]  [ -c "命令" ] user_name**

- **su -  [ user_name ]**  ：代表使用login shell方式登录shell，如果user_name省略，那么默认登录root用户
- l—以login shell 的方式登录
- c—如果我只想要执行一个只有root才能进行的命令，且执行完毕就恢复原本的身份，
- 无法切换no-login用户
- 若要**完整的切换到新用户的环境**，必须要使用 **su -username or su -l username**
- root用户切换为任何用户不需要知道其它用户密码
- **一般用户切换root用户需要知道root的密码。**那么不就每个人都得要知道root密码了吗？不妥当
- exit 退出su环境，使用多个su需要对称的输入多个exit才能回到原来的环境

### 10.4.2 sudo

一般用户切换root用户需要知道root的密码。那么不就每个人都得要知道root密码了吗？不妥当。

sudo的执行仅需知道自己的密码，甚至可以设置不需密码就可执行。

但并非所有人都能够执行sudo，而是仅有**/etc/sudoers**内的用户才能够执行sudo这个命令。

**sudo [ -b ] [ -u user_name ] sffix_cmd** 

- 默认sudo仅有root能使用，sudo的执行流程如下
  - 当用户执行sudo，系统于**/etc/sudoers**查找该用户是否有执行sudo的权限
  - 若有sudo的权限，就会让用户输入自己的密码来确认
  - 若密码输入正确（root不需要执行密码），便开始执行sudo 后续接的命令
- u—欲切换的用户
- b—

#### visudo 与 /etc/sudoers

一般用户若需要执行root的权限命令，则需要**root使用visudo去修改 /etc/sudoers**，让该账号能够使用全部或部分的root命令

```bash
#通过visudo这个命令可以直接打开/etc/sudoers
visudo
#visudo只是利用vi将/etc/sudoers文件调出来而已，里面的修改和vim的用法相同

#通过上下键，光标调到下面的文字

## Allow root to run any commands anywhere

###1. 单一用户调整

#用户账户	登录者来源主机=可切换的身份	   可执行的命令
root  		  ALL=(ALL)    			   ALL
qin			  ALL=(root,kang)			!/usr/bin/passwd,/usr.bin/passwd [A-Za-z]*,!/usr/bin/passwd root
#用户账户：系统的哪个账户可以使用sudo这个命令
#登录者来源主机：限制这个用户账户的ip地址等去访问sudo
#可切换的身份：这个用户账户可以切换成什么身份来执行后续的命令
#可执行的命令：一定务必使用绝对路径编写
#ALL是一个特殊的关键字，代表任何身份，任何主机，任何命令的意思

#感叹号!代表不可执行的意思
# 这一句是!/usr/bin/passwd,/usr.bin/passwd [A-Za-z]*,!/usr/bin/passwd root
#防止qin修改root的密码

###2. 用户组以及免密码使用sudo

##2.1 用户组
## Allows people in group wheel to run all commands
#组符 组名		登录者来源主机=可切换的身份	   可执行的命令
%wheel 			 ALL=(ALL)     				  ALL
%admin			 ALL=(ALL)     				  ALL		#eg
#最左边的%代表后面接的是用户组的意思
#%后面是用户组名

## 2.2 免密使用sudo
## Same thing without a password
%wheel        ALL=(ALL)       NOPASSWD: ALL

### 3.别名（类似于变量的玩意）
User_Alias ADMINS = jsmith, mikem
Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig
#等号两边要有空格
#可以用ADMINS去代替后面一长串的内容，有了类似于变量的别名，我们可以改一处，做到所有引用该变量的地方都修改的目的
#别名都必须用大写字母，别名前要用关键字做声明，User_Alias,Cmnd_Alias,Host_Alias

### 4.sudo 时间间隔问题
# 连续执行的两个sudo 在5分钟内，不需要再次输入密码，超过5分钟需要再次输入密码

### 5.sudo 搭配 su，切换root身份
User_Alias ADMINS = qin,kang

ADMINS ALL = (root) /bin/su -
#这样就不会泄露root的密码
```

## 10.5 PAM

PAM（Pluggable Authentication Modules 可嵌入认证模块）是一套独立的验证机制。

- 它提供了一连串验证机制，只要用户将验证阶段的需求告知PAM后，它就能够回传用户的验证结果（成功or失败）。
- 它可以供其他程序所调用，因此不论你使用什么程序，都可以使用PAM来进行验证。

### 10.5.1 配置PAM

PAM的**配置文件在/etc/pam.d/**

PAM通过一个与程序相同文件名的配置文件来进行一连串的认证分析需求。

执行passwd命令后，这个程序调用PAM的流程是：

1. 执行/usr/bin/passwd程序，输入密码
2. passwd调用PAM执行验证
3. PAM到/etc/pam.d/找程序同名（passwd）的配置文件
4. 依据/etc/pam.d/passwd内的设置，引用相关PAM模块逐步验证分析
5. 将验证结果（成功or失败or其他）返回给passwd
6. passwd根据PAM回传结果执行其他操作

```bash
#在/etc/pam.d/passwd的内容
#%PAM-1.0
# This tool only uses the password stack.
#验证类型	控制标准		PAM模块与该模块的参数
password   substack     system-auth
-password   optional    pam_gnome_keyring.so use_authtok
password   substack     postlogin
```

#### 验证类型

常用为四种

- auth：验证用户身份，通常是需要密码来检验的
- account：验证是否具有正确的权限
- session：
- password：

#### 控制标准

验证通过的标准

- required
- requisite
- sufficient
- optional

![](./legend/PAM控制标志造成的回报流程.png)

## 10.6 用户间信息传递

### 10.6.1 查询登录信息

1. **w**

   - 当前在系统上已登录的用户信息

   - ```bash
     USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
     root     pts/0    222.18.126.102   19:36    1.00s  0.02s  0.00s w
     ```

   - **who -h 也可以**

2. **last**

   - 命令用于显示用户最近登录信息。
   - **last -n num**，用于获取最近登录记录的num条

3. **lastlog**

   - 用于显示系统上每个用户最近登录的时间

### 10.6.2 用户对谈

在线用户间交流

1. write

   - 发消息

   - **write 用户账户 [ 用户所在终端tty ]**

   - 先查看在线用户情况w，再通过write写给对应在线用户

   - root可以发给任何人，所有人不可拒收消息

   - ```bash
     write qin pts/2
     hello，qin
     will shut down linux
     #使用ctrl + d 结束输入
     #然后对应用户就会收到消息
     ```

2. mesg

   - **mesg [ ny ]**
   - n—拒收消息，y—允许接收消息，无—查看当前消息接收状态
   - 对root消息无拒收能力。

3. wall

   - 群发消息

### 10.6.3 邮件信箱

1. 发邮件
   - **mail username@ip -s "邮件标题" < 信件内容文件**
   - mail username@ip -s "邮件标题" ，然后，在命令行输入信件内容，小数点为结束，出现Cc：回车即可
   - 如果寄给本机用户，那么不需要ip
2. 收邮件
   - mai 查看邮件，相关命令可以查书
   - 还可以调qq邮箱的接口，具体百度
3. 

# 11 例行性工作

linux的两种工作调度种类

1. 例行性的，每隔一个周期就要执行的（每天中午12点吃饭）。
   - crontab这个命令所设置的工作将会循环下去
   - crontab命令执行也可编辑/etc/crontab来支持。
   - 让crontab可以生效的服务则是crond这个服务。
2. 突发性的，偶尔一次执行的（就相当于在日历上记录，下周要在会议厅开会这样的工作）。
   - at是个可以处理仅执行一次就结束调度的命令
   - 让at生效的服务则是atd（在某些新版的distributions中），atd可能默认并没有启动

linux常见例行工作：

- 新建locate数据库（用于locate查找文件）
- 建立whatis数据库
- 日志文件分析logwatch以及日志文件轮替
- 删除临时文件（tmpwatch）
- RPM软件日志文件新建
- apache www 网络服务有关分析行为

## 11.1 突发性at

并非所有linux distributions都会默认打开atd这个调度的服务

```bash
/etc/init.d/atd restart

#开机自启
chkconfig atd on
```

### 11.1.1 at工作方式配置

at工作方式

- 我们使用at这个命令来生成所要运行的工作，并将这个工作已文本文件的方式写入**/var/spool/at/目录内**，该工作便能等待atd这个服务的取用与执行。
- 不过因为安全的原因，不是所有的人都可以进行at工作调度。我们利用/etc/at.allow或/etc/at.deny这两个文件来进行at的使用限制。加上这两个文件后，工作情况如下：
  - 先找/etc/at.allow，写在这个文件中的用户才能使用at，没有在则不能使用at（即使用户不在at.deny文件里）
  - 若/etc/at.allow不存在，就会再找/etc/at.deny这个文件，在at.deny中的用户不能使用at，没有在则可以使用at
  - 如果两个文件都不存在，那么只有root可以使用at这个命令
- at.allow为管理严格的方式，at.deny为较为松散的方式，书写方式为每行写一个username

### 11.1.2 运行at

1. **安排at** 

   - **at [ -mldv ] TIME**

   - **at -c 工作命令**

   - **at now + 5 minutes**，通过now的方式设定

   - m—工作完成后，以email通知用户该工作完成

   - l—列出目前系统上面所有该用户的at调度，相当于**atq**

   - d—取消在at调度中的工作，相当于**atrm**

   - v—以较明显的时间格式列出at调度中的任务列表

   - c—列出后面可以接的该项工作的实际命令内容

   - TIME——

     - HH:MM ex>hh:mm(今天的某时某分执行，若时间已过，则在第二天执行)，
     - HH:MM YYYY-MM-DD ex>hh:mm yyyy-mm-dd(在某年某月某天 某时某分执行，若时间已过，则在某年某月某天 某时某分)

   - ```bash
     at 23:00 2022-08-29
     /bin/sync #建议使用绝对路径来执行命令
     /sbin/shutdown -h now
     #ctrl+d
     ```

   - 工作完成后的stdout、stderr都会输出到mailbox中，如果想输出到屏幕则需要重定向 >/dev/tty1

   - at 的任务是后台执行的。

     

2. 管理工作at

   - 万一执行at后，发现命令错误，就需要将它删除

   - **atq**

     ```bash
     atq
     #jobnumber	 time				 执行者
     5           2022-08-29 11:00  a  root
     ```

   - **atrm [ jobnumber ]**

      删除对应jobnumber的工作

   - 

3. **batch 系统有空是才进行后台任务**

   - **batch是利用at来进行命令的执行，只是加了一些控制参数而已**

   - **batch 安排的任务只会在CPU工作负载小于0.8的时候，才进行你所执行的工作任务**（工作负载：指的是单一时间点负责的工作任务数量，而不是CPU的使用率）

   - ```bash
     batch 23:00 2023-08-29
     /sbin/shutdown -h now
     #ctrl+d
     ```

   - 

4. 

## 11.2 例行性crontab

crond（ cron）这个系统服务是默认启动的，不需要想atd那样去开启

### 11.2.1 用户例行任务

**用户限制**

同样为了安全，我们需要限制使用crontab的账号，**会/etc/cron.allow以及/etc/cron.deny两个文件**，前者优先级大于后者，系统默认有/etc/cron.deny，一个账号一行。

**crontab**

- 这个命令是针对用户来设计的，不是系统的例行任务命令

- 当用户使用crontab这个命令来新建工作调度之后，该项工作就会被记录到**/var/spool/cron/**里面去，并且以账户名做区分，不同用户的例行工作在不同的文件里面，但切忌不要使用vi直接编辑该文件，因为可能由于输入的原因导致无法执行。

- cron执行的每一项工作都会记录到**/var/log/cron**

- **crontab [ -u username ] [ -l | -e | -r ]**

- u——只有root能用这个u参数，用于帮其他用户新建删除crontab工作调度

- e——编辑crontab的工作内容

- l——查阅crontab的工作内容

- r——删除所有的crontab的工作内容

- ```bash
  crontab -e
  #分（0~59）  时（0~23）	日（0~31）	月（1~12）	周（0~7）		例行执行的命令
  0	 		 12	 		10	  		*	   	  *				mail qin -s "工资到账" < /home/qin/hello.txt
  #编辑完后:wq保存后离开，每项工作（每行）都具有六个字段
  #时间的特殊字符
  #星号*：代表任何时刻
  #逗号,：代表时间列表的分隔
  #减号-：代表一段时间范围
  #/n: 每隔几个时间单位的意思，*/n（每隔n个单位时间）
  ```

### 11.2.2 系统例行任务

crond这个服务的最低检测限制是"分钟"，所以crond会每分钟去读取一次/etc/crontab与var/spool/cron/来更新例行工作任务。

如果是系统执行例行性任务，只需要编辑**/etc/crontab**这个文件就可以。

```bash
cat /etc/crontab
#内容

SHELL=/bin/bash
#执行文件的查找路径，当然使用默认路径已经很足够
PATH=/sbin:/bin:/usr/sbin:/usr/bin
#stdout/stderr输出给哪个邮箱
MAILTO=root

#runparts
#分	时	日	月	周	执行者身份	命令串
01 	*	 *	  *	   *     root      run-parts /etc/cron.hourly
01 	4	 *	  *	   *     root      run-parts /etc/cron.daily
22 	4	 *	  *	   0     root      run-parts /etc/cron.weekly
01 	4	 1	  *	   *     root      run-parts /etc/cron.monthly

#目录规划的命令
01 	*	 *	  *	   *     root      run-parts /home/qin/qincron
#直接执行命令
01 	*	 *	  *	   *     root      mail -s "hello wqq" qin < /home/qin/hello.txt

#几乎和crontab -e相似，多了个执行者，系统默认执行者身份是root
#命令串，那里用于直接执行命令，或是以目录的形式来规划
#run-parts，可以帮你执行某个路径下的.sh，可以自定义，也可以使用/etc/cron.*,hourly（每时），daily（每天），weekly（每周），monthly（每月）
#将要需要每小时执行的文件放在/etc/cron.hourly，其余文件同意思
```

由于centos提供run-parts这个sript的辅助，因此/etc/crontab这个文件支持两种命令的方式，**一种是直接执行命令，一种则是以目录来规划**

**注意事项：**

1. **周与日月不可同时并存**
2. 例行性工作注意时间规划，别让多个任务同时开始，这样会很繁忙
3. 安全的检验
4. 取消不必要的输出选项：MAILTO 设置的账号给/dev/null

## 11.3 任务补漏anacron

当linux主机全年无休之用，那么只需atd、crond这两个服务来管理你的例行性工作调度就行。

但如果，我的服务器突然断电或关机，那么在关机的这段时间的例行工作是无法执行的。这时候就需要用到anacron了。

anacron其实也是通过crontab来运行的，因此anacron运行的时间通常有两个，

- 一个是系统开机后运行（执行完成后关闭），anacron的进行其实是在开机完成后才进行的一项工作任务，

- 一个是写入crontab调度中（在/etc/cron.daily，weekly，monthly文件夹下都有0anacron的执行文件），它只做执行时间更新，辅助判断主机是否关机。

  ```bash
  cat /etc/cron.daily/0anacron
  if [! -e var/run/anacron.pid ]; then
  	anacron -u cron.daily  #仅用于更新anacron执行时间
  fi
  ```

在crontab调度中，anacron会以一天、七天、一个月为期去检测系统未进行的crontab任务。

crontab调度下，在/etc/cron.daily下执行0anacron，它会更新anacron执行时间戳（放在/var/spool/anacron/cron.daily，cron.weekly，cron.monthly），当anacron检测到现在的时间与cron.daily（weekly，monthly）时间相差超过1天（超过7天，超过30天），就说明主机未执行那些例行工作。

### anacron

**anacron**

-  **anacron [ -sfn ] [ job ]**
- **anacron -u job**
- s——开始执行各项工作（job），会依据时间记录文件的数据判断是否执行
- f——强制执行，而不去依据时间记录文件判断是否执行
- n——立刻进行未进行的任务，而不延迟等待时间
- u——仅更新时间戳，不进行任何工作
- job——由/etc/anacrontab定义的各项工作名

### /etc/anacrontab

```bash
#period in days（命令执行周期，单位：天）   delay in minutes   job-identifier(job名称)   		command
1       								5       			cron.daily              nice run-parts /etc/cron.daily
7       								25      			cron.weekly             nice run-parts /etc/cron.weekly
@monthly 								45     				cron.monthly            nice run-parts /etc/cron.monthly
```

anacron并不需要额外的设置。

当执行这个命令 **anacron -s cron.daily**，它的工作流程如下：

1. 由/etc/anacrontab分析到名为cron.daily的任务，它的周期为1天，也就是需要每天执行的
2. 再由/var/spool/anacron/cron.daily取出最近执行anacron的时间戳
3. 当前时间与最近执行的anacron的时间戳对比，若差异超过周期，则就准备执行后面的命令，
4. 根据延迟时间，到时执行
5. 执行完毕，anacron程序完毕

# 12 程序管理

## 12.1 进程

1. 程序（program）：通常为二进制程序放置在存储媒介中，以物理文件的形式存在

2. 进程（process）：进程就是一个正在运行的程序。程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会加载到内存中，操作系统并给予这个内存内的单元一个标识符PID

   ![](./legend/程序与进程.png)

3. 子进程与父进程：

   - 连续执行的两个bash，第二个bash的父进程就是前一个bash，每个进程都有PID，某个进程的父进程通过**Parent PID（PPID)**

   - 有时候，你杀掉一个子进程，父进程就会主动再生一个（这就是有时候，你关不掉某个进程的原因），杀父进程可以解决这个问题

   - 父进程调用子进程的流程

     ![](./legend/父进程调用子进程.png)

4. 服务

   - 服务就是常驻在内存中的进程，通常是负责系统所提供的的功能以服务用户各项任务的
   - 有些命令被触发后所产生的PID很快就会终止，而服务不会

5. 

### 僵尸进程与孤儿进程

**孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

**僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

　　unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

　　**孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

　　**任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

## 12.2 工作管理

工作管理——当我们登录系统取得bash shell之后，在**单一终端机下**同时进行多个工作的行为管理。

想要在**一个终端**内同时进行多个操作，比如说数据查找，编译，vi编辑文本等就需要用到工作管理。

首先理解两个概念：

1. 前台（foreground）：
   - 出现提示符，用户能够操作的环境。
   - 前台进程是属于某个终端的进程，如果终端退出，那么这个进程就会被kill掉
   - Ctrl + c可以停止前台的进程。
2. 后台（background）：
   - 独立的不可见的运行环境。
   - 后台进程是独立与任何终端的进程，除非自行退出或关机或kill，它不能与用户互动
   - 使用**bg/fg**调用该工作

**在工作管理中提到的“后台”指的是在终端机模式下可以避免Ctrl+c中断掉，并不是放到系统的后台去，所以，工作管理的后台与终端机有关。**

**当以远程连接的方式连接到你的linux主机，并且将工作已加&形式放到后台去，在工作尚未结束的情况下，你脱机（断网，失去连接）了，工作就不会再进行了，就会被中断掉。**

要进行bash的job control 必须要注意以下限制：

- 这些工作所触发的进程必须来自于自身shell的子进程（只能管理自己bash的工作，不能管理其他bash的工作）
- 后台中执行的进程不能收到来自terminal/shell的输入

### job control

bash只能够管理自己的工作而不能管理其他bash的工作

后台的工作又有两种状态：暂停（stop）与运行中（running）

1. 直接将命令**丢到后台中执行**的**“ & ”**

   - **cmd &**

   - ```bash
     #eg:
     tar -zpcvf /tmp/etc.tar.gz /etc &
     #[ job number ] PID
     [1] 8400    
     
     #丢到后台的工作，当工作完成后，会向前台发送如下信息
     [1]+Done  tar -zpcvf /tmp/etc.tar.gz /etc &
     ```

   - 作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。因此，**将工作丢到后台当中要特别注意数据的流向。**

2. 将目前的工作**先暂停再丢到后台**：**【 Ctrl + z 】**

   - ```bash
     vim ~/.bashrc
     #一般模式下按下Ctrl + z，会出现如下提示
     [1]+ Stopped   vim ~/.bashrc
     ```

3. 查看当前的后台工作状态：**jobs**

   - **jobs [ -lrs ]**

   - l，同时列出PID

   - r，列出在后台running的工作

   - s，列出在后台stopped的工作

   - **jobs -l**

   - +号代表默认取用的工作（fg命令默认拿到前台的工作），-代表最近的倒数第二被放置到后台工作的工作，倒数第三及以后，没有符号。

     ```bash
     #[job number] +/-最近的一二个工作 	PID 	工作状态 	命令
     	[1]				- 			10314 	 Stopped 	Vim ~/bashrc
     	[2]				+ 			10833	 Stopped 	find /-print
     ```

4. 将**后台工作拿到前台**来处理：**fg**

   - **fg %jobnumber**
   - fg 默认取用+号代表的那个工作

5. 让工作在后台下的工作变为运行中：**bg**

   - **bg %jobnumber**
   - 将stopped状态变为running

6. 杀死后台的工作：**kill**

   - **kill -signal %jobnumber**
   - **kill -l**
   - l—列出当前kill能使用的signal，有很多，下面列**signal**几个
     - 1，重新读取一次参数的配置文件
     - 2，等于Ctrl + c
     - 9，立刻强制删除一个工作（粗鲁的方式）
     - 15，以一个正常的程序方式终止一项工作。（细致的方式，会删除相关的文件）

### 脱机管理nohup

前面我们知道工作管理当中的后台工作与终端有关，当远程连接的终端脱机，还在后台的工作就会中断。

如果我的工作需要一直工作，或者说需要很长时间，那我们该怎么办呢？

**nohup**

- **nohup可以让你在脱机或注销系统后，还能够让工作继续进行**
- **nohup cmd**，在终端机前台工作
- **nohup cmd &**，在终端机后台工作
- nohup并不支持bash内置的命令，因此在执行*.sh文件时，里面的使用到bash内置命令必须写绝对路径

## 12.3  进程管理

工作管理只能管理自己终端相关的工作，而进程管理则能做到对系统所有进程进行管理

### 12.3.1 进程查看与管理

#### 查看

1. **ps**

   - 将某个时间点的进程运行情况选取下来。

   - **ps -l ——查阅自己bash程序，ps aux——查看需系统所有运行的程序（这里没有-aux，就是aux）**

   - ```bash
     ps -l
     F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
     0 S     0  328469  328380  0  80   0 -  6635 -      pts/1    00:00:00 bash
     0 R     0  328522  328469  0  80   0 - 11351 -      pts/1    00:00:00 ps
     #F:process flags，进程标志，说明进程的权限，4——root，1——此子进程只可fork不可exec
     #S：stat，进程状态，R-running，S-sleep，T-stop，Z-zombie(僵尸)，D—不可唤醒的睡眠态
     #C：cpu使用率（%）
     #PRI/NI：Priority/Nice，cpu执行的优先级
     #ADDR/SZ/WCHAN：与内存有关,
     	#ADDR是kernel function，指出该进程在内存的哪个部分（-表示running）
     	#SZ：size，用掉多少内存
     	#WCHAN：表示目前程序是否在进行中（-表示running，还有wait状态等）
     #TIME:使用掉的cpu时间
     
     #ps -lA 显示系统所有进程的关于ps -l 中的内容项（观察项，F,S,UID,...WCHAN,TTY,TIME,CMD）
     ```

   - ```bash
     ps aux
     USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
     root         674  0.0  0.1 149436  2728 ?        S<sl Nov13   1:59 /sbin/auditd
     #VSZ:该进程使用掉的虚拟内存量(KB)
     #RSS:该进程占用的固定内存量(KB)
     #START:该进程被触发启动的时间
     #TIME:该进程实际使用的cpu运行时间
     
     #COMMAND:后面如果出现defunct，就代表该程序是僵尸进程
     ```

   - ```bash
     ps axjf
     #进程树形结构，描述父子进程及进程相关性
     PPID	  PID	 PGID	  SID	TTY		  TPGID  STAT	UID	  TIME  COMMAND
         977  326939  326939  326939 ?             -1 Ss       0   0:00  \_ sshd: root [priv]
      326939  326952  326939  326939 ?             -1 S        0   0:00  |   \_ sshd: root@pts/0
      326952  327039  327039  327039 pts/0     327039 Ss+      0   0:00  |       \_ -bash
         977  328378  328378  328378 ?             -1 Ss       0   0:00  \_ sshd: root [priv]
      328378  328380  328378  328378 ?             -1 S        0   0:00  |   \_ sshd: root@pts/1
      328380  328469  328469  328469 pts/1     328888 Ss       0   0:00  |       \_ -bash
      328469  328888  328888  328469 pts/1     328888 R+       0   0:00  |           \_ ps axjf
         977  328884  328884  328884 ?             -1 Ss       0   0:00  \_ sshd: root [priv]
      328884  328885  328884  328884 ?             -1 S       74   0:00  |   \_ sshd: root [net]
         977  328886  328886  328886 ?             -1 Ss       0   0:00  \_ sshd: root [priv]
      328886  328887  328886  328886 ?             -1 S       74   0:00      \_ sshd: root [net]
     ```

   - 

2. **top**

   - 动态查看进程变化，可以持续检测进程运行状态。以及系统资源的变化

   - **top [ -d 数字 ]**

   - **top [ -bnp ]**

   - d—进程变化更新时间（秒）

   - p—指定某个PID来进行监测，b与n搭配使用—搭配数据重定向，将批处理结果输出成为文件。

   - top执行过程中可以使用的按键

     - ？—显示top当中可以输入的按键命令
     - 排序：P—cpu使用资源排序，M—内存资源，N—PID，T—cpu时间累积
     - **k—给予某个pid一个signal**，**r—给与某个pid一个nice值**，按下后，会让输入pid
     - q—离开top

   - ```bash
     top -d 2
     #    目前的时间	 开机到现在的时间	  已登录系统的用户	系统在1,5，15分钟的平均工作负载（batch命令指的工作负载）
     top - 18:34:38  up 20 days,  7:37,  2 users,  	  load average: 0.03, 0.04, 0.00
     #目前进程总量，和每个状态上的进程数
     Tasks:  96 total,   1 running,  95 sleeping,   0 stopped,   0 zombie
     #cpu的整体负载
     %Cpu(s):  1.3 us,  0.7 sy,  0.0 ni, 97.7 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st
     #物理内存使用情况
     MiB Mem :   1827.0 total,    107.7 free,    264.2 used,   1455.2 buff/cache
     #虚拟内存使用情况
     MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1377.9 avail Mem 
     #					
         PID USER      PR NI   VIRT    RES  	  SHR S  %CPU  %MEM     TIME+ COMMAND                                                             
        1018 root      10 -10  194380  42132  11456 S   0.7   2.3 164:42.67 AliYunDun                                                           
         975 root      20   0  693628  42004  40144 S   0.3   2.2   3:12.56 rsyslogd                                                                                                         
           3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp    
      #PR:priority，
      #NI:nice
      #vIRT:virtual memory usage 虚拟内存
      #RES：resident memory usage 常驻内存
      #SHR：shared memory 共享内存
      #TIME+:CPU累积使用率
       
     ```

   - 

3. **pstree**

   - **查找进程之间的相关性**
   - patree [ -A|U] [up]
   - A—各进程树以ascii字符来连接，U—以utf8连接
   - p—列出pid，u—列出user
   - 从输出结果我们可以看到**所有进程都是依附在init（systemd）进程下，它是所有进程的父进程**
   - 重新启动inti就是reboot

#### 管理

进程之间是可以互相控制的，通过给与进程一个信号（signal）去告知进程你想要让它做什么。

那么到底有多少signal呢？可以通过**使用kill -l ，查看signal列表**

常用有：

| 代号 | 名称    | 内容                                                   |
| ---- | ------- | ------------------------------------------------------ |
| 1    | SIGHUP  | 启动被终止的程序，可让该pid重新读取配置，类似重新启动  |
| 9    | SIGKILL | 强制中断一个进程的进行，尚未完成的部分可能有半成品产生 |
| 15   | SIGTERM | 以正常的结束进程来终止该进程                           |
| 2    | SIGINT  | CTRL + C                                               |
| 17   | SIGSTOP | CTRL + Z                                               |

**我们如何传送一个信号给某个进程呢？通过kill 或 killall **

**kill -signal PID**——根据进程pid传输信号

**killall [-iIe] command_name**——根据命令的名称传输信号

- i—interactive的意思，交互式的，若需要删除，会出现提示符给用户
- e—exact精确匹配命令名，
- I—命令名称忽略大小写。

### 12.3.2 进程的执行顺序

linux是多用户、多任务的环境，系统同时间有非常多的进程在运行，只是绝大多数的进程都在休眠。

如果多个进程被同时唤醒，那么cpu就要按照优先执行序（Priority）or CPU调度

**PRI值越低，越优先。**不过PRI值是由**内核动态调整的**，用户无法直接调整PRI的值。

我们无权干涉PRI，如果要调整进程的优先执行序，就要通过Nice值了

**PRI ( new )=PRI( old ) + NICE**

注意：

1. nice范围：-20~19
2. root可调整自己和他人进程的nice值，范围为-20~19
3. 一般用户可调整自己进程的nice值，范围为0~19，而且nice的值只能越调越高，不能小于当前nice值

#### nice调整

1. **nice**
   - **执行命令时给予nice值**
   - **nice [ -n 数字 ] command**
2. **renice**
   - **修改进程的nice值**
   - **renice [ number ] PID**

### 12.3.3 系统资源的查看

除了系统进程之外，我们还必须对系统的一些资源进行检查。

1. **free**

   - **查看内存使用情况**

   - free [ -b | -k | -m | -g ] [ -t ]

   - [ -b | -k | -m | -g ]—— 存储单位

   - t——total 汇总物理内存与swap的总量

   - ```bash
     free -m -t
                   total        used        free      shared  buff/cache   available
     Mem:           1826         265         116           1        1445        1376
     Swap:             0           0           0
     Total:         1826         265         116
     #Mem:物理内存，total=used + free + buff/cache
     #Swap:虚拟内存
     ```

   - 物理内存被用光很正常，但是如果swap的用量超过20%，那么系统的物理内存不足才会出现这样的情况

2. **uname**

   - **查看系统与内核信息**

   - **uname [ -asrmpi ]**

   - a—所有系统相关信息，s—内核名称，r—内核版本，m—系统硬件名称，p—CPU类型，i—硬件平台

   - ```bash
     uname -a
     #内核名 主机名				  内核版本
     Linux iZbp1a1nnstgr4w2bu73ovZ 4.18.0-193.14.2.el8_2.x86_64 
     #内核版本创建日期						#硬件平台
     \#1 SMP Sun Jul 26 03:54:29 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
     ```

3. **uptime**

   - 查看系统启动时间与工作负载

   - ```bash
     uptime
     #目前的时间  开机到现在的时间	  已登录系统的用户	系统在1,5，15分钟的平均工作负载（batch命令指的工作负载）
      21:42:42   up 20 days, 10:45,   2 users,      load average: 0.01, 0.01, 0.00
     ```

4. **netstat**

   - **跟踪网络，查看进程对外和对内通信情况。**输出分两部分，分别是网络与系统进程相关性部分

   - **netstat -[ atunlp ]**

   - a—列出系统当前所有的连接、监听、sockete数据。（包括监听与未监听）

   - t—列出tcp连接，u—列出udp连接

   - n—不列进程的服务名称，以端口号显示，会影响Local Adress分号后面是端口号还是服务名

   - l—列出正在网络监听的服务

   - ```bash
     netstat -a
     Active Internet connections (servers and established)	#正在活跃的internet连接，用于网络中进程通信
     Proto Recv-Q Send-Q Local Address           Foreign Address         State      
     tcp        0      0 0.0.0.0:svn             0.0.0.0:*               LISTEN	#listen状态与established状态参看下面的tcp包交换机制 
     tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN 
     tcp        0      0 iZbp1a1nnstgr4w2b:35010 100.100.30.26:http      ESTABLISHED
     udp        0      0 localhost:323           0.0.0.0:* 
     Active UNIX domain sockets (servers and established)	#正在活跃的Unix域套接口，用于本机通信
     Proto RefCnt Flags       Type       State         I-Node   Path
     unix  2      [ ACC ]     STREAM     LISTENING     19475    /run/dbus/system_bus_socket
     unix  3      [ ]         STREAM     CONNECTED     9232566  /var/lib/sss/pipes/nss
     Active Bluetooth connections (servers and established)	#正活跃的蓝牙连接
     Proto  Destination       Source            State         PSM DCID   SCID      IMTU    OMTU Security
     Proto  Destination       Source            State     Channel
     #Proto：protocol协议
     #Local Address：服务进程在本地ip端口情况，
     #Foreign Address：服务进程对外开放端口（远程主机可访问该服务的ip范围）
     #现在几乎所有应用程序都依靠socket通信编程
     
     #RefCnt：表示连接到本套接口socket上的进程数量
     #state：CONNECTED表示多个进程之间已经连接建立，listen监听
     #Path：连接到此socket的相关程序的路径，或者相关数据输出路径
     
     ```

   - **tcp包交换机制**

   - ![](./legend/tcp连接中的包交换.jpg)

5. **dmesg**

   - 分析内核产生的信息，内核会去**检测系统硬件**等等信息。
   - **dmesg | 管道命令 **，由于内核相关信息太多了，需要采用管道命令来查看。

6. **vmstat**：

   - 动态检测系统资源变化

   - **vmstat [ -a ] [检测的时间间隔 [ 检测的次数 ]]** ，a—使用active/inactive代替下面的memory替代buffer/cache的内存输出信息

   - ```bash
     vmstat 1 3
     procs  -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
      r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs  us sy id wa st
      3  0      0 147320     84 1461592    0    0     2    15    7   12  1  1 99  0  0
      0  0      0 147260     84 1461592    0    0     0     0  269  556  0  2 98  0  0
      0  0      0 149016     84 1461596    0    0     0     0  258  546  1  0 99  0  0
      
      #procs，r——等待运行中的进程数量，b——不可被唤醒的进程数量，两个选项越多，代表系统越繁忙
      #memory，swpd——虚拟内存使用量，free——未被使用的内存容量，buff——用于缓存存储器，cache——高速缓存
      #swap，si——由磁盘中将程序取出的量，so——由于内存不足，将没用到的程序写入磁盘中的程序量。
      #		si/so越大，导致内存内的进程数据频繁在磁盘与内存之间传递，系统性能越差
      #io ， bi——由磁盘写入的块数量，bo——写入磁盘的块数量，这部分值越高，系统越忙碌
      #system，in——每秒被中断的进程次数，cs——每秒进行的事件切换次数，这部分值越大，表示系统与接口设备的通信非常频繁
      #cpu，us——非内核层cpu使用状态，sy——内核层cpu状态，id——闲置的状态，wa——等待i/o所耗费的cpu状态，st——被虚拟机盗用的cpu使用状态
     ```

   - vmstat [-S] 设置数据单位

   - vmstat [ -d ]，列出磁盘的读写总量统计表

   - ```bash
     disk- ------------reads------------ ------------writes----------- -----IO------
            total merged sectors      ms  total merged sectors      ms    cur    sec
     vda    39549    150 5756755  134133 4263009 221359 54824738 6638685      0   1278
     ```

   - vmstat [ -p 分区 ] ，磁盘分区读写总量统计表

7. 

## 12.4 特殊文件与程序



## 12.5 SELinux基础



# 13 系统服务

服务：常驻内存中的进程。

daemon——守护神，守护程序，service与daemon基本上同样的意思，不要去特意的区别

## 13.1 daemon

### 13.1.1 分类

按daemon的启动与管理方式来分，可以分为

1. **stand alone** ：自行单独启动的服务daemon
   - 这类daemon自启动并加载到内存就一直占用内存与系统资源，
   - 启动后，自行监听客户端请求并提供相应服务，优点：响应快。
   - 就相当于银行的单一窗口提供单一存钱业务
2. **super daemon**：由super daemon来统一管理的服务daemon
   - 这类daemon的启动依靠super daemon这个特殊的daemon——**xinetd**
   - 当没有客户端的请求时，各项服务都是未启动的情况，等到有来自客户端的请求时，super daemon 才会唤醒被它管理的服务
   - 就相当于银行的统一窗口提供各种贷款，提现等多种业务
   - super daemon 的处理模式：
     - 多线程，多个client请求对应多个daemon服务。
     - 单线程，client请求需要排队获取daemon服务

按提供的工作状态来分，可分为

1. signal control：请求进来立即启动并处理
2. interval control：每隔一段时间启动处理

daemon的命名规则：

每一个服务的开发者通常在服务的名称之后会加一个**“d”**，这个d代表的是daemon的意思

### 13.1.2 服务与端口

每个服务都会对应一个端口。

系统的所有服务都可以在/etc/services中看到，**不建议修改此文件**

```bash
cat /etc/services
#daemon名称	   端口/协议
...
ftp             21/tcp
ftp             21/udp          fsp fspd
ssh             22/tcp                          # The Secure Shell (SSH) Protocol
ssh             22/udp                          # The Secure Shell (SSH) Protocol
http            80/tcp          www www-http    # WorldWideWeb HTTP
http            80/udp          www www-http    # HyperText Transfer Protocol
http            80/sctp                         # HyperText Transfer Protocol
...
```

### 13.1.3 启动

系统会记录每一个daemon启动后所取得进程的PID并记录在**/var/run/*.pid**

#### 启动脚本与配置文件位置

1. /etc/init.d/*：启动脚本放置处
   - **系统几乎所有的服务启动脚本都放置在这里**
2. /etc.sysconfig/*：各服务的初始化环境配置文件
   - 几乎所有的服务都会将初始化的一些参数设置写入到这个目录里
3. /etc/xinetd.conf，/etc/xinet.d/*：super daemon配置文件
   - xinetd服务的配置在/etc/xinetd.conf，而被它管理的服务则放在/etc/xinetd.d/*
4. /etc/*：各服务各自的配置文件
5. /var/lib/*：各服务产生的数据库
6. /var/run/*.pid：各服务的进程pid

#### stand alone的启动

我们可以通过/etc/init.d/* status | start | restart | stop来执行查看服务的状态 | 开启 | 重启 | 停止 服务

也可以通过一个stand alone 服务脚本 ——service进程，**提供service命令，去操作/etc/init.d/下的服务service**

**service**

- **service [ service_name ] ( status | start | restart | stop )**
- **service --status-all**
- service_name—需要操作的服务名称了，需与/etc/init.d/下的服务名相对应
- start | ...——服务需要执行的动作
- **status-all将系统所有的stand alone 的服务状态全部列出来**

#### super daemon的启动

super daemon本身也是一个stand alone的服务。super daemon 的启动方式和stand alone是相同的，

但是它所管理的daemon 就不是这么做的。必须要在/etc/xinetd.d/*做配置。

先修改/etc/xinetd.d/下面的配置文件，然后再重启xinetd就对了

## 13.2 super daemon 的配置文件

super daemon它是一个可以管理多个daemon的进程，，这个super daemon是xinetd这个进程所实现的。

如果在/etc下没有xinetd.conf，说明你没有安装此服务。通过yum install xinetd安装即可

```bash
#默认参数文件
defaults
{
...
# Define access restriction defaults
#
#       no_access       =
#       only_from       =
#       max_load        = 0
        cps             = 50 10 #每秒发起的“新”连接（建立连接的请求）最多仅能有50条，若超过50条，该服务会暂停10秒钟。
        instances       = 50 #一个服务最多可以有50个同时连接，
        per_source      = 10 #统一个来源的用户最多仅能达成10条连接
...
}

includedir /etc/xinetd.d #具体服务，更多具体细节，设置值在/etc/xinetd.d/*
```

/etc/xinetd.d/*文件的一般格式

```bash
service <service_name>
#service_name要与etc/service一致
{
    <attribute> <assign_op> <value>
    #参数名  		赋值的符	值
    #assign_op = | += | -= 直接赋值 | 追加赋值 | 减法赋值
    
    #1 一般设置选项：
    #1.1 服务的识别，启动与程序
    Disable=[ yes|no ] #服务是否启动
    id=[ 服务识别id ]
    Server=[ 启动程序 ] #支出服务的启动程序，eg：/usr/bin/rsync
    server=[ 程序参数 ] #续接在启动程序之后的参数，eg：/usr/bin/rsync --daemon，这里的--daemon就是参数
    User=[ user_name ]
    group=[ group_name ]
    
    #1.2 连接方式与连接数据包协议
    socket_type=[ stream | dgram | raw ]，
    	#stream为连接机制较为可靠的tcp数据包
    	#dgram为UDP数据包
    	#raw代表server需要与ip直接交互
    protocol=[ tcp | udp ] #与上面重复，通常此项不设定
    Wait=[ 连接机制 ] # yes（sinle） | no（multi），使用单线程还是多线程
    instance=[ 最大连接数 ]# 这个服务科接受的最大连接数量
    per_source=[ 单ip最大连接数量 ]
    Cps=[ 新连接的限制 ]
    	# 为避免短时间内大量的连接请求导致系统出现忙碌的状态，
    	#cps第一个值为一秒内建立新连接的最大请求数量
    	#第二个数字则为超过第一个数字时，关闭该服务的秒数
    
    #1.3 日志记录
    log_type=[ 日志选项等级 ]
    log_on_success=[ PID | HOST | USERID | EXIT | DURATION ]
    log_on_failure=[ PID | HOST | USERID | EXIT | DURATION ]
    	#在成功登录或失败后，需要记录的选项
    	
    #高级设置选项
    #2.1 环境、网络端口与连接机制等
    env=[]# 设置环境变量
    Port=[ 非正规端口号 ]#若服务名称是你自定义的，那么这个端口可以随你指定，如果不是，那么请按照/etc/services中的服务名与端口相对应。
    redirect=[ 服务转址 ] #将client对我们server的请求转到另一台主机上去。
    includedir=[ 调用外部设置 ]# 表示将某个目录下的所有文件都塞进到xinetd.conf这个设置里面。
    
    #2.2 安全管控选项
    bind=[ 可服务ip ]# 可以享受此服务的ip
    interface=[ 可服务ip ]#与bind相同
    only_from=[ 可登录防火墙0.0.0.0,192.168.1.0/24,hostname,domainname ]# 只有这里面规定的ip或主机名是可以登录
    no_access=[ 不可登录防火墙 ]
}
```

## 13.3 服务的防火墙

系统的防火墙分析主要通过数据包过滤或者是通过软件分析。

有的主机支持/usr/sbin/tcpd这个软件来分析进入系统的TCP网络数据包，TCP数据包并搭配/etc/hosts.allow、hosts.deny规则处理，决定该连接是否内能够进入我们的主机

**任何以xinetd管理的服务或者该服务的程序支持TCP Wrapper 函数功能，都可以通过/etc/hosts.allow、/etc/hosts.deny来设置防火墙，**

配置文件的语法

```bash
service_name:<ip,domain,hostname>:action
#服务名：ip | 域 | 主机：deny|allow
#在hosts.allow中，action可以不写，默认allow
#在hosts.deny中，action可以不写，默认deny

#第一个字段或第二个字段有一些特殊参数可使用
#ALL（全部）,LOCAL（本机）,UNKNOWN（不可解析）,KNOWN（可解析）

```

两个文件优先级：hosts.allow>hosts.deny

## 13.4 系统开启的服务

**可以使用ps与top来查找已经启动的服务的进程及其PID，不过我们怎么知道该服务启动的port是哪一个呢——netstat**

**设置开机自启服务——chkconfig**

### 查看系统已启动的服务

**netstat -tlup**，**参数n可以查看端口号**

```bash
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:3690            0.0.0.0:*               LISTEN      830/svnserve 
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      977/sshd  
```

### 开机立即启动服务

netstat仅能查看到目前已经开启的daemon，使用service或者 “/etc/init.d/* start”的方法仅能在目前环境下立即启动某个服务。如何在重启后，进行自启动服务？

1. **chkconfig** 
   - **chkconfig --list [ 服务名称 ]**
   - **chkconfig [ --level [ 0123456 ] ] [ 服务名称 ] [ on | off ]**
   - list—列出在目前各项服务的自启动状态
   - level—设置某个服务在该level下启动 or 关闭
   - chkconfig仅是设置开机时默认启动的服务而已，

#### 设置自己的系统服务

**如果我自己写了一个程序并且想要让该程序成为系统服务好让chkconfig来管理，我们只需要将该服务加入init可以管理的script当中，即是/etc/init.d/。并且将服务通过chkconfig加入服务管理序列中即可**

**chkconfig [ --add | del ] [ 服务名称 ]**

**服务名称必须和/etc/init.d/下的script脚本名称相同**

# 14 软件安装

厂商现在他们的系统上面编译好了我们用户所需要的软件，然后将这个编译好的可执行软件直接发布给用户来安装。

在我们系统的本地通过建立相关软件安装数据库，用于记录安装等行为。就可以对这些软件进行安装，卸载，升级与验证等相关功能。

在linux系统上至少就有两种常见的软件管理器，分别是RPM与Debian 的DPKG。

| distribution代表  | 软件管理机制                  | 使用命令      | 在线升级机制（命令） |
| ----------------- | ----------------------------- | ------------- | -------------------- |
| Red Hat \| Fedora | RPM（RedHat Package Manager） | rpm，rpmbuild | YUM（yum）           |
| Debian \| Ubuntu  | DPKG                          | dpkg          | APT（apt-get）       |

centos用的是RPM。

## 14.1 RPM

RPM 全名 RedHat Package Manager

RPM的特点是将你要安装的软件先编译，并打包成RPM机制的安装包，根据安装包内的数据库文件，进行依赖属性软件进行检查，若满足则予以安装，否则不安装。

### 14.1.1 RPM默认安装路径

在依赖的软件已安装，环境检查通过，那么RPM安装包就开始被安装，在安装完成后，软件的相关信息就会写入**/var/lib/rpm/**目录下的数据库文件中。

| 路径                               | 文件功能                                 |
| ---------------------------------- | ---------------------------------------- |
| /etc                               | 一些软件的设置文件                       |
| /usr/bin                           | 一些可执行文件                           |
| /usr/lib                           | 一些程序使用动态函数库                   |
| /usr/share/doc<br />/usr/share/man | 软件使用手册与帮助文档，一些man page文件 |

### 14.1.2 安装

**RPM安装包需要自行下载，安装软件是root的工作，因此需要root才有权操作rpm 命令**

**rpm -ivh package_name**

- i—install，v—查看详细的安装信息，h—安装进度条

- ```bash
  #一次性安装多个软件
  rpm -ivh a.rpm b.rpm *.rpm
  #通过网络地址直接安装软件
  rpm -ivh http://website.name/path/pkgname.rpm
  ```

| 可执行参数      | 代表意义                                                     |
| --------------- | ------------------------------------------------------------ |
| --nodeps        | 使用时机：当发生软件属性依赖问题而无法安装，但你执意安装时<br />危险性：可能造成软件无法使用 |
| --replacefiles  | 使用时机：“某个文件已经被安装在你的系统上面”，又或许出现版本不和（conflict files），可以使用此参数直接覆盖原有文件。<br />危险性：覆盖操作无法复原 |
| --replacepkgs   | 使用时机：如果需要安装一大堆rpm软件文件（rpm -ivh *.rpm），其中某些软件已安装。若出现“某软件已安装”，此时可以用此参数重新安装此rpm |
| --force         | 使用时机：是replacefiles与replacepkgs的综合体                |
| --test          | 使用时机：测试软件是否能够通过环境与属性依赖检查             |
| --justdb        | 使用时机：RPM数据库损坏或产生错误，使用此参数更新软件在数据库内的信息 |
| --nosignature   | 使用时机：略过数字证书的检查                                 |
| --prefix 新路径 | 使用时机：要将软件**安装到其他非正规目录**时。例如：你想将某软件安装到/usr/local 下，而非正规的/bin，/etc |
| --noscripts     | 使用时机：不想让软件在安装过程中自行执行某些系统命令         |
|                 |                                                              |

### 14.1.3 升级与更新

**rpm -Uvh package_name**

- U—upgrade，无论后面的软件有没有安装

**rpm -Fvh package_name**

- F—freshen，只有后面的软件安装过，才会进行更新操作

### 14.1.4 查询

查询的时候，就会去/var/lib/rpm/这个目录下查询。

**rpm -q[a] [ 已安装软件的名称 ]**

- q——查询后面的软件是否安装
- qa——query all，查询由RPM管理的所有已安装软件

**rpm -q[ licdR ] 已安装软件名称**

- qi—information，列出软件的详细信息，包括开发商，版本说明等
- ql—list，列出该软件所有的文件与目录所在的完整文件名（安装路径里存的文件，包括/etc，/usr/lib，/usr/bin）
- qc—etc，列出该软件所有的设置文件（包括/etc）
- qd—列出该软件所有的帮助文件（说明或man page）
- qR—Required，列出该软件相关的依赖软件所含文件。

**rpm -qf 文件名**

- f—由文件名查找归属于哪个软件

**rpm -qp[ licdR ] rpm包名**

- p—package，仅在查找某个rpm包内的信息。

### 14.1.5 卸载

**rpm -e 软件关键词**

- e—erase，擦除，卸载
- 软件的卸载必须符合由上层往下层进行卸载，如果所需卸载的软件还存在依赖，那么将卸载失败，除非你使用--nodeps

### 14.1.6 重建数据库

**rpm --rebuilddb**

- 某些操作可能会导致RPM数据库/var/lib/rpm/下的文件损坏，那么可以通过此命令重建一下数据库

### 14.1.7 RPM验证

使用/var/lib/rpm下面的**数据库内容**来比较目前Linux系统环境下的所有**软件文件**

当你误删了某软件的文件，或不小心修改了某个软件的文件内容，你想查看到底修改了哪些文件的数据

**rpm -V 已安装软件名称**

- V—verify，列出该软件被改动的文件列表
- Va—列出系统上所有可能被改动的文件。

**rpm -Vf 文件名**

- 判断这个文件名是否被修改过

**rpm -Vp 软件名**

- 列出某个软件内可能被改动的文件

```bash
rpm -V logrotate
..5...T c /etc/logrotate.conf
#最前面的八个字符，“.”作为占位符，如果没有变动则为"."
#S：file size differs，文件大小发生了改变
#M：Modediffers，文件类型or文件权限rwx发生改变
#5：MD5 sum differs，MD5这一种指纹码的内容已经不同
#D：Device major/minor number mis-match ,设备的主次代码已经改变
#L：readLink（2） path mis-match ，Link路径已被改变。
#U：user Owership differs，文件所有者发生改变
#G：group Owership differs，文件所属用户组已被改变
#T：mTime differs，文件创建时间已被改变

#其次的一个字符为文件的类型，如上是一个c
#c：设置文件（config file）
#d：文档（documentation）
#g：ghost file
#l：授权文件（license file）
#r：自述文件（read me）
```

## 14.2 SRPM

一般RPM的安装包它的后缀名为**XXX.rpm**，安装包是已经编译的文件，可以直接安装。

然而，RPM的软件安装环境必须与打包时的环境相同，需要满足软件的依赖属性需求，可移植性弱。

**SRPM（source RPM）所提供的软件内容并没有经过编译，它提供的是源代码**，扩展名通常是以**XXX.src.rpm**这种格式。

它与RPM不同的是，要安装此软件必须

1. 先将该软件以RPM管理的方式进行编译，此时SRPM会被编译成RPM文件
2. 然后将RPM文件安装到Linux系统中

## 14.3 yum

### 14.3.1 软件管理

yum（ Yellow dog Updater, Modified）

yum 替你下载软件，替你解决依赖关系，替你安装 

**yum [ option ] [ 查询工作项目 ] [ 相关参数 ]**

- option：

  * list—列出目前主机上yum所管理的所有软件，类似于rpm -qa
  * info—类似于rpm -qai
  * provides—通过文件搜索软件，类似于rpm -qf
  * search—搜索后面工作项目关键字
  * install—接需要安装的软件
  * update—接需要更新的软件
  * remove—接需要删除的软件
  * clean—清除缓存目录下的。[ packages | headers | all ]

- 相关参数

  - -y—当yum要等待用户输入时，这个选项可以自动提供yes的响应输入
  - **--installroot=/some/path**，将软件安装在/some/path中而不使用默认路径

  

### 14.3.2 yum配置

容器设置

在/etc/yum.repos.d/文件夹下放有多个容器设置

```bash
cat CentOS-Base.repo 

[BaseOS]
name=CentOS-$releasever - Base
baseurl=http://mirrors.cloud.aliyuncs.com/$contentdir/$releasever/BaseOS/$basearch/os/
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial

#[container_name]：容器名，在容器列表中充当repo id
#name：repos name，容器，在容器列表中充当repo name
#mirrorlist：列出这个容器可以使用的镜像站点，如果不用可注释。mirrorlist是由yum程序自行去找进行站点，
#baseurl：容器的实际网址，baseurl是指定固定的一个容器网址
#enable：1容器启用，0容器关闭，在容器列表中充当status
#gpgcheck：1指定是否需要查阅RPM文件内的数字证书
#gpgkey：数字证书的公钥文件所在位置。

#查看主机的容器列表
yum repolist all

repo id                                            repo name                                                                       status
AppStream                                          CentOS-8 - AppStream                                                           enabled
AppStream-source                                   CentOS-8 - AppStream Sources                                                  disabled
BaseOS                                             CentOS-8 - Base                                                                enabled
BaseOS-source                                      CentOS-8 - BaseOS Sources                                                     disabled
```



# 补充

1. 关于终端
   - 目前我只谈两种：tty和ptsl
   - **tty**：打字机（teletype），现在泛指各种类型的终端设备，你坐在主机前，接了键盘和显示器，启动时就是那种黑框框没有图形界面的地方直接登录，这种登录终端我们叫他 TTY（终端控制台）
   - **pts**：伪终端（pseudo terminal slave），远程登录（使用telnet或者ssh），或者是你开机之后，用图形界面登录，然后打开的gnome等终端
   - **w**命令，用于显示目前登录系统的用户信息，
     - **w**：登录系统的用户列表
   - 
2. 模板字符串
   - \`pwd\`/test.sh，pwd执行返回的结果，当做前缀，执行该script脚本
   - \`cmd\`，用于执行bash命令并返回字符串。
3. 

# 命令集合

| 命令    | 描述                                                         | 实例                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ls      | 文件列表                                                     | ls -l filename 文件名下子文件的信息<br />ls -ld filename 本文件的信息 |
| clear   | 清屏                                                         |                                                              |
| date    | 日期时间                                                     |                                                              |
| cal     | 日历calendar                                                 | cal 6 2020                                                   |
| bc      | 计算器 scale设置精度                                         | bc enter scale=2 quit 退出                                   |
| history | 记录命令行敲过的命令（最多1000）                             |                                                              |
| !       | 执行history列出的命令                                        | !22，!+history列表中的索引                                   |
| nano    | nano文本编辑器                                               |                                                              |
| man     | man page帮助                                                 |                                                              |
| info    | info page帮助                                                |                                                              |
| gedit   | gedit文本编辑器                                              |                                                              |
| sync    | 数据同步写到到磁盘中去                                       |                                                              |
| ln      | 用于将一个文件创建链接(快捷方式，有软硬之分)                 |                                                              |
| touch   | 一、是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；<br />二、是用来创建新的空文件。 |                                                              |
| cd      |                                                              |                                                              |
| mkdir   |                                                              |                                                              |

# 常用操作

1. 命令行翻页：【 Shift + Pageup/Pagedown】

2. 通过管道符分页查看内容：eg：【 ls | less 】 Pageup/Pagedown 离开+q

3. 查看命令是否存在：【 type command 】

4. 删除文件：【 rm -fr 文件名 】

5. [后台运行程序](<https://blog.csdn.net/u013123046/article/details/80610931>)：
   - 查看后台运行程序【 ps -aux 】
   - 后台运行程序 【nohup ......... &】
   - 杀进程：轻杀【kill pid】，强杀【 kill -9 pid】，pid为ps -aux中的pid
   
6. 端口与进程
   - 查看端口号下运行的进程：【 lsof -i:端口号】
   - 通过pid查看进程占用的端口：【 netstat -anp | grep pid 】
   
7. 查询rpm包管理工具中是否安装某个软件：【 rpm -qa | grep software】

8. 查看ubantu系统中APT包管理系统中安装的软件：【 apt list --installed 】

9. 查看ip地址：【ifconfig】或【ip addr】，好像看不到外网地址，只能看到内网的。

   ```bash
   # etho 表示网卡的代号
   eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
           inet 10.0.4.8  netmask 255.255.252.0  broadcast 10.0.7.255 
           # 这里的10.0.4.8就是内网ip，broadcast代表广播地址
           inet6 fe80::5054:ff:feac:42c1  prefixlen 64  scopeid 0x20<link>
           ether 52:54:00:ac:42:c1  txqueuelen 1000  (Ethernet)
           RX packets 4575266  bytes 676977858 (645.6 MiB)
           RX errors 0  dropped 0  overruns 0  frame 0
           TX packets 4502910  bytes 718125324 (684.8 MiB)
           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
   # lo表示本机的环回接口
   lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
           inet 127.0.0.1  netmask 255.0.0.0
           inet6 ::1  prefixlen 128  scopeid 0x10<host>
           loop  txqueuelen 1000  (Local Loopback)
           RX packets 671  bytes 85537 (83.5 KiB)
           RX errors 0  dropped 0  overruns 0  frame 0
           TX packets 671  bytes 85537 (83.5 KiB)
           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
   
   ```

   

10. [系统防火墙](https://www.cnblogs.com/moxiaoan/p/5683743.html)

    ```bash
    # 查看防火墙开放的端口号
    firewall-cmd --list-all
    # 如果出现FirewallD is not running，说明防火墙服务处于关闭状态。
    # 查看防火墙状态
    systemctl status firewalld
    
    ● firewalld.service - firewalld - dynamic firewall daemon
       Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
       Active: inactive (dead)# 果然处于关闭状态。
         Docs: man:firewalld(1)
    # 开启防火墙，没有任何提示即开启成功
    systemctl start firewalld # 关闭防火墙 systemctl stop firewalld
    
    # 开放端口
    firewall-cmd --add-port=80/tcp --permanant # --permanent永久生效，没有此参数重启后失效
    # 开放后需要重启防火墙，即可生效。
    firewall-cmd -reload
    
    # 删除
    firewall-cmd --zone= public --remove-port=80/tcp --permanent #--zone 作用域
    ```

    

11. 添加环境变量

    ```bash
    # 1.针对所有用户长久有效
    # 通过export添加变量参数
    vim /etc/profile
    
    # 通过这个函数可以实现在现有的path上面添加新的path
    pathmunge () {
        case ":${PATH}:" in
            *:"$1":*)
                ;;
            *)
                if [ "$2" = "after" ] ; then
                    PATH=$PATH:$1
                else
                    PATH=$1:$PATH
                fi
        esac
    }
    pathmunge /usr/local/nginx/sbin
    export PATH
    
    # 保存etc/profile后，需要下面的命令使文件生效
    source /etc/profile
    
    # 2.针对当前用户长久有效
    vi ~/.bash_profile
    # 操作同上
    
    # 3.针对当前登录会话有效，关闭之后下次登录shell就无效了
    # 直接将上面的export 命令执行一遍。这种方式最简便，适合临时设置环境变量使用
    ```

    

12. 下载文件：[wget](https://www.cnblogs.com/ftl1012/p/9265699.html)

    wget是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。 wget支持HTTP，HTTPS和FTP协议。

    ```bash
    # 下载文件到当前目录下
    wget http://www.minjieren.com/download.aspx?id=1080
    # -O：下载文件到对应目录，并且修改文件名称
    wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080
    # -b：后台下载，查看下载进度：tail -f wget-log
    wget -b wordpress.zip http://www.minjieren.com/download.aspx?id=1080
    ```

    

13. 

```bash

```




<table cellpadding="2" cellspacing="2"> 
 <tbody> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">任务</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">旧指令</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">新指令</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">使某服务自动启动</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">chkconfig --level 3 httpd on</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl enable httpd.service</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">使某服务不自动启动</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">chkconfig --level 3 httpd off</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl disable httpd<span style="word-wrap: break-word; font-style: italic;"></span>.service</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">检查服务状态</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">service httpd status</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl status&nbsp;<span style="word-wrap: break-word; line-height: 1.5;">httpd</span>.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">显示所有已启动的服务</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">chkconfig --list</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl list-units --type=service</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">启动某服务</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">service httpd start</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl start httpd.service<span style="word-wrap: break-word; font-style: italic;"></span></td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">停止某服务</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">service httpd stop</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl stop httpd.service</td> 
  </tr> 
  <tr> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">重启某服务</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">service httpd restart</td> 
   <td style="word-wrap: break-word; margin: 0px; padding: 0px;">systemctl restart httpd.service</td> 
  </tr> 
 </tbody> 
</table>

# Ubantu

dpkg 主要是用来安装已经下载到本地的 deb 软件包，或者对已经安装好的软件进行管理。而 apt-get 可以直接从远程的软件仓库里下载安装软件。

## 
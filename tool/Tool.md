# [Regex](<https://www.zhihu.com/question/48219401/answer/742444326>)

---

## 基础

**正则表达式的通项： /pattern/flags**

| 符号\|组别       | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
|                  |                                                              |
| **合法字符**     |                                                              |
|                  |                                                              |
| **"  x  "**      | x代表任意合法字符                                            |
| **"  \uhhhh  "** | 十六进制所代表的Unicode字符                                  |
| **"  \t  "**     | 制表符                                                       |
| **"  \n  "**     | 换行符                                                       |
| **"  \r  "**     | 回车符                                                       |
| **"  \f  "**     | 换页符                                                       |
| **"  \cx  "**    | x对应的控制符，                                              |
|                  |                                                              |
| **预定义字符**   |                                                              |
|                  |                                                              |
| **"  .  "**      | 匹配任意**一个**字符                                         |
| **"  \d  "**     | 匹配所有数字                                                 |
| **"  \D  "**     | 匹配所有非数字                                               |
| **"  \s  "**     | 匹配所有空白符，包括空格，制表符，回车符，换页符，换行符等   |
| **"  \S  "**     | 匹配所有非空白符                                             |
| **"  \w  "**     | 匹配所有单词字符，包括0-9，26个字母和下划线                  |
| **"  \W  "**     | 匹配所有非单词字符                                           |
|                  |                                                              |
| **特殊字符**     |                                                              |
|                  |                                                              |
| **"   ^  "**     | 匹配一行的起始，eg：" ^a "代表匹配所有以字母a开头的字符串    |
| **"  $  "**      | 匹配一行的结尾                                               |
| **"  [  ]  "**   | 匹配字符集里的多个字符，存在集里的字符即匹配，eg：[0-9c]匹配0到9或c中的任意多个字符 |
| **"  (  )  "**   | 匹配子表达式                                                 |
|                  |                                                              |
| **重复限定符**   |                                                              |
|                  |                                                              |
| **"  {  }  "**   | 指定其前面子表达式可以出现的次数，<br />**{ n }——重复n次、{n , }——重复大于等于n次、{ n , m }——重复n到m次**<br />eg：(a){3}，a连续出现三次， |
| **"  *  "**      | 指定其前面子表达式可以出现0或多次                            |
| **"  +  "**      | 指定其前面子表达式可以出现1或多次                            |
| **"  ?  "**      | 指定其前面子表达式可以出现0或1次                             |
|                  |                                                              |
| **"  \|  "**     | 指定竖线两侧的两项中任选一项匹配                             |
| **"  \  "**      | 转义字符                                                     |
|                  |                                                              |
| **边界匹配符**   |                                                              |
|                  |                                                              |
| **"  \b  "**     | 单词的边界，即只能匹配到单词前后的空白                       |
| **"   \B  "**    | 非单词的边界                                                 |
| **"   \A  "**    | 只匹配字符串的开头                                           |
| **"   \Z  "**    | 只匹配字符串的结尾                                           |

<b>方括号表达式</b>

| 用途            | 解释                                     |
| --------------- | ---------------------------------------- |
| **表示枚举**    | eg：[abc]                                |
| **表示范围**    | eg:[a-z]                                 |
| **表示求否：^** | eg:[**^**abc]                            |
|                 |                                          |
| **匹配模式**    |                                          |
|                 |                                          |
| **"  i  "**     | ignorCase忽略大小写                      |
| **"  g  "**     | globle进行全局匹配，指匹配到目标串的结尾 |
| **"  m  "**     | mutiple允许多行匹配                      |

## 断言匹配

断言只是匹配位置，也就是说，匹配结果里是不会返回断言本身，返回的是断言前后的符合另一个正则表达式的内容

1. 正向先行断言：

   - 找到pattern的位置，然后找该位置之前的prePattern内容作为匹配结果返回

   - ```js
     //格式
     prePattern(?=pattern)
     ```

   - 

2. 正向后行断言

   - 找到pattern的位置，然后找到该位置之后的affixPattern内容作为匹配结果返回

   - ```js
     //格式
     affixPattern(?<=pattern)
     ```

   - 

3. 负向前行断言

   - 负向的意思是对pattern进行取非操作，然后找到非pattern的位置，再将该位置之前的prePattern内容作为匹配结果返回

   - ```js
     //格式
     prePattern(?!pattern)
     ```

   - 

4. 负向后行断言

   - 负向的意思是对pattern进行取非操作，然后找到非pattern的位置，再将该位置之后的affixPattern内容作为匹配结果返回

   - ```js
     //格式
     affixPattern(?<!pattern)
     ```

   - 

## 捕获

单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。

一个正则表达式里有多个子表达式（用括号括起来的表达式，eg：（[a-z]|\d），这些子表达式就作为一个正则表达式的分组。

匹配子表达式的内容，把匹配结果保存到内存中，用数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。

1. 数字编号捕获组
   - 从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第1组开始为分组。
   - 格式：(pattern)，，eg：(0\d{2})-(\d{8})，第0组为整个表达式，第一分组为(0\d{2})，第二分组为(\d{8})
2. 命名编号捕获组
   - 分组的命名由表达式中的name指定
   - 格式：(?\<name>pattern)，eg：(?\<quhao>\0\d{2})-(?\<haoma>\d{8})
3. 非捕获组：
   - 用来标识不需要捕获的分组，就是可以根据你的需要来捕获分组。
   - 格式：(?:pattern)，eg：(?:\0\d{2})-(?\<haoma>\d{8})

## 反向引用

通常捕获组和反向引用是组合使用的。

举个例子：假如你想匹配到aa，bb，cc，11这样的内容。

- 1）匹配到一个字母
- 2）匹配第下一个字母，检查是否和上一个字母是否一样
- 3）如果一样，则匹配成功，否则失败

这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
这下子捕获就有用处啦，我们**可以利用捕获把上一个匹配成功的内容（引用捕获分组的内容）用来作为本次匹配的条件**

- 1）匹配到一个字母，\w
- 2）匹配第下一个字母，检查是否和上一个字母是否一样，(\w)\1，\1的意思是引用了(\w)捕获组的内容，这样就会匹配到和(\w)一样的字母了
- 3）如果一样，则匹配成功，否则失败

根据捕获组的命名规则，反向引用可分为：

1. 数字编号组反向引用：\k 或 \number
2. 命名编号组反向引用：\k 或者 \\'name'

## 贪婪

贪婪与懒惰

### 贪婪

当正则表达式中**包含能接受重复的限定符**时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。

```js
let str="61762828 176 2991 44 871";
let pattern=/\d{3,6}/
//617628  176  2991  871
```

按照表达式来，在匹配到617这三个字符已经成功匹配到了一个，但是它并不满足，所以它要继续匹配，看看它能不能匹配到更长的结果，结果第一个匹配的结果为617628。

这就是贪婪。

### 懒惰

懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。
特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

在重复限定符后面加？号，就构成了懒惰匹配。

```js
*?//任意次，但尽可能少
+?//一次或多次，但尽可能少
??//0次或一次，但尽可能少
{n,m}?//n次到m次，但尽可能少
{n,}?//n次以上，但尽可能少
```

## JavaScript字符串函数

```js
1. string.indexOf(searchStr, start);
2. string.search(searchStr|regexp)//返回目标字符串的开始位置
3. string.lastIndexOf(searchStr,start);//从指定start位置，由后往前匹配
4. string.substr(start,length)
5. string.substring(from, to)//提取子字符串，左闭右开，from、to不可以为负数
6. string.slice(start,end)//提取子字符串，左闭右开，start、end可以为负数

//函数的第二个参数，可以为function，func的第一个参数为整个regexp匹配到的一个内容，第二个参数为第一个分组捕获(正则子表达式匹配)的内容，依次类推，func的返回值作为替换字符串。
7. string.replace(searchStr|regexp,repStr|func)
8. string.match(regexp);//regexp的包含g，返回一个匹配内容的数组，无匹配内容为null

9. string.includes(searchStr, start);//返回true，false
10. string.startsWith(searchStr, start)//是否以searchStr开头

11.string.split(separator,longlimit)//返回分割的子字符串数组
12. string.repeat(count)//重复目标字符串指定次数，并返回

13. string.toLowerCase()
14. string.toUpperCase()
15. string.trim()
16. string.length
```

## 相关练习

1. 给一个连字符串例如：get-element-by-id转化成驼峰形式。

   ```js
   let str="get-element-by-id";
   let word='';
   let strn=str.replace(/(-[a-z])/g,(target)=>{
       return target.charAt(1).toUpperCase() 
       //target.substr(1,1).toUpperCase()
   })
   console.log(strn)
   ```

2. 匹配二进制数字

   ```js
   let str="fh5890u1001u201110137";
   let arr=str.match(/(?<=[^0-9]|^1)1(0|1)*(?=[^2-9])/g);
   //这个regExp有3部分组成：
   //1.首部定位：(?<=[^0-9]|^1)正向后行断言，只用来定位以非数字为首，或以1为首位置，所以它前面没有任何prepattern
   //2.中部实体内容：1(0|1)*
   //3.尾部定位：(?=[^2-9])/g)正向前行断言，只用来定位以尾部不能以2-9结尾
   console.log('数组',arr);
   ```

3. 非零的十进制数字 (有至少一位数字, 但是不能以0开头)

   ```js
   let str="fh5890u1001u201110137";
   let arr=str.match(/(?<=[^0])[1-9][0-9]*(?=[^a-fA-F])/g);
   console.log('数组',arr)
   ```

4. ip地址

   ```js
   //ip地址
   //xxx分成
   //0-9,\d
   //10-99,[1-9]\d，0-99的号段合并为[1-9]?\d
   //100-199,[1-9]\d{2}
   //200-249,2[0-4]\d
   //250-255,25[0-5]
   //xxx的regExp：(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)
   //xxx.xxx.xxx.xxx的regEXP。xxx.重复三次匹配。
   //((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d).){3}(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)/g
   let str="192.168.145.199";
   let arr=str.match(/((25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d).){3}(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)/g);
   console.log('数组',arr)
   ```

5. 分割数字每三个以一个逗号划分

   ```js
   //结尾不加逗号，依靠反向前行断言
   let str="192168145199";
   let strn=str.replace(/\d{3}(?!$)/g,(target)=>{
       return target+","
   })
   console.log(strn);
   ```

6. 过滤html标签

   ```js
   let str="<span>hah</span><div>你好</div><img/>";
   let strn=str.replace(/(\<.*?\>)/g,(target)=>{
       console.log(target)
       return ""
   })
   console.log(strn);
   ```

7. 
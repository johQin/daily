# offer

# 1 C/C++

## 1.1 语言基础

1. C++语言特点

   - 继承C的面向过程，结构化语言，执行效率高（比汇编慢10%~20%）。
   - 面向对象：封装（结构清晰），继承（代码重用），多态（丰富扩展性，面向接口编程）。
   - 泛型编程：引入模板编程思想，在此基础上实现STL，实现算法和数据结构的分离，极大提高代码的可复用度，提高开发效率。
   - 更加安全易用，增加了引用，四个类型转换，try_catch异常类型机制
   - 发展的语言：lambda函数、右值引用，可变参数模板，智能指针等。

2. C和C++的特点

   - C++是C的超集，C++可以很好的兼容C，并且增加了许多新特性。
   - C++是面向对象的语言，而C面向过程
   - C++可复用性更高，引入泛型编程中的模板思想，在此基础上构建了STL，使C++相较于C更加灵活，更加通用
   - C++更安全，引用，智能指针，try_catch异常机制，cast转换。

3. C++中class与struct的区别

   - 使用场景：struct更多用于描述一个数据结构集合，而class是对一个对象数据的封装。
   - 本质区别是：访问控制
     - struct默认的访问权限是public，而class是private
     - struct默认的继承权限是public，而class是private
   - 泛型方面：struct不支持模板参数，而class可以。
   - 其余方面struct和class没什么大的区别:
     - class可以继承struct，struct也可以继承class，取决于继承者的类型
   - 

4. C++中的struct和C中的struct的区别

   - 声明时：

     |          | C                      | C++                      |
     | -------- | ---------------------- | ------------------------ |
     | 成员函数 | 不能有                 | 可以有                   |
     | 静态成员 | 不能有                 | 可以有                   |
     | 访问控制 | public，不可修改       | public/private/protected |
     | 继承关系 | 不可继承               | 可从其他类或结构体继承   |
     | 初始化   | 不能直接初始化数据成员 | 可以                     |

   - 初始化声明时：C中必须加上关键字struct，而C++中可以省略。

5. [include头文件中双引号""和尖括号<>的区别](https://blog.csdn.net/qq_27825451/article/details/102568482)

   - 头文件的文件类型：尖括号中的系统文件，双引号中的是自定义文件
   - 查找文件的路径顺序：
     - 双引号：
       1. 当前源文件所在的工作目录
       2. 编译器设置的头文件查找路径，编译器有默认的头文件查找路径。（当然也可以-i指定）
       3. 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径（vs，如果安装在C盘就在programfile x86下的Windows Kits\10\Source\10.0.22000.0\ucrt，如果在其他盘就在盘下的Windows Kits\10\Source\10.0.22000.0\ucrt）
     - 尖括号就在后两个路径上找

6. 在C++中导入C语言代码的关键字。

   - 关键字是extern，表达形式是extern "C"
   - 主要作用：为了实现C++代码调用其他C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言进行编译，而不是C++
   - 在函数方面，C编译器和C++编译器编译有所不同，由于C++支持函数重载，编译时函数名会加上参数的类型，而C不会。

7. 简述C++从代码到可执行的二进制文件的过程

   - C++和C语言类似，总过程：预处理（预编译，.i），编译（.s），汇编（.o），链接（.exe）
   - 预处理阶段：主要做宏处理，宏分四类：define宏定义，include宏，if条件编译宏，预定义宏
     - 处理宏定义展开
     - 处理所有条件编译宏
     - 处理include宏，将被包含的文件插入到预编译指令的位置
     - 处理预定义宏，添加行号，文件名，日期等。
     - 生成.i的临时文件
   - 编译阶段
     - 词法分析，语法分析，语义分析，代码优化，生成汇编代码，汇编代码优化
     - 生成.s临时文件
   - 汇编阶段
     - 将汇编代码转变为机器可以执行的指令。
     - 生成目标文件.o或.obj
   - 链接阶段
     - 将不同源文件产生的目标文件进行链接，从而形成可执行的程序。
     - 生成可执行文件（window为.exe，linux为.out)
     - 链接分为静态和动态链接：
       - 静态链接：将函数和数据编译成一个静态链接库文件（windows为.lib，linux为.a），在链接的时候，把需要调用的函数或过程嵌入链接到生成的可执行文件中，现在就算你把静态库删除也不会影响可执行程序的执行。
         - 静态库本身并不需要与可执行文件一起发行。
       - 动态链接：将函数和数据编译成生成动态链接库文件（windows为.dll，linux为.so），在链接的时候，并没有把调用的函数和过程嵌入链接进入可执行文件中，只包含函数的重定位信息。所以当你删除动态链接库的时候，可执行程序就不能运行。

8. 关键字static的作用

   - 静态局部变量和静态全局变量，
     - 静态全局变量：
     - 静态局部变量：在编译时分配内存并赋初值（之后不再赋初值），函数调用后，内存不释放
   - 静态函数
   - 静态变量和静态函数都被限制在本文件中。
   - 在C++的类中，被用于定义静态成员（变量和函数），
     - 静态成员只有一份拷贝，为所有对象共享
     - this指针无法引用

9. [指针和数组的区别](https://blog.csdn.net/qq_36992917/article/details/79238874)

   - |          | 数组                                               | 指针                       |
     | -------- | -------------------------------------------------- | -------------------------- |
     | 访问效率 | 直接访问，效率高                                   | 间接访问，效率低           |
     | 字节大小 | 不固定，数组类型和元素个数决定                     | 固定，由操作系统的字长决定 |
     | 标识符   | 指针常量，不可以使用自增++                         | 指针变量，可以使用自增++   |
     | 内存空间 | 存储的是一系列数值，对应的空间大小不可变，内容可变 | 存储的是地址               |
     | 赋值     | 遍历数组进行赋值                                   | 同类型指针变量可以相互赋值 |

   - 数组对应一块内存区域，地址和容量在其生命周期不会改变，其内容可变。而指针指向一块内存区域，指向的区域地址和大小可变。

10. 函数指针

    - 概念：指向函数的指针，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址

    - 定义：

      ```c
      int func(){}
      int (*f)();
      f= &func;
      ```

    - 应用场景：做回调函数。

11. [静态变量初始化时机](https://blog.csdn.net/u011723812/article/details/78151533)

    - 全局变量，文件域的静态变量和类的静态成员变量，在main执行之前，分配内存并初始化（编译期初始化）
    - 局部静态变量在第一次使用时分配内存并初始化。
    - 初始化线程安全性：非局部静态变量线程安全。而局部静态变量线程不安全（编译器的实现是通过一个标识，来标定这个局部静态变量是否初始化），而在支持C++11标准的编译环境下，它是线程安全的。
    - 全局或静态对象当且仅当对象首次用到时才进行构造

12. 用nullptr初始化类的对象，可不可以调用类的成员函数

    - nullptr可以调用成员函数，因为成员函数在编译对象时，就已经绑定了函数地址，和指针空不空没有关系

    - ```c++
      class animal{
      	public:
      		void sleep(){ cout << "animal sleep" << endl; }
      		void breathe(){ cout << "animal breathe haha" << endl; }
      };
      class fish :public animal{
      	public:
      		void breathe(){ cout << "fish bubble" << endl; }
      };
      int main(){
      	animal *pAn=nullptr;
      	pAn->breathe(); // 输出：animal breathe haha
      	fish *pFish = nullptr;
      	pFish->breathe(); // 输出：fish bubble
      }
      ```

13. [野指针](https://blog.csdn.net/qq_40927789/article/details/80686723)

    - 没有初始化的指针，指针指向的位置不可知。

    - 悬垂指针：指向已经释放内存区域的指针

    - 危害：

      - 指向一个不可访问的空间
      - 指向一个没有明确意义的空间，在这种情况下， 程序是正确的，可以正常运行，然而事实上是有问题存在，掩盖了程序上的错误
      - 指向一个可用，并且正在被使用的空间，如果我们用这样的指针对所指空间进行了修改，这个修改对程序的运行大概率会有影响，进而导致程序崩溃，或数据被损坏

    - 避免方法:

      - 初始化置NULL

      - 申请内存后判空

      - 内存释放后指针置空

      - 使用智能指针

      - ```c
        int *p = NULL; //初始化置NULL
        
        p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间
        assert(p != NULL); //判空，防错设计
        
        p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
        free(p);
        p = NULL; //释放后置空
        ```

14. 静态局部变量，静态全局变量，全局变量，局部变量的区别。

    - 作用域：
      - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件
      - 静态全局变量：文件作用域
      - 局部变量：局部作用域
      - 静态局部变量：局部作用域，只初始化一次，直到程序结束
    - 所在空间
      - 除局部变量在栈区（动态存储区），其他都在静态存储区。
    - 生命周期
      - 由于局部变量在栈上，出了作用域就回收存储，而其他都在静态存储区上，知道程序结束才回收内存。

15. 内联函数和宏函数的区别

    - 内联函数：广义的来说，定义时被inline修饰的函数。一般用于比较小而简单的，频繁调用的函数。
    - 宏函数：通过define定义的标识符，带参数的宏
    - 相同点：
      - 宏函数和内联函数都会在适当位置进行展开，都是以代码膨胀为代价，避免函数调用开销。
    - 区别：
      - 性质：宏函数不是函数（只是像，但不是），而内联函数是函数。
      - 处理阶段：宏函数在预处理阶段，而内联函数在编译阶段
      - 参数方面：宏函数没有类型检查（只进行简单的字符串替换），而内联函数会进行类型检查。

16. 内联函数和函数的区别

    - 定义需要inline修饰
    - 内联函数没有函数调用开销
    - 内联函数无需寻址（代码在调用处展开）
    - 选择：调用开销、执行函数体时间、代码量，三个维度来决定函数是内联还是普通

17. 运算符`i++和++i`的区别

    - 赋值顺序不同，
    - 效率不同：后置++比前置++效率低，后置`++`要多生成一个局部对象 tmp，因此执行速度比前置的慢。
    - i++不能作为左值，而++i可以
    - 二者都不是原子操作。

18. new和malloc的区别，各自底层实现原理

    - 区别：

      |      | new                                                          | malloc                                     |
      | ---- | ------------------------------------------------------------ | ------------------------------------------ |
      | 类型 | 操作符                                                       | 函数                                       |
      | 重载 | 可重载                                                       | 不可重载                                   |
      | 异常 | 发生错误，抛异常，分配内存更直接更安全，                     | 返回NULL                                   |
      | 构造 | **new** 和 **delete** 分别是 **开空间+构造函数**、**析构函数+释放空间** | 开空间和释放空间                           |
      |      | 会调用构造函数，无需指定内存大小，指针无需强转               | 需要给定申请的内存大小，返回的指针需要强转 |

    - [malloc底层实现](https://blog.csdn.net/Allelujah123/article/details/123874128)

      - https://blog.csdn.net/weixin_43340455/article/details/124570759
      - malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表为每一个空闲块记录了一个未分配的、连续的内存地址。

    - new底层实现

      - 创建一个新的对象
      - 将构造函数的作用域赋值给这个新的对象
      - 执行构造函数的代码
      - 返回新对象

19. [const详解](https://blog.csdn.net/qq_40337086/article/details/125519833)

    - [const 修饰变量](https://blog.csdn.net/weiyuanzhang123/article/details/117592035)：**const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。**
      - const int * ：`(const int) *`——指针指向一个整型常量，不可改变指针指向的内容，但指针本身可以改变
      - int const *：`(int const) *`——同上
      - int * const：`int (* const)`——指针常量指向一个整型变量，可改变指针指向的内容，但指针本身不可改变
      - const int * const：`(const int) (* const) `——指针常量指向整型常量
      - int const *const：`(int const) (* const)`
    - 

20. C++有几种传值方式

    - 值传递：改变形参的值，不会改变实参的值
    - 引用传递：改变形参的值，会改变实参的值
    - 指针传递：如果指针的指向没有改变，改变形参的值，会影响实参的值

21. 使用指针的注意

    - 防止野指针：
      - 定义指针变量时，初始化为NULL
      - 申请内存后，判空
      - 释放内存后，置为NULL
    - 动态内存申请和释放必须配对，防止内存泄漏
    - 避免指针越界

22. 常量定义：const和define 

    - 生效阶段：const在编译阶段，define在预处理阶段
    - 内存占用：const定义的变量需要占用内存空间，define运行时时直接的操作数
    - 类型：const定义的变量时有类型的，而define无

23. 



## 1.2 C++内存

1. [堆和栈的区别](https://blog.csdn.net/mynameisJW/article/details/105150558)
   - 管理方式：栈由操作系统自动分配和释放，堆的分配释放由开发者控制，容易产生内存泄漏。
   - 空间大小：每个进程拥有的栈空间要远远小于堆的大小，64bits windows默认栈是1M，64bits linux默认10M，而可申请的堆理论大小是虚拟内存的大小
   - 生长方向：堆生长方向向上，内存地址由低到高，栈的生长方向向下，内存地址由高到低。
   - 分配方式：
     - 堆只能动态分配，栈动态和静态分配都有。
     - 静态分配是由操作系统完成的，比如局部变量的分配。
     - 堆的动态分配由malloc或new函数进行分配，须手动free和delete。栈的动态分配不同于堆，**栈中动态分配内存**的函数`alloca`，用法与malloc，但不用free，由操作系统自动释放。
   - 分配效率：
     - 栈由操作系统自动分配，会在硬件层级对栈提供支持：提供专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，效率高
     - 堆则由C/C++提供库函数或运算符来完成管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片，效率低。
   - 存放内容:
     - 栈存放函数变量、参数、地址、寄存器内容
     - 堆一般存放对象，具体内容由开发者填充
   - 生命周期：栈短堆长，栈中存储的数据随函数执行完成而结束，系统自动释放空间。而堆如果不手动释放，其生命周期等同进程生命周期
   - 数据结构：栈是一种线性数据结构，遵守FILO的规则，而堆是一种非线性的完全二叉树
2. [C++内存管理](https://blog.csdn.net/weixin_41055260/article/details/118981630?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-118981630-blog-124414552.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3)
   - 内存管理（分配方式）机制：分为5个区，栈区，堆区，自由存储区，静态存储区，常量区，代码区。
     - 栈区：存放函数内的局部存储单元
     - 堆区：由new分配的内存块，需要delete释放
     - 自由存储区：由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。（在C里面，这就是堆）
     - 静态存储区：存放全局，静态变量
     - 常量存储区：存储的是常量，不允许修改
     - 代码区：存放可执行的机器码
   - 内存泄漏机制：
     - 内存泄漏：程序在申请内存后，无法释放已申请的空间，占用有用内存，最终导致内存溢出。
     - 泄漏分为两类：
       - 堆内存泄漏：堆上申请资源后，使用结束后，未释放
       - 资源泄漏：通常指系统资源，比如socket，文件描述符等。因为这些在系统中都是有限的，创建而不释放，系统资源会耗尽
     - 产生方式分类：
       - 常发性内存泄漏：每执行一次，就会造成一次泄漏
       - 偶发性内存泄漏：特定场景下执行，就会一次泄漏
       - 一次性内存泄漏：造成泄漏的代码只会被执行一次。
       - 隐式内存泄漏：不停分配内存。
     - 泄漏的场景：
       - new和malloc申请资源使用后，没有用delete和free释放；
       - 子类继承父类时，父类析构函数不是虚函数。
       - Windows句柄资源使用后没有释放。
     - 怎么检测（避免）内存泄漏：
       - 申请和释放一定要成对存在
       - 分配的内存的指针以链表形式管理，使用完成后从链表中删除，程序结束时检查链表中的指针是否都得到了释放。
       - 使用智能指针
       - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
   - 内存回收机制
     - 垃圾回收技术所解决只有两个问题：
       - 如何识别当前内存中未被引用的内存块
       - 如何将失去管理的内存进行回收
     - 引用计数：除内存块外增加一个引用计数，当内存块被引用，计数加1，当内存块失去引用，计数减1，同时检查引用计数，如果为0，就销毁释放内存
     - 标记清除：垃圾回收器扫描所有内存块，将被引用的内存块进行标记，标记完成后，统一检测内存，将所有未被标记的内存块回收
   - 
3. [内存对齐](https://blog.csdn.net/qq_39397165/article/details/119745975)
   - 由于CPU对内存的访问不是随机的，而是在特定地址或字长的整数位置访问内存，所以对数据的存储要按照一定的空间规则，使CPU对一个数据单元访问的次数尽量小，这就是内存对齐。
4. C++程序启动过程
   - 操作系统首先创建相应的进程并分配私有的进程空间，操作系统的加载器负责把可执行文件的数据段和代码段映射到进程虚拟内存空间。
   - 加载器读入可执行程序的导入符号表，根据这些符号可以查找出该可执行程序的所有依赖的动态链接库。
   - 加载器针对该进程的每个动态链接库，调用LoadLibrary
     - 查找动态库文件，读入动态链接库，调用动态链接库初始化应用程序的函数
   - 初始化应用程序的全局变量，对于全局对象自动调用构造函数
   - 进入应用程序入口点函数开始执行
5. 

## 1.3 面向对象

1. 三大特征：

   - 封装：将数据和操作数据的方法进行有机结合，加以权限区分，隐藏对象的属性和实现细节，仅对外公开来和对象进行交互。
   - 继承：利用已有类定义新类，新类可以使用和扩展已有类的功能。
     - 三种继承方式：public，private，protected（父类成员权限被继承方式限制）
     - 构造函数，析构函数，operator=，都不能继承（子类不会复制父类的函数，类的函数，只有一份，为所有对象共享，包括子类对象），对象的空间计算包含：对象的父类和本身的非静态属性。
   - 多态：
     - **同一类型的多个实例，在执行同一方法时，呈现出多种行为特征——多态**
     - 静态多态（编译时多态）：重载，重定义（子类重新定义父类的非虚函数，覆盖）
     - 动态多态（运行时多态）：重写（子类重写父类虚函数）
       - 协变（子替代父）是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。
       - 不变（两个毫不相关的类，不能相互替代），协变（子替代父），逆变（父替代子）
   - 

2. C++的重载和重写

   - 重载：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。（返回值类型不同不能作为重载的条件）
     - 采用命名倾轧技术，重载函数在编译时，会将参数类型的首字母作为函数名的一部分，以此来区分重载的多个函数。
   - 重写：子类重写父类的虚函数，返回值类型、函数名，参数顺序，个数，类型都必须一致。
     - 在基类的函数前加virtual修饰，在子类中重写该函数，运行时将会根据对象的实际类型调用相应的函数
     - 采用虚函数动态绑定原理，
       - 当声明父类一个函数为虚函数时，就会为这个类声明一个虚函数指针vfptr，这个指针指向一个虚函数表vftable，表里记录这虚函数的入口地址。
       - 当子类继承父类时，会继承这个vfptr和vftable，当子类重写了父类虚函数的同时，通过vfptr找到vftable，修改这个函数对应的入口地址为子类的函数地址。
       - 当父类指针指向子类的空间时，本质上还是调用父类的那个函数，当调用父类的那个函数时，发现此函数是一个虚函数指针，通过这个指针找到这个vftable，从而找到子类函数的入口地址，间接调用了子类函数
   - 重定义：子类重定义父类的同名函数（非虚），参数的顺序，个数，类型可以不同。

3. C实现函数重载

   - C不允许函数同名，因为编译时，同名函数名都是一样的

   - 采用函数指针，将一个函数的一个参数类型定义为函数指针，其他参数为这个函数指针的参数

   - 使用可变参数函数（stdarg.h，val_list类型和三个宏函数va_start，va_arg，va_end）

   - [gcc内置函数](https://www.it1352.com/1987845.html)可以实现函数重载

   - ```c++
     // 函数指针实现函数重载
     #include<stdio.h>
     
     typedef void (*ptr)(void *); //typedef申明一个函数指针
     
     void func_int(void * a){
     	printf("%d\n",*(int*)a); //输出int类型，注意 void * 转化为int
     }
     void func_double(void * b){
     	printf("%.2f\n",*(double*)b);
     }
     
     void c_func(ptr p,void *param){
     	p(param); //调用对应函数
     }
     
     int main(){
     	int a = 23;
     	double b = 23.23;
     	c_func(func_int,&a);
     	c_func(func_double,&b);
     	return 0;
     }
     
     // 可变参数实现函数重载
     #include<stdarg.h>
     int fun(int n, ...){
         //1. 在函数中创建一个va_list类型的变量
         val_list ap;
         //2. 初始化一个参数列表
         va_start(ap,n);
     //    for(int i = 0;i < n; i++){
     		//3.访问参数列表的内容
         	va_arg(ap,int);
     //    }
     	//4. 清理
         va_end(ap);
     };
     ```

   - 

4. 仿函数

   - 重载了operator()的类，其对象称为函数对象，是行为类似函数的对象，也叫仿函数
   - 它是一个类的实例，而不是函数。
   - 超出普通函数概念，可以拥有自己的状态。
   - 模板函数使得函数对象的通用型更好，这也是它的优点之一。

5. 类方法和数据的权限

   - public：类的实例可以**直接访问**
   - protected：允许本类及子类的**成员函数可以访问**
   - private：允许本类的成员函数可以访问。

6. 派生类的继承方式（权限）影响对父类成员的访问。

   - 继承方式（权限）会限制父类成员的访问权限，继承权限大的不会影响访问权限小的父类成员，继承权限小的会缩小访问权限大的父类成员至继承权限。

7. 构造函数的种类

   - 默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数，转换构造函数。

   - 默认构造函数（无参构造）和初始化构造函数（有参构造）

     - 在定义对象时，完成对象的初始化工作，
     - 定义了有参构造，编译器不再提供无参构造

   - 拷贝构造函数

     - 完成对是整个对象的拷贝，旧对象和复制构造的对象各自占有不同的同样大小的堆内存。
     - 拷贝构造的形参是一个左值引用。

     - 三种情况被调用：
       - **旧对象初始化（构造）新对象**，记得是初始化，而不是赋值（=），如果等号的左边是一个已定义的对象，那么就不会发生拷贝构造
       - 函数的参数是对象，而非对象的引用。在调用函数的时候，会发生拷贝构造
       - 函数的返回值是对象，而非对象的引用。在调用函数并执行返回的时候，会发生拷贝构造。所以**引用可以大大减小拷贝构造开销**

   - 移动构造函数：**右值（临时（匿名）对象、不可寻址的字面常量）初始化新对象时**（C++11）

     - 生成一个指针指向源对象地址，接管源对象的内存。
     - 移动构造的形参是一个右值引用。

   - 转换构造函数：

     - 通过利用单参数的构造函数（转换构造）可以隐式转换其他对象为本构造对象，再配合相应的运算符重载，完成相关运算。
     - 类型转换函数：将本对象隐式转换为其他类型对象，完成相应的计算。

8. 拷贝和移动的区别

   - 形参：拷贝是左值引用，移动是右值引用
   - 拷贝是对整个对象的拷贝，移动是生成一个指针指向源对象的地址，接管源对象。

9. 拷贝构造参数是什么传递方式，为什么

   - 引用传递方式
   - 如果是传值，传值的方式会调用该类的拷贝构造，从而造成无穷递归调用拷贝构造

10. 空类默认有哪些函数

    - 默认构造，拷贝构造，重载赋值，析构

11. 多重继承下的构造和析构

    - 父类构造函数–>成员类对象构造函数–>自身构造函数
    - 其中成员变量的构造与在当前类声明顺序有关，父类构造函数的调用顺序是当前子类继承列表中的顺序。（与当前子类初始化列表顺序无关）
    - 析构顺序和构造顺序相反。

12. 类型转换

    - 上下行转换：
      - 上行转换：父类指针指向子类空间，不会造成内存越界，安全
      - 下行转换：子类指针指向父类空间，可能会造成内存越界，不安全
    - C++提供四种类型转换
      - static_cast：用于基类与派生类之间的指针或引用转换
      - dynamic_cast：用于类层次的上行转换
      - const_cast：用于将const修饰和非const修饰的对象之间的转换
      - reinterpret_cast：重新解释类型转换（可用于无关类之间的转换）

13. 深拷贝和浅拷贝

    - 浅拷贝：将原对象的引用直接赋值给新对象，新对象只是原对象的一个引用
    - 深拷贝：开辟一个和原对象一样的空间，创建一个新的对象，把原对象属性的“值”拷贝一份，是值而不是引用。（如果这个值是对象，那就还需迭代开辟空间）

14. 常函数

    - 类的成员函数后边被const修饰，被称作常函数。
    - 常函数体内不可修改对象中任何非静态成员变量，但是可以修改静态成员变量和mutable修饰的成员变量。
    - 常量（即 const修饰的）类的实例对象可以调用const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样。

15. 菱形继承

    - 孙子类的多个父类有共同的祖先
    - 孙子类及其派生类会拥有多份公共的数据，当孙子类及其派生类访问这份公共数据时，出现二义性，而出错

16. 虚继承

    - 在继承方式前加virtual修饰，子类虚继承父类，子类只会保存一份公共数据。
    - 虚继承解决 菱形继承中，多份公共祖先数据的问题。

17. 多态

    - 同一个类型的不同实例，在执行同一方法时，呈现出多种行为特征。
    - 除了虚函数（动态多态，运行时）可以实现多态， 还有函数重载（静态多态，编译时）可以实现多态

18. 为什么要虚析构，而不能虚构造

    - 虚析构：
      - 虚析构：析构函数被virtual修饰
      - 通过父类指针 释放整个子类空间，防止内存泄漏。原理：vfptr，通过vftable，找到虚析构函数，而这个析构函数实际指的是子类的析构函数，子类析构之后，会自动调父类的析构函数。
    - 虚构造
      - 从功能上说：虚函数是用来实现多态的，也就是对象的动态行为，而构造函数的作用是提供初始化，在对象的生命周期只执行一次，不是对象的动态行为，没有必要称为虚函数。
      - 构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用

19. 哪些函数不能是虚函数

    - 普通函数（非成员函数）：只能被重载，不能被重写。
    - 构造函数：执行初始化行为，而不是对象的动态行为。自动调用，而不是通过父类指针或引用去调用
    - 内联成员函数：编译时被展开，而虚函数是运行时动态绑定函数
    - 静态成员函数：属于一个类，而非某个对象，没有this指针，无法进行对象的判别
    - 友元函数：无法继承，所以没有虚函数的说法。

20. 虚函数表里存放的内容？什么时候写进去的？

    - 存储虚函数地址的数组，存放该类重写的及父类未被重写的所有虚函数入口地址。
    - [虚表写入时机](https://blog.csdn.net/weixin_43919932/article/details/104356460)：分配内存空间后，调用构造函数前。

21. 构造函数中能不能调用虚函数

    - 语法上讲：调用完全没有问题
    - 从效果上讲：不能达到多态的效果，
      - 因为派生类对象构造期间（父类构造函数在派生类构造之前调用），派生类还没完全创建，此时它当做一个父类对象，
      - 同样，进入基类析构函数时（子类析构函数在父类析构之前调用），对象也是基类类型。
    - 基类中声明纯虚函数并且在基类的析构函数中调用，编译器会报错。
      - 如果在**基类构造函数中调用虚函数**被解析成**调用派生类的虚函数**，而**派生类的虚函数中又访问到未初始化的派生类数据**，这是危险的，将会导致程序出现未知行为及bug。

22. 虚函数与纯虚函数的区别

    - 可以同时定义一个类中，都可以被重写，以多态的形式被调用。
    - 都不能被static修饰，因为被static修饰的函数在编译时静态绑定，然而虚函数是运行时动态绑定。
    - 含有纯虚函数的类被称为抽象类，只含有虚函数的类不能被称为抽象类；
    - 定义形态不同，虚函数可以直接被使用，因为在父类中有函数体，也可以被子类重写，以多态的形式调用。而纯虚函数必须在子类中实现，因为纯虚函数在父类中没有函数体。

23. 含有纯虚函数的类能实例化吗？它的派生类要必须重写纯虚函数吗？

    - 含有纯虚函数的类被称为抽象类，抽象类不能实例化对象。在底层，拥有虚函数都有一个vftable，纯虚函数的对应的函数入口地址为0，也就是指向一个不存在的函数，由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能实例化对象。
    - 抽象类的派生类必须重写所有纯虚函数，否则依然是一个抽象类，抽象类不能实例化对象。
    - 定义纯虚函数是为了实现一个接口，用来规范派生类的行为。

24. 抽象类

    - 抽象类：有**纯虚函数**的类
    - 纯虚函数：函数原型后加“=0”
    - 特点：
      - 抽象类只能用作其他类的基类，不能建立抽象类对象。
      - 抽象类不能用作函数的返回值类型，参数类型或显示转换的类型
      - 可以定义指向抽象类的指针和引用，指针可以指向它的派生类，继而实现多态

25. 类模板和模板类的区别

    - 类**模板**是一个模板的定义，**含有通用类型参数的类定义**，可以看作是做蛋糕的模具

    - 模板**类**：**类模板中通用类型具体化后的类**，可以看作是通过蛋糕模具做出来的蛋糕。

    - ```c++
      // 类模板
      template<class T1, class T2>
      class Data{}
      
      // 模板类
      Data<int, float>
      ```

    - 

26. 

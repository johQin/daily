# offer

# 1 C/C++

## 1.1 语言基础

1. C++语言特点

   - 继承C的面向过程，结构化语言，执行效率高（比汇编慢10%~20%）。
   - 面向对象：封装（结构清晰），继承（代码重用），多态（丰富扩展性，面向接口编程）。
   - 泛型编程：引入模板编程思想，在此基础上实现STL，实现算法和数据结构的分离，极大提高代码的可复用度，提高开发效率。
   - 更加安全易用，增加了引用，四个类型转换，try_catch异常类型机制
   - 发展的语言：lambda函数、右值引用，可变参数模板，智能指针等。

2. C和C++的特点

   - C++是C的超集，C++可以很好的兼容C，并且增加了许多新特性。
   - C++是面向对象的语言，而C面向过程
   - C++可复用性更高，引入泛型编程中的模板思想，在此基础上构建了STL，使C++相较于C更加灵活，更加通用
   - C++更安全，引用，智能指针，try_catch异常机制，cast转换。

3. C++中class与struct的区别

   - 使用场景：struct更多用于描述一个数据结构集合，而class是对一个对象数据的封装。
   - 本质区别是：访问控制
     - struct默认的访问权限是public，而class是private
     - struct默认的继承权限是public，而class是private
   - 泛型方面：struct不支持模板参数，而class可以。
   - 其余方面struct和class没什么大的区别:
     - class可以继承struct，struct也可以继承class，取决于继承者的类型
   - 

4. C++中的struct和C中的struct的区别

   - 声明时：

     |          | C                      | C++                      |
     | -------- | ---------------------- | ------------------------ |
     | 成员函数 | 不能有                 | 可以有                   |
     | 静态成员 | 不能有                 | 可以有                   |
     | 访问控制 | public，不可修改       | public/private/protected |
     | 继承关系 | 不可继承               | 可从其他类或结构体继承   |
     | 初始化   | 不能直接初始化数据成员 | 可以                     |

   - 初始化声明时：C中必须加上关键字struct，而C++中可以省略。

5. [include头文件中双引号""和尖括号<>的区别](https://blog.csdn.net/qq_27825451/article/details/102568482)

   - 头文件的文件类型：尖括号中的系统文件，双引号中的是自定义文件
   - 查找文件的路径顺序：
     - 双引号：
       1. 当前源文件所在的工作目录
       2. 编译器设置的头文件查找路径，编译器有默认的头文件查找路径。（当然也可以-**i**指定）
       3. 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径（vs，如果安装在C盘就在programfile x86下的Windows Kits\10\Source\10.0.22000.0\ucrt，如果在其他盘就在盘下的Windows Kits\10\Source\10.0.22000.0\ucrt）
     - 尖括号就在后两个路径上找

6. 在C++中导入C语言代码的关键字。

   - 关键字是extern，表达形式是extern "C"
   - 主要作用：为了实现C++代码调用其他C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言进行编译，而不是C++
   - 在函数方面，C编译器和C++编译器编译有所不同，由于C++支持函数重载，编译时函数名会加上参数的类型，而C不会。

7. 简述C++从代码到可执行的二进制文件的过程

   - C++和C语言类似，总过程：预处理（预编译，.i），编译（.s），汇编（.o），链接（.exe）
   - 预处理阶段：主要做宏处理，宏分四类：define宏定义，include宏，if条件编译宏，预定义宏
     - 处理宏定义展开
     - 处理所有条件编译宏
     - 处理include宏，将被包含的文件插入到预编译指令的位置
     - 处理预定义宏，添加行号，文件名，日期等。
     - 生成.i的临时文件
   - 编译阶段
     - 词法分析，语法分析，语义分析，代码优化，生成汇编代码，汇编代码优化
     - 生成.s临时文件
   - 汇编阶段
     - 将汇编代码转变为机器可以执行的指令。
     - 生成目标文件.o或.obj
   - 链接阶段
     - 将不同源文件产生的目标文件进行链接，从而形成可执行的程序。
     - 生成可执行文件（window为.exe，linux为.out)
     - 链接分为静态和动态链接：
       - 静态链接：将函数和数据编译成一个静态链接库文件（windows为.lib，linux为.a），在链接的时候，把需要调用的函数或过程嵌入链接到生成的可执行文件中，现在就算你把静态库删除也不会影响可执行程序的执行。
         - 静态库本身并不需要与可执行文件一起发行。
       - 动态链接：将函数和数据编译成生成动态链接库文件（windows为.dll，linux为.so），在链接的时候，并没有把调用的函数和过程嵌入链接进入可执行文件中，只包含函数的重定位信息。所以当你删除动态链接库的时候，可执行程序就不能运行。

8. 关键字static的作用

   - 静态局部变量和静态全局变量，
     - 静态全局变量：
     - 静态局部变量：在编译时分配内存并赋初值（之后不再赋初值），函数调用后，内存不释放
   - 静态函数
   - 静态变量和静态函数都被限制在本文件中。
   - 在C++的类中，被用于定义静态成员（变量和函数），
     - 静态成员只有一份拷贝，为所有对象共享
     - this指针无法引用

9. [指针和数组的区别](https://blog.csdn.net/qq_36992917/article/details/79238874)

   - |          | 数组                                               | 指针                       |
     | -------- | -------------------------------------------------- | -------------------------- |
     | 访问效率 | 直接访问，效率高                                   | 间接访问，效率低           |
     | 字节大小 | 不固定，数组类型和元素个数决定                     | 固定，由操作系统的字长决定 |
     | 标识符   | 指针常量，不可以使用自增++                         | 指针变量，可以使用自增++   |
     | 内存空间 | 存储的是一系列数值，对应的空间大小不可变，内容可变 | 存储的是地址               |
     | 赋值     | 遍历数组进行赋值                                   | 同类型指针变量可以相互赋值 |

   - 数组对应一块内存区域，地址和容量在其生命周期不会改变，其内容可变。而指针指向一块内存区域，指向的区域地址和大小可变。

10. 函数指针

    - 概念：指向函数的指针，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址

    - 定义：

      ```c
      int func(){}
      int (*f)();
      f= &func;
      ```

    - 应用场景：做回调函数。

11. [静态变量初始化时机](https://blog.csdn.net/u011723812/article/details/78151533)

    - 全局变量，文件域的静态变量和类的静态成员变量，在main执行之前，分配内存并初始化（编译期初始化）
    - 局部静态变量在第一次使用时分配内存并初始化。
    - 初始化线程安全性：非局部静态变量线程安全。而局部静态变量线程不安全（编译器的实现是通过一个标识，来标定这个局部静态变量是否初始化），而在支持C++11标准的编译环境下，它是线程安全的。
    - 全局或静态对象当且仅当对象首次用到时才进行构造

12. 用nullptr初始化类的对象，可不可以调用类的成员函数

    - nullptr可以调用成员函数，因为成员函数在编译对象时，就已经绑定了函数地址，和指针空不空没有关系

    - ```c++
      class animal{
      	public:
      		void sleep(){ cout << "animal sleep" << endl; }
      		void breathe(){ cout << "animal breathe haha" << endl; }
      };
      class fish :public animal{
      	public:
      		void breathe(){ cout << "fish bubble" << endl; }
      };
      int main(){
      	animal *pAn=nullptr;
      	pAn->breathe(); // 输出：animal breathe haha
      	fish *pFish = nullptr;
      	pFish->breathe(); // 输出：fish bubble
      }
      ```

13. [野指针](https://blog.csdn.net/qq_40927789/article/details/80686723)

    - 没有初始化的指针，指针指向的位置不可知。

    - 悬垂指针：指向已经释放内存区域的指针

    - 危害：

      - 指向一个不可访问的空间
      - 指向一个没有明确意义的空间，在这种情况下， 程序是正确的，可以正常运行，然而事实上是有问题存在，掩盖了程序上的错误
      - 指向一个可用，并且正在被使用的空间，如果我们用这样的指针对所指空间进行了修改，这个修改对程序的运行大概率会有影响，进而导致程序崩溃，或数据被损坏

    - 避免方法:

      - 初始化置NULL

      - 申请内存后判空

      - 内存释放后指针置空

      - 使用智能指针

      - ```c
        int *p = NULL; //初始化置NULL
        
        p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间
        assert(p != NULL); //判空，防错设计
        
        p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
        free(p);
        p = NULL; //释放后置空
        ```

14. 静态局部变量，静态全局变量，全局变量，局部变量的区别。

    - 作用域：
      - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件
      - 静态全局变量：文件作用域
      - 局部变量：局部作用域
      - 静态局部变量：局部作用域，只初始化一次，直到程序结束
    - 所在空间
      - 除局部变量在栈区（动态存储区），其他都在静态存储区。
    - 生命周期
      - 由于局部变量在栈上，出了作用域就回收存储，而其他都在静态存储区上，知道程序结束才回收内存。

15. 内联函数和宏函数的区别

    - 内联函数：广义的来说，定义时被inline修饰的函数。一般用于比较小而简单的，频繁调用的函数。
    - 宏函数：通过define定义的标识符，带参数的宏
    - 相同点：
      - 宏函数和内联函数都会在适当位置进行展开，都是以代码膨胀为代价，避免函数调用开销。
    - 区别：
      - 性质：宏函数不是函数（只是像，但不是），而内联函数是函数。
      - 处理阶段：宏函数在预处理阶段，而内联函数在编译阶段
      - 参数方面：宏函数没有类型检查（只进行简单的字符串替换），而内联函数会进行类型检查。

16. 内联函数和函数的区别

    - 定义需要inline修饰
    - 内联函数没有函数调用开销
    - 内联函数无需寻址（代码在调用处展开）
    - 选择：调用开销、执行函数体时间、代码量，三个维度来决定函数是内联还是普通

17. 运算符`i++和++i`的区别

    - 赋值顺序不同，
    - 效率不同：后置++比前置++效率低，后置`++`要多生成一个局部对象 tmp，因此执行速度比前置的慢。
    - i++不能作为左值，而++i可以
    - 二者都不是原子操作。

18. new和malloc的区别，各自底层实现原理

    - 区别：

      |      | new                                                          | malloc                                     |
      | ---- | ------------------------------------------------------------ | ------------------------------------------ |
      | 类型 | 操作符                                                       | 函数                                       |
      | 重载 | 可重载                                                       | 不可重载                                   |
      | 异常 | 发生错误，抛异常，分配内存更直接更安全，                     | 返回NULL                                   |
      | 构造 | **new** 和 **delete** 分别是 **开空间+构造函数**、**析构函数+释放空间** | 开空间和释放空间                           |
      |      | 会调用构造函数，无需指定内存大小，指针无需强转               | 需要给定申请的内存大小，返回的指针需要强转 |

    - [malloc底层实现](https://blog.csdn.net/Allelujah123/article/details/123874128)

      - https://blog.csdn.net/weixin_43340455/article/details/124570759
      - malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表为每一个空闲块记录了一个未分配的、连续的内存地址。

    - new底层实现

      - 创建一个新的对象
      - 将构造函数的作用域赋值给这个新的对象
      - 执行构造函数的代码
      - 返回新对象

19. [const详解](https://blog.csdn.net/qq_40337086/article/details/125519833)

    - [const 修饰变量](https://blog.csdn.net/weiyuanzhang123/article/details/117592035)：**const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。**
      - const int * ：`(const int) *`——指针指向一个整型常量，不可改变指针指向的内容，但指针本身可以改变
      - int const *：`(int const) *`——同上
      - int * const：`int (* const)`——指针常量指向一个整型变量，可改变指针指向的内容，但指针本身不可改变
      - const int * const：`(const int) (* const) `——指针常量指向整型常量
      - int const *const：`(int const) (* const)`
    - 

20. C++有几种传值方式

    - 值传递：改变形参的值，不会改变实参的值
    - 引用传递：改变形参的值，会改变实参的值
    - 指针传递：如果指针的指向没有改变，改变形参的值，会影响实参的值

21. 使用指针的注意

    - 防止野指针：
      - 定义指针变量时，初始化为NULL
      - 申请内存后，判空
      - 释放内存后，置为NULL
    - 动态内存申请和释放必须配对，防止内存泄漏
    - 避免指针越界

22. 常量定义：const和define 

    - 生效阶段：const在编译阶段，define在预处理阶段
    - 内存占用：const定义的变量需要占用内存空间，define运行时时直接的操作数
    - 类型：const定义的变量时有类型的，而define无

23. 



## 1.2 C++内存

1. [堆和栈的区别](https://blog.csdn.net/mynameisJW/article/details/105150558)
   - 管理方式：栈由操作系统自动分配和释放，堆的分配释放由开发者控制，容易产生内存泄漏。
   - 空间大小：每个进程拥有的栈空间要远远小于堆的大小，64bits windows默认栈是1M，64bits linux默认10M，而可申请的堆理论大小是虚拟内存的大小
   - 生长方向：堆生长方向向上，内存地址由低到高，栈的生长方向向下，内存地址由高到低。
   - 分配方式：
     - 堆只能动态分配，栈动态和静态分配都有。
     - 静态分配是由操作系统完成的，比如局部变量的分配。
     - 堆的动态分配由malloc或new函数进行分配，须手动free和delete。栈的动态分配不同于堆，**栈中动态分配内存**的函数`alloca`，用法与malloc，但不用free，由操作系统自动释放。
   - 分配效率：
     - 栈由操作系统自动分配，会在硬件层级对栈提供支持：提供专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，效率高
     - 堆则由C/C++提供库函数或运算符来完成管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片，效率低。
   - 存放内容:
     - 栈存放函数变量、参数、地址、寄存器内容
     - 堆一般存放对象，具体内容由开发者填充
   - 生命周期：栈短堆长，栈中存储的数据随函数执行完成而结束，系统自动释放空间。而堆如果不手动释放，其生命周期等同进程生命周期
   - 数据结构：栈是一种线性数据结构，遵守FILO的规则，而堆是一种非线性的完全二叉树
2. [C++内存管理](https://blog.csdn.net/weixin_41055260/article/details/118981630?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-118981630-blog-124414552.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3)
   - 内存管理（分配方式）机制：分为5个区，栈区，堆区，自由存储区，静态存储区，常量区，代码区。
     - 栈区：存放函数内的局部存储单元
     - 堆区：由new分配的内存块，需要delete释放
     - 自由存储区：由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。（在C里面，这就是堆）
     - 静态存储区：存放全局，静态变量
     - 常量存储区：存储的是常量，不允许修改
     - 代码区：存放可执行的机器码
   - 内存泄漏机制：
     - 内存泄漏：程序在申请内存后，无法释放已申请的空间，占用有用内存，最终导致内存溢出。
     - 泄漏分为两类：
       - 堆内存泄漏：堆上申请资源后，使用结束后，未释放
       - 资源泄漏：通常指系统资源，比如socket，文件描述符等。因为这些在系统中都是有限的，创建而不释放，系统资源会耗尽
     - 产生方式分类：
       - 常发性内存泄漏：每执行一次，就会造成一次泄漏
       - 偶发性内存泄漏：特定场景下执行，就会一次泄漏
       - 一次性内存泄漏：造成泄漏的代码只会被执行一次。
       - 隐式内存泄漏：不停分配内存。
     - 泄漏的场景：
       - new和malloc申请资源使用后，没有用delete和free释放；
       - 子类继承父类时，父类析构函数不是虚函数。
       - Windows句柄资源使用后没有释放。
     - 怎么检测（避免）内存泄漏：
       - 申请和释放一定要成对存在
       - 分配的内存的指针以链表形式管理，使用完成后从链表中删除，程序结束时检查链表中的指针是否都得到了释放。
       - 使用智能指针
       - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
   - 内存回收机制
     - 垃圾回收技术所解决只有两个问题：
       - 如何识别当前内存中未被引用的内存块
       - 如何将失去管理的内存进行回收
     - 引用计数：除内存块外增加一个引用计数，当内存块被引用，计数加1，当内存块失去引用，计数减1，同时检查引用计数，如果为0，就销毁释放内存
     - 标记清除：垃圾回收器扫描所有内存块，将被引用的内存块进行标记，标记完成后，统一检测内存，将所有未被标记的内存块回收
   - 
3. [内存对齐](https://blog.csdn.net/qq_39397165/article/details/119745975)
   - 由于CPU对内存的访问不是随机的，而是在特定地址或字长的整数位置访问内存，所以对数据的存储要按照一定的空间规则，使CPU对一个数据单元访问的次数尽量小，这就是内存对齐。
4. C++程序启动过程
   - 操作系统首先创建相应的进程并分配私有的进程空间，操作系统的加载器负责把可执行文件的数据段和代码段映射到进程虚拟内存空间。
   - 加载器读入可执行程序的导入符号表，根据这些符号可以查找出该可执行程序的所有依赖的动态链接库。
   - 加载器针对该进程的每个动态链接库，调用LoadLibrary
     - 查找动态库文件，读入动态链接库，调用动态链接库初始化应用程序的函数
   - 初始化应用程序的全局变量，对于全局对象自动调用构造函数
   - 进入应用程序入口点函数开始执行
5. 

## 1.3 面向对象

1. 三大特征：

   - 封装：将数据和操作数据的方法进行有机结合，加以权限区分，隐藏对象的属性和实现细节，仅对外公开来和对象进行交互。
   - 继承：利用已有类定义新类，新类可以使用和扩展已有类的功能。
     - 三种继承方式：public，private，protected（父类成员权限被继承方式限制）
     - 构造函数，析构函数，operator=，都不能继承（子类不会复制父类的函数，类的函数，只有一份，为所有对象共享，包括子类对象），对象的空间计算包含：对象的父类和本身的非静态属性。
   - 多态：
     - **同一类型的多个实例，在执行同一方法时，呈现出多种行为特征——多态**
     - 静态多态（编译时多态）：重载，重定义（子类重新定义父类的非虚函数，覆盖）
     - 动态多态（运行时多态）：重写（子类重写父类虚函数）
       - 协变（子替代父）是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。
       - 不变（两个毫不相关的类，不能相互替代），协变（子替代父），逆变（父替代子）
   - 

2. C++的重载和重写

   - 重载：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。（返回值类型不同不能作为重载的条件）
     - 采用命名倾轧技术，重载函数在编译时，会将参数类型的首字母作为函数名的一部分，以此来区分重载的多个函数。
   - 重写：子类重写父类的虚函数，返回值类型、函数名，参数顺序，个数，类型都必须一致。
     - 在基类的函数前加virtual修饰，在子类中重写该函数，运行时将会根据对象的实际类型调用相应的函数
     - 采用虚函数动态绑定原理，
       - 当声明父类一个函数为虚函数时，就会为这个类声明一个虚函数指针vfptr，这个指针指向一个虚函数表vftable，表里记录这虚函数的入口地址。
       - 当子类继承父类时，会继承这个vfptr和vftable，当子类重写了父类虚函数的同时，通过vfptr找到vftable，修改这个函数对应的入口地址为子类的函数地址。
       - 当父类指针指向子类的空间时，本质上还是调用父类的那个函数，当调用父类的那个函数时，发现此函数是一个虚函数指针，通过这个指针找到这个vftable，从而找到子类函数的入口地址，间接调用了子类函数
   - 重定义：子类重定义父类的同名函数（非虚），参数的顺序，个数，类型可以不同。

3. C实现函数重载

   - C不允许函数同名，因为编译时，同名函数名都是一样的

   - 采用函数指针，将一个函数的一个参数类型定义为函数指针，其他参数为这个函数指针的参数

   - 使用可变参数函数（stdarg.h，val_list类型和三个宏函数va_start，va_arg，va_end）

   - [gcc内置函数](https://www.it1352.com/1987845.html)可以实现函数重载

   - ```c++
     // 函数指针实现函数重载
     #include<stdio.h>
     
     typedef void (*ptr)(void *); //typedef申明一个函数指针
     
     void func_int(void * a){
     	printf("%d\n",*(int*)a); //输出int类型，注意 void * 转化为int
     }
     void func_double(void * b){
     	printf("%.2f\n",*(double*)b);
     }
     
     void c_func(ptr p,void *param){
     	p(param); //调用对应函数
     }
     
     int main(){
     	int a = 23;
     	double b = 23.23;
     	c_func(func_int,&a);
     	c_func(func_double,&b);
     	return 0;
     }
     
     // 可变参数实现函数重载
     #include<stdarg.h>
     int fun(int n, ...){
         //1. 在函数中创建一个va_list类型的变量
         val_list ap;
         //2. 初始化一个参数列表
         va_start(ap,n);
     //    for(int i = 0;i < n; i++){
     		//3.访问参数列表的内容
         	va_arg(ap,int);
     //    }
     	//4. 清理
         va_end(ap);
     };
     ```

   - 

4. 仿函数

   - 重载了operator()的类，其对象称为函数对象，是行为类似函数的对象，也叫仿函数
   - 它是一个类的实例，而不是函数。
   - 超出普通函数概念，可以拥有自己的状态。
   - 模板函数使得函数对象的通用型更好，这也是它的优点之一。

5. 类方法和数据的权限

   - public：类的实例可以**直接访问**
   - protected：允许本类及子类的**成员函数可以访问**
   - private：允许本类的成员函数可以访问。

6. 派生类的继承方式（权限）影响对父类成员的访问。

   - 继承方式（权限）会限制父类成员的访问权限，继承权限大的不会影响访问权限小的父类成员，继承权限小的会缩小访问权限大的父类成员至继承权限。

7. 构造函数的种类

   - 默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数，转换构造函数。

   - 默认构造函数（无参构造）和初始化构造函数（有参构造）

     - 在定义对象时，完成对象的初始化工作，
     - 定义了有参构造，编译器不再提供无参构造

   - 拷贝构造函数

     - 完成对是整个对象的拷贝，旧对象和复制构造的对象各自占有不同的同样大小的堆内存。
     - 拷贝构造的形参是一个左值引用。

     - 三种情况被调用：
       - **旧对象初始化（构造）新对象**，记得是初始化，而不是赋值（=），如果等号的左边是一个已定义的对象，那么就不会发生拷贝构造
       - 函数的参数是对象，而非对象的引用。在调用函数的时候，会发生拷贝构造
       - 函数的返回值是对象，而非对象的引用。在调用函数并执行返回的时候，会发生拷贝构造。所以**引用可以大大减小拷贝构造开销**

   - 移动构造函数：**右值（临时（匿名）对象、不可寻址的字面常量）初始化新对象时**（C++11）

     - 生成一个指针指向源对象地址，接管源对象的内存。
     - 移动构造的形参是一个右值引用。

   - 转换构造函数：

     - 通过利用单参数的构造函数（转换构造）可以隐式转换其他对象为本构造对象，再配合相应的运算符重载，完成相关运算。
     - 类型转换函数：将本对象隐式转换为其他类型对象，完成相应的计算。

8. 拷贝和移动的区别

   - 形参：拷贝是左值引用，移动是右值引用
   - 拷贝是对整个对象的拷贝，移动是生成一个指针指向源对象的地址，接管源对象。

9. 拷贝构造参数是什么传递方式，为什么

   - 引用传递方式
   - 如果是传值，传值的方式会调用该类的拷贝构造，从而造成无穷递归调用拷贝构造

10. 空类默认有哪些函数

    - 默认构造，拷贝构造，重载赋值，析构

11. 多重继承下的构造和析构

    - 父类构造函数–>成员类对象构造函数–>自身构造函数
    - 其中成员变量的构造与在当前类声明顺序有关，父类构造函数的调用顺序是当前子类继承列表中的顺序。（与当前子类初始化列表顺序无关）
    - 析构顺序和构造顺序相反。

12. 类型转换

    - 上下行转换：
      - 上行转换：父类指针指向子类空间，不会造成内存越界，安全
      - 下行转换：子类指针指向父类空间，可能会造成内存越界，不安全
    - C++提供四种类型转换
      - static_cast：用于基类与派生类之间的指针或引用转换
      - dynamic_cast：用于类层次的上行转换
      - const_cast：用于将const修饰和非const修饰的对象之间的转换
      - reinterpret_cast：重新解释类型转换（可用于无关类之间的转换）

13. 深拷贝和浅拷贝

    - 浅拷贝：将原对象的引用直接赋值给新对象，新对象只是原对象的一个引用
    - 深拷贝：开辟一个和原对象一样的空间，创建一个新的对象，把原对象属性的“值”拷贝一份，是值而不是引用。（如果这个值是对象，那就还需迭代开辟空间）

14. 常函数

    - 类的成员函数后边被const修饰，被称作常函数。
    - 常函数体内不可修改对象中任何非静态成员变量，但是可以修改静态成员变量和mutable修饰的成员变量。
    - 常量（即 const修饰的）类的实例对象可以调用const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样。

15. 菱形继承

    - 孙子类的多个父类有共同的祖先
    - 孙子类及其派生类会拥有多份公共的数据，当孙子类及其派生类访问这份公共数据时，出现二义性，而出错

16. 虚继承

    - 在继承方式前加virtual修饰，子类虚继承父类，子类只会保存一份公共数据。
    - 虚继承解决 菱形继承中，多份公共祖先数据的问题。

17. 多态

    - 同一个类型的不同实例，在执行同一方法时，呈现出多种行为特征。
    - 除了虚函数（动态多态，运行时）可以实现多态， 还有函数重载（静态多态，编译时）可以实现多态

18. 为什么要虚析构，而不能虚构造

    - 虚析构：
      - 虚析构：析构函数被virtual修饰
      - 通过父类指针 释放整个子类空间，防止内存泄漏。原理：vfptr，通过vftable，找到虚析构函数，而这个析构函数实际指的是子类的析构函数，子类析构之后，会自动调父类的析构函数。
    - 虚构造
      - 从功能上说：虚函数是用来实现多态的，也就是对象的动态行为，而构造函数的作用是提供初始化，在对象的生命周期只执行一次，不是对象的动态行为，没有必要称为虚函数。
      - 构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用

19. 哪些函数不能是虚函数

    - 普通函数（非成员函数）：只能被重载，不能被重写。
    - 构造函数：执行初始化行为，而不是对象的动态行为。自动调用，而不是通过父类指针或引用去调用
    - 内联成员函数：编译时被展开，而虚函数是运行时动态绑定函数
    - 静态成员函数：属于一个类，而非某个对象，没有this指针，无法进行对象的判别
    - 友元函数：无法继承，所以没有虚函数的说法。

20. 虚函数表里存放的内容？什么时候写进去的？

    - 存储虚函数地址的数组，存放该类重写的及父类未被重写的所有虚函数入口地址。
    - [虚表写入时机](https://blog.csdn.net/weixin_43919932/article/details/104356460)：分配内存空间后，调用构造函数前。

21. 构造函数中能不能调用虚函数

    - 语法上讲：调用完全没有问题
    - 从效果上讲：不能达到多态的效果，
      - 因为派生类对象构造期间（父类构造函数在派生类构造之前调用），派生类还没完全创建，此时它当做一个父类对象，
      - 同样，进入基类析构函数时（子类析构函数在父类析构之前调用），对象也是基类类型。
    - 基类中声明纯虚函数并且在基类的析构函数中调用，编译器会报错。
      - 如果在**基类构造函数中调用虚函数**被解析成**调用派生类的虚函数**，而**派生类的虚函数中又访问到未初始化的派生类数据**，这是危险的，将会导致程序出现未知行为及bug。

22. 虚函数与纯虚函数的区别

    - 可以同时定义一个类中，都可以被重写，以多态的形式被调用。
    - 都不能被static修饰，因为被static修饰的函数在编译时静态绑定，然而虚函数是运行时动态绑定。
    - 含有纯虚函数的类被称为抽象类，只含有虚函数的类不能被称为抽象类；
    - 虚函数在基类中已定义，而纯虚函数在基类中仅仅只声明。虚函数可以直接被使用，因为在父类中有函数体，也可以被子类重写，以多态的形式调用。而纯虚函数必须在子类中实现，因为纯虚函数在父类中没有函数体。

23. 虚函数与纯虚函数

    - 虚函数的作用主要为了实现多态。
    - 纯虚函数的作用主要是为了实现一个接口，用来规范派生类的行为。

24. 含有纯虚函数的类能实例化吗？它的派生类要必须重写纯虚函数吗？

    - 含有纯虚函数的类被称为抽象类，抽象类不能实例化对象。在底层，拥有虚函数都有一个vftable，纯虚函数的对应的函数入口地址为0，也就是指向一个不存在的函数，由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能实例化对象。
    - 抽象类的派生类必须重写所有纯虚函数，否则依然是一个抽象类，抽象类不能实例化对象。
    - 定义纯虚函数是为了实现一个接口，用来规范派生类的行为。

25. 抽象类

    - 抽象类：有**纯虚函数**的类
    - 纯虚函数：函数原型后加“=0”
    - 特点：
      - 抽象类只能用作其他类的基类，不能建立抽象类对象。
      - 抽象类不能用作函数的返回值类型，参数类型或显示转换的类型
      - 可以定义指向抽象类的指针和引用，指针可以指向它的派生类，继而实现多态

26. 类模板和模板类的区别

    - 类**模板**是一个模板的定义，**含有通用类型参数的类定义**，可以看作是做蛋糕的模具

    - 模板**类**：**类模板中通用类型具体化后的类**，可以看作是通过蛋糕模具做出来的蛋糕。

    - ```c++
      // 类模板
      template<class T1, class T2>
      class Data{}
      
      // 模板类
      Data<int, float>
      ```

27. 函数模板

    - 会编译两次：在编译时编译，在调用处类型具体化后的编译
    - 每使用一次函数模板（模板的类型不同的话），都会产生一个新的函数空间

28. 

## 1.4 STL

1. STL基本组成部分

   - 广义上来讲分三类：容器，迭代器，算法，容器和算法之间通过迭代器进行无缝衔接。

   - 详细来说有六类：容器，迭代器，算法，仿函数，适配器，空间配置器
   - 容器（container）：是一种数据结构，用来存放对象的模板类，为了访问容器内的数据，可以通过容器类提供的迭代器
   - 算法（algorithm）：操作容器中数据的模板函数，函数本身与操作的数据的结构和类型无关。
   - 迭代器（iterator）：提供访问容器中对象的方法。事实上，指针也是一种迭代器，迭代器也可以是那些定义了operator*()以及其他重载了指针的操作符方法的类对象;
   - 仿函数（functor）：又称函数对象，重载了"operator()"的类，它是一个类，不是一个函数，可以拥有自己的状态
   - 适配器（adapter）：简单来说是一个接口类，专门用来修改现有类的接口，提供一种新的接口，或调用现有函数来实现某种功能。主要包含三类：容器适配器，迭代器适配器，函数适配器。
   - 空间配置器（allocator）：为STL提供空间控制系统，主要包括两部分：对象的创建和销毁，内存的获取与释放

2. STL中常见的容器

   - 分为三类：顺序容器，关联式容器，容器适配器
   - 顺序容器
     - 容器并非排序的，元素插入位置同元素值无关。包含vector，deque，list
     - vector：单端动态数组，内存连续，存取常数时间，在尾端增删元素具有较佳性能
     - deque：双向队列。内存连续，存取常数时间（仅次于vector），在两端增删元素具有较佳性能
     - list：双向链表，内存不连续。任何位置增删常数时间。不支持随机存取。
       - 还有forward_list——单向链表，链表中的节点只能向后搜索，支持前向迭代器。
   - 关联性容器
     - 有序关联：set、multiset、map、multimap，支持双向迭代器
       - 元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；查找性能高；通常以**平衡二叉树（红黑树）**的方式实现。
     - 无序关联：unordered_set/unordered_multiset，unordered_map/unordered_multimap，支持前向迭代器，
       - 元素无序，按**哈希表**存放，查找速度比有序关联的快。
   - 容器适配器（不支持迭代器）：封装了一些基本的容器，底层可能是序列容器或者链表。
     - stack：默认的底层容器是deque，FILO
     - queue：默认的底层容器是deque，FIFO
     - priority_queue：内部元素按照有序堆（大顶堆降序、小顶堆升序）进行存放，按优先级执行，高级先出，同级才FIFO

3. STL中map、hashtable、deque、list的实现原理

   - map：红黑树（非严格平衡二叉搜索树）
     - map内部实现了红黑树，它有自动排序功能，树的每个节点都代表map的一个元素，因此对map的增删查等操作就是对红黑树的操作。由于map中的元素是按照二叉树存储的，所有左子树的所有节点都比根节点小，右子树都比所有根节点大，使用树的中序遍历，可将键值按照从小到达遍历出来。
   - unordered_map：hashtable，散列表
     - 采用函数映射思想将元素的存储位置和元素的关键字联系起来，它能快速的定位到想要查找的元素，而不是依靠元素的关键字进行比较来进行查找
   - deque：双向队列
     - 内部实现了一个双向队列，元素在内存连续存放，随机存取常数时间，两端增删性能较优
   - list：双线链表
     - 内部实现的是一个双向链表，内存不连续，任意位置增删常数时间，不支持随机存取，访问第i个元素都需从头挨个遍历到第i

4. 介绍一下STL空间配置器

   - 程序包括数据结构和算法，而数据结构作为存储数据的组织形式，与内存分配有着密切的联系，在C++ STL中，空间配置器便是用来实现内存空间分配的工具。每一种空间的分配都是通过空间配置器来实现。
   - 空间配置器没有简单采用new和delete的方式，而是采用了一个高效的方式。
   - 首先把对象构造始末分成了空间配置和对象构造两部分，
     - 空间配置：内存配置allocator，内存释放deallocator
     - 对象构造：构造construct，释放destroy
   - 对于内存空间的配置，SGI STL采用类两级结构：
     - 一级空间配置器：管理大块内存
       - 对malloc和free进行了封装，同时增加了申请空间失败抛出异常机制
       - 主要作用：向操作系统申请内存，申请失败抛异常
     - 二级空间配置器：管理小块内存
       - 采用内存池来提高申请空间速度和减少额外空间的浪费，在内存池内右采用哈希桶来提高获取空间的速度和高效管理（但增加了内存碎片），也有在内存池内采取链表的形式来管理，可是获取空间的速度不高。

5. 各种容器的时间复杂度

   |      | vector<br />（单端数组） | deque<br />(双向队列) | list<br />（双向链表） | map/multi~<br />set/multi~<br />（红黑树） | unordered_map/~_multimap<br />unordered_set/~_multiset<br />（散列表） |
   | ---- | ------------------------ | --------------------- | ---------------------- | ------------------------------------------ | ------------------------------------------------------------ |
   | 插入 | O(N)                     | O(N)                  | O(1)                   | O(logN)                                    | O(1)，最坏O(N)                                               |
   | 查看 | O(1)                     | O(1)                  | O(N)                   | O(logN)                                    | O(1)，最坏O(N)                                               |
   | 删除 | O(N)                     | O(N)                  | O(1)                   | O(logN)                                    | O(1)，最坏O(N)                                               |

6. 迭代器什么时候失效（STL怎么删除元素）

   - 对于顺序容器的vector、deque来说，使用erase后，后面每个元素的迭代器都会失效，后面每一个元素都会往前移动一位。erase返回下一个有效迭代器。
   - 对于关联容器map、set来说，使用了erase后，当前元素的迭代器会失效，但其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调erase方法之前，记录下一个元素的迭代器即可
   - 对于list来说，它使用了不连续的内存，并且erase会返回下一个有效的迭代器，因此上面两种方式都可用。

7. 迭代器的作用，有指针为什么还要迭代器

   - 用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
   - 作用：
     - 用于指向顺序容器和关联容器中的元素
     - 通过迭代器可以读取它指向的元素
     - 通过非const迭代器还可以修改其指向的元素
   - 迭代器不是指针，是类模板，表现的像指针，他只是模拟了指针的一些功能，重载了指针的一些操作符。本质是封装了原生指针。
   - 迭代器返回的是对象的引用而不是对象的值。

   ```c++
   int main() {
   	vector<int> v; //一个存放int元素的数组，一开始里面没有元素
   	v.push_back(1);
   	v.push_back(2);
       v.push_back(3);
       v.push_back(4);
   	vector<int>::const_iterator i; //常量迭代器
   	for (i = v.begin(); i != v.end(); ++i){ //v.begin()表示v第一个元素迭代器指针，++i指向下一个元素
           cout << *i << ","; //*i表示迭代器指向的元素
           cout << endl;
       }
   	vector<int>::reverse_iterator r; //反向迭代器
       for (r = v.rbegin(); r != v.rend(); r++){
           cout << *r << ",";
           cout << endl;
       }
       vector<int>::iterator j; //非常量迭代器
       for (j = v.begin();j != v.end();j++){
       	*j = 100;
       }
       for (i = v.begin();i != v.end();i++){
       	cout << *i << ",";
       }
   return 0;
   }
   /*
   运行结果：
   1,2,3,4,
   4,3,2,1,
   100,100,100,100,
   */
   ```

8. 迭代器分类

   - 输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器
   - 容器支持情况：
     - vector，deque：随机访问迭代器
     - list，map，multimap，set，multiset：双向迭代器
     - forward_list，unordered_map，~set，~multimap，~multiset：前向迭代器
     - stack，queue，priority_queque：不支持迭代器

9. STL 中resize和reserve的区别

   - size和capacity
     - size：容器中元素的个数
     - capacity：容器的容量，拥有capacity属性的容器只有vector和string。
   - resize
     - resize(num)：重新指定容器size为num，容器原有个数大于num直接截断，容器原有个数小于num，增加新位置并以默认值填充新位置
     - resize(num)的作用：size变成指定的num，capacity视情况变化，
       - num<capacity，capacity不变
       - num>capacity，capacity变得大于等于num
   - reserve
     - 预留容器空间
     - reserve(num1)的作用：不改变size，capacity视情况变化，
       - num1>size，capacity置为num1
       - num1<size，capacity不变

10. STL 动态链接可能产生的问题

    - 给动态库函数传递容器对象本身，可能会出现内存堆栈破坏的问题
    - 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。

11. map和unordered_map的区别，底层实现

    - map元素排列有序，unordered_map无序，归根结底是底层实现不同。
    - map内部实现了一个红黑树，红黑树有自动排序功能
    - unordered实现了一个hash表，采用函数映射思想将元素的存储位置和元素的关键字联系起来

12. vector和list区别，应用场景

    - vector：是一个单端动态数组，内存连续，支持随机存取，插入删除数据和扩容开辟空间比较麻烦，适用于高效访问的场景。
    - lsit：是一个双向链表，内存不连续，支持任意位置插入删除，适用于高效插入和删除的场景

13. vector实现原理

    - 底层实现原理为一维数组，内存连续
    - 新增时：
      - 如果数组已满，则需要另辟更大的空间，复制原数据，然后再新增和插入
      - 在尾端新增，很简单
      - 通过迭代器在中间插入数据，需要当前迭代器后面的所有元素向后移动一位，腾开一个位置给这个新插入的数据
    - 删除时：
      - 在尾端删除pop_back很简单
      - 通过迭代器在中间删除，当前迭代器后面的所有元素向前移动一位，尾端多出的空间空闲在那，不释放。

14. push_back和emplace_back的区别

    - 传匿名对象或旧对象时，二者效率相同，会先调构造，再调移动构造
    - 传单构造参数时，emplace_back效率高，都会调构造，但emplace_back不会调用移动构造

15. 

## 1.5 新特性

1. c++11新特性

   - 统一初始化形式，还提供了模板类initializer_list
   - 成员变量默认初始化：构建一个类的对象不需要用构造函数初始化成员变量。
   - auto关键字：用于定义变量，编译器可以自动判断的类型，定义时必须初始化，否则无法推导类型
   - decltype(exp)：根据exp表达式来推导类型，定义时可不必初始化，因为变量的类型和左值右值没有关系，类型由exp决定。
   - 智能指针：shared_ptr，weak_ptr（配合shared_ptr解决循环引用的问题），unique_ptr
   - 空指针nullptr：nullptr_t类型的右值常量，专用于初始化空类型指针。依据nullptr 我们也可以创建属于自己的空指针对象
   - 右值引用和move语义 让程序员有意识减少进行深拷贝操作
   - 增加stl模板类：无序关联容器unordered_map/~multimap，~set/~multiset
   - 正则表达式，实质是一个字符串，该字符串描述了一种特定模式的字符串
   - Lambda表达式：最简：`[捕获上下文列表](参数列表){函数体}`，底层实现是一个匿名对象。
   - 可变参数模板

   ```c++
   // 统一初始化形式
   int a{1};//等价int a(1);，等价int a=1;
   int b{2+2};
   	//c++11后
   Student stu{ 1,85.5f,"qqq" };//结构体
   Data d{1,1.2};//自定义对象
   
   // 成员变量默认初始化
   class Data {
   public:
   	int a = 1;
   };
   
   // auto
   auto var = 55; 
   vector< vector<int> >::iterator i = v.begin();// 类型太长时，可以不用写，用auto代替
   auto i = v.begin();
   
   // decltype
   decltype<1+1> a;
   a = 100;
   sizeof(decltype(1+1.5));
   ```

   

2. 

# 2 操作系统

1. 常用的linux命令

   - 文件权限：chmod
   - 文件与目录管理：
     - 目录：cd/pwd
     - 文件：touch/rm/mv/cp
   - 文件压缩与备份：
     - 压缩：tar/gzip/zip
     - 备份：dump/restore
   - 用户管理：
     - su/useradd/userdel/usermod
   - 例行工作：
     - 突发性：at
     - 例行性：crontab/anacron(任务补漏)
   - 程序管理：
     - 工作管理：jobs(查看后台工作情况)/fg/bg/nohup(脱机管理)
     - 进程管理：ps(当前进程情况)/top(持续检测)/kill/free(资源查看)
   - 服务管理
     - stand alone：service
     - super daemon：xinted
   - 软件安装：
     - yum/apt-get

2. 文件权限修改chmod

   - `chmod nnn file_name`

3. 如何以root权限运行某程序

   ```bash
   sudo chown root filename
   sudo chmod u+s filename # 就是给某个程序的所有者以suid权限,可以像root用户一样操作。
   ./filename
   ```

## 内存管理

1. 软连接和硬链接

   - 文件系统将文件数据分为两个部分：文件权限和属性、文件内容
   - 文件权限和属性，存放在inode中，文件内容存放在data block中，inode有指向datablock的指针
   - 定义上：
     - 软连接又叫符号链接，这个文件的文件内容里包含了另一个文件的路径名，相当于**具有快捷方式功能的文件**。
     - 硬连接就是**一个文件的一个或多个多件名**，
     - ![](./legend/连接文件.png)
   - 限制上：
     + 硬链接只能对同一文件系统下的文件进行链接
     + 软连接可以跨文件系统，对文件和目录都可以链接
   - 操作上：
     - 修改：通过链接来编辑文件，都会导致源文件爱被修改
     - 删除：
       - 当指向inode的硬链接（所有文件名的都是硬链接）数目为0的时候就会删除源文件本身。
       - 软链接是本身就是一个文件，你删除了就删除了软链接本身，不会对源文件造成影响。但如果源文件被删除，这个软链接就成了死链接，如果恢复源文件，那这个软链接也可恢复。

2. 动态库和静态库的制作，及区别

   ```bash
   # 静态库制作
   # 1.编译生成.o文件
   gcc -c add.c
   gcc -c sub.c
   # 2.由.o文件生成静态库，使用ar工具
   ar -rc libcal.a add.o sub.o # 库名称cal，lib是它的前缀，.a是它的后缀
   # 3.整理liccal.a和add.h，sub.h到一个文件结构下，供他人使用
   mkdir -p mathlib/lib
   mkdir -p mathlib/include
   cp *.a mathlib/lib
   cp *.h mathlib/include
   
   #4.编译含有main函数的test.c文件，test.c中用到了add.h的函数
   gcc test.c -I ./mathlib/include -L ./mathlib/lib -l cal -o mytest
   #5.运行可执行文件
   ./mytest
   
   # 动态库制作
   # 1.编译生成位置无关的.o文件
   gcc -fPIC -c add.c
   gcc -fPIC -c sub.c
   # 2.由.o文件生成共享库格式的动态库
   gcc -shared -o libcal.so add.o sub.o
   # 3.整理库结构，同上
   # 4.编译含有main函数的test.c文件
   gcc test.c -I mlib/include/ -L mlib/lib/ -l cal -o mytest
   # 5.告诉操作系统运行时在哪找动态库
   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/mylib/lib/
   # 6.运行可执行文件
   ./mytest
   ```

   - 区别：
     - 静态库代码装载速度快，执行速度也比动态库快
     - 动态库更加节省内存，可执行文件体积比静态库小很多
     - 静态库在编译时加载，动态库是在运行时加载
     - 生成静态库，windows是.lib，linux是.a。生成动态库，windows是.dll，linux是.so
   - 

3. LRU算法及其实现方式

   - LRU算法：用于缓存淘汰，思路是将缓存中最近最少使用的对象删除掉

   - 实现方式：利用链表和hashmap

     - 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。
     - 如果命中，则移至头部，如果未命中，则创建在头部，链表最后一个节点即为最久未访问数据

   - ```c++
     class LRUCache {
     	list<pair<int, int>> cache;//创建双向链表
     	unordered_map<int, list<pair<int, int>>::iterator> map;//创建哈希表
     	int cap;
     public:
     	LRUCache(int capacity) {
     		cap = capacity;
     	}
     	int get(int key) {
             if (map.count(key) > 0){
                 auto temp = *map[key];
                 cache.erase(map[key]);
                 map.erase(key);
                 cache.push_front(temp);
                 map[key] = cache.begin();//映射头部
                 return temp.second;
             }
             return -1;
     	}
         void put(int key, int value) {//添加数据
             //如果查询到链表里有这个数据，则删除；这个if{}里的和else if{}后面的内容和get方法内容相似
             //都为的是将历史同样数移至链表头部
             if (map.count(key) > 0){
                 cache.erase(map[key]);
                 map.erase(key);
             }
             else if (cap == cache.size()){//这里是查询链表是否已满，如果满，则删除链表尾部数据
                 auto temp = cache.back();
                 map.erase(temp.first);
                 cache.pop_back();
             }
             cache.push_front(pair<int, int>(key, value));
             map[key] = cache.begin();//映射头部
         }
     };
     
     int main(){
         LRUCache* obj = new LRUCache(capacity);
     	//访问查询数据
         int param_1 = obj->get(key);
         // 添加数据
         obj->put(key,value);
     }
     ```

4. 一个线程占多大的内存

   - linux中大概8M

5. 虚拟内存和物理内存

   - 物理内存：寄存器，高速缓存器，主存，磁盘。访问速度一次递减，访问容量依次增大。有一个专门的内存管理器记录内存的使用情况，完成分配和回收的工作。

     <img src="./legend/物理内存存储层次结构.png" style="zoom:50%;" />

   - 虚拟内存：操作系统为每一个进程分配一个独立的地址空间，它是虚拟的空间。虚拟内存与物理内存通过页表建立映射关系。

   - 早期内存分配方式存在的问题：

     - 进程地址空间不隔离，会导致数据被随意修改。
     - 内存使用效率低。
     - 程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。

   - 虚拟内存的优点

     - 扩大地址空间，每个进程占4G，真实物理空间并没有那么大
     - 内存保护，防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。
     - 内存共享，方便进程通信。
     - 可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。

   - 虚拟内存的缺点

     - 虚拟内存需要额外构建数据结构，占用空间。
     - 虚拟地址到物理地址的转换，增加了执行时间。
     - 页面换入换出耗时。
     - 一页如果只有一部分数据，浪费内存。

6. 什么是页表

   - 操作系统虚拟内存到物理内存的映射表，就被称之为页表
   - 如果虚拟内存的每个字节都对应到物理内存上，那么这张表将大得真正的物理地址也放不下。于是操作系统引入页（page）的概念。
   - 在64位的操作系统中，虚拟内存每页的大小为4kbyte（物理内存的页框大小同样），即2*12次方，需要12位来表示页内的所有地址（页内偏移最大为2^12）,如果用64位中的48位来表示虚拟地址，48位的低12位用来记录数据在页内的地址，高36位用来表示页码（页号）
   - 系统在启动时，操作系统将将整个物理内存以4K为单位，划分为各个页，之后进行内存分配时，都以页为单位，那么虚拟内存页到物理内存页框的映射表就大大减小，4G内存只需要8M大小的页表就可以映射。

7. 缺页，缺页异常，缺页中断

   - 缺页：一个程序被加载运行时，只是加载了很少一部分到内存，另外一部分在需要时再从磁盘载入，被加载到内存的部分标识为“驻留”，而未被加载的部分标识为“未驻留”，当操作系统根据需要读取虚拟地址表，如果读取到虚拟地址表中记录的地址为“未驻留”，表示这部分地址记录内存未被加载到内存，需要从磁盘读入，则这种情况就是缺页。
   - 缺页异常：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常，引发缺页中断。
   - 缺页中断：缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

8. 虚拟地址到物理地址怎么映射

   - 操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表中的每一项都记录了这个页的基地址。
   - 三级页表转换 方法：
     - 逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址
     - 线性地址转物理地址：每一个32位的线性地址被划分为三部分：页目录索引（DIRECTORY，10位）、页表索引（TABLE，10位）、页内偏移（OFFSET，12位）
       - 从cr3中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）
         - 页目录地址 + 页目录索引 = 页表地址
         - 页表地址 + 页表索引 = 页地址
         - 页地址 + 页内偏移 = 物理地址
   - ![](./legend/三级页表转换示意.jpg)

9. 堆栈溢出

   - 堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。
   - 本质上一种数据结构的满溢情况。
   - 堆溢出：假如不断的new，而不释放，最终导致堆内存不足，报OutOfMemory Error
   - 栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error。

10. 操作系统的malloc实现原理

    - 当开辟空间小于128kb时，调用brk函数。
    - 当开辟空间大于128kb时，调用mmap函数
    - malloc采用的是内存池的管理方式，先申请一大块内存作为堆区，然后将堆区分为多个内存块，采用隐式链表记录所有空闲块块，用户申请时，就分配一个空闲块。

11. mmap的原理和使用场景

    - mmap是一种**内存映射文件**的方法，即将一个文件或者其它对象映射到进程的地址空间（文件被映射到多个页上），实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。
    - 进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面（以文件格式当然看不懂指针到底写了什么进去）到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。
    - 相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。
    - ![](./legend/mmap.jpg)
    - 使用场景：
      - 对同一块区域频繁读写操作；
      - 可用于实现用户空间和内核空间的高效交互
      - 可提供进程间共享内存及相互通信
      - 可实现高效的大规模数据传输。

12. 进程空间从高位到低位都有什么

    - 内核空间：1G
    - 程序空间：3G，由高到低：环境变量，命令行参数，栈空间，共享区，堆空间，.bss(未初始化全局)，.data(已初始化全局)，代码段，受保护的地址。

    ![](./legend/进程空间.jpg)

13. 32位系统能访问4G以上的内存空间吗？

    - 正常情况下不可以，2^32次方等于4G，一个操作字长最多能到4G的空间。
    - PAE（physical address extension）技术，PAE最初是为了弥补32位地址在PC服务器应用上的不足而推出的，4GB普通桌面应用差不多够用，但对于服务器来说还是显不足，PAE技术将地址扩展至36位，系统能够容纳64G的内存。

14. 大小端

    - 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，和我们的阅读习惯一致

    - 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，

      ```c++
      bool isLittleEndian(){
          unsigned short a = 0x1218;//16进制数
      
          if( (*(char*)&a)  == 0x18){
              return true;
          }else{
              return false;
          }
      }
      ```

      

## 进程

1. [linux内核态（系统态）与用户态，什么时候会进入内核态](https://blog.csdn.net/qq_41709234/article/details/124320482)

   - **内核态：**也叫**内核空间**，是内核进程/线程所在的区域。**主要负责运行系统、硬件交互。**
   - **用户态：**也叫**用户空间**，是用户进程/线程所在的区域。**主要用于执行用户程序。**
   - 区别：
     - **内核态：**运行的代码**不受任何限制**，CPU可以执行任何指令。
     - **用户态：**运行的代码需要受**到CPU的很多检查**，不能直接访问内核数据和程序，也就是说不可以像内核态线程一样访问任何有效地址。
   - 何时进入内核态：操作系统**在执行用户程序时**，主要工作在用户态，只有在其执行**没有权限完成的任务**时才会切换到内核态。
   - 为什么要区分这二态：保护机制。**防止用户进程误操作或者是恶意破坏系统。**
   - 用户态切换到内核态的方式：
     - 系统调用（主动）：由于用户态无法完成某些任务，**用户态会请求切换到内核态**，内核态通过为用户专门开放的中断完成切换。
     - 异常（被动）：在执行用户程序时**出现某些不可知的异常**，会从用户程序切换**到内核中处理该异常的程序**，也就是切换到了内核态。
     - 外围设备中断：外围设备发出中断信号，当中断发生后，**当前运行的进程暂停运行，**并由**操作系统内核**对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态向内核态的切换。

2. 并发和并行

   - 并发：单核CPU（单个处理器），在同一时刻只有一个进程在运行，多个线程的执行在不同时间片中。

   - 并行：多核CPU，多个处理器，同时处理多个进程。

   - 区别：

     - | 并发（时分复用）                     | 并行（空分复用）       |
       | ------------------------------------ | ---------------------- |
       | 多个事件（任务）在同一时间间隔发生。 | 多个事件同时发生       |
       | 在同一实体（处理器）上的多个事件     | 在不同实体上的多个事件 |

       <img src="./legend/并行与并发.png" style="zoom:80%;" />

3. 进程，线程，协程

   - 进程：

     - 是程序的实体，是系统进行资源分配和调度的基本单位，

     - 进程有5种基本状态：初始态、就绪状态、执行状态、等待（阻塞）状态、终止状态。

   - 线程：

     - 是程序执行中一个单一的顺序控制流程，是处理器调度和分派的基本单位。
     - 一个进程可以有多个线程，多个线程共享进程中的所有资源，各个线程有各自的调用栈和线程本地存储
     - 也有五个状态

   - 协程：

     - 微线程，比线程更加轻量的存在，协程不被操作系统所管理，完全由程序所控制
     - 一个线程可以有多个协程，可以比作子程序，子程序可中断。
     - 协程适用于IO阻塞且需要大量并发的场景

   - <img src="./legend/进程线程协程.png" style="zoom:50%;" />
   - 进程和线程的区别
     - 线程从属于进程，
     - 进程是系统资源调度的最小单位，线程是CPU调度的最小单位
     - 进程拥有独立的内存单元，多个线程共享进程的内存，线程拥有自己的栈段和寄存器组
     - 进程切换需要刷新页表缓冲并获取新的地址空间，然后切换硬件上下文和内核栈。线程切换只执行后二者。
     - 通信方式不一样
     - 进程适用于多核，多机分布。线程适用于多核
   - 线程和协程的区别
     - 协程执行效率极高，切换开销更小更快，直接操作栈没有内核切换的开销。
     - 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

4. linux fork函数

   - 用于创建子进程，我们在shell下执行一个命令其实也是通过fork()实现的。
   - fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。
   - fork()最大的特点就是一次调用，两次返回，两次返回主要是区分父子进程，因为fork()之后将出现两个进程，所以有两个返回值，父进程返回子进程ID，子进程返回0。如果创建失败返回-1

5. 孤儿进程，僵尸进程

   - 孤儿进程：父进程退出后，而子进程还在运行，被称作孤儿进程，孤儿进程将被init进程（进程号为1）接管和记录状态
   - 僵尸进程：一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。
   - 解决僵尸进程
     - fork子进程后，都要及时调用wait系统调用。
     - kill进程。

6. 守护进程，[如何实现](https://blog.csdn.net/m0_72772587/article/details/126692497)

   - 运行在后台，长生存期（系统启动到关闭）的进程，通常独立于控制终端，并且周期性的执行某种任务或等待处理某些发生的事件。Daemon，处理一些系统级的任务。

   - 如何实现：

     - 创建子进程，终止父进程。(使子进程称为后台进程)：调用fork，然后杀父进程

     - 创建一个新会话，使进程完全独立：调用setid()

       - linux以会话，进程组的方式管理进程，每个进程属于一个进程组，会话则是多个进程组的集合。

     - 将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。

       - 便于让守护进程以绝对路径的形式访问资源

     - 重设文件权限掩码。

       - 将文件掩码设置为0，方便后续守护进程创建时，创建出来的文件权限符合我们的预期，增强守护进程的灵活性

     - 关闭子进程从父进程继承打开的文件描述符。

       - 进程继承了父进程已经打开的文件，这些文件可能永远不会被守护进程读写，但一样会消耗资源，所以需要关闭这些不用的文件描述符。

       ```c
       #include <stdio.h>
       #include <sys/stat.h>
       #include <sys/types.h>
       #include <unistd.h>
       #include <stdlib.h>
        
       int main()
       {
       	//1.创建子进程，关闭父进程
       	pid_t pid=0;
       	pid=fork();
       	if(pid<0)
       	{
       		perror("fork error");
       		return -1;
       	}
       	if(pid>0)
       	{
       		exit(0);//关闭父进程
       	}
       	//2.创建新会话
       	pid=setsid();
       	if(pid<0)
       	{
       		perror("setsid error");
       		return -1;
       	}
       	//3.设置工作目录
       	chdir("/tmp");
       	//4.重设文件掩码
       	umask(0);
       	//5.关闭从父进程继承下来的文件描述符
       	int i=0;
       	for(i=0;i<getdtablesize();i++)
       	{
       		close(i);
       	}
       	//6.执行任务(每5秒记录一次系统时间)
       	while(1)
       	{
       		system("echo `date` >> time.txt");
       		sleep(5);
       	}
       	return 0;
       }
       //根目录tmp文件夹下多了一个time.txt文件。查看该文件，可以看到守护进程每5秒写入的系统时间。
       ```

7. 进程间通信

   - 进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存）、套接字socket。
   - 管道：管道本质是一种文件，
     - 无名管道（半双工）：只能用于具有亲缘关系的进程直接通信
     - 命名管道：可以允许无亲缘关系进程间的通信。
   - 系统IPC(inter-process communication)
     - 消息队列
     - 信号量semaphore：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。
     - 信号：用于通知接收进程某个事件的发生。
     - 内存共享：使多个进程访问同一块内存空间。
   - 套接字socket：用于不同主机直接的通信。

8. 进程通信中管道的实现原理

   - 操作系统在内核中开辟一块缓冲区（称为管道）用于通信，管道本质是文件，一般文件的 I/O 函数都可以用于管道，如close()、read()、write()等。
   - 管道具有单向通信的机制，所以要实现全双工需要两个管道
   - 

   ```c
   // 父子进程间的管道通信
   #include<unistd.h>
   #include<stdio.h>
   #include<stdlib.h>
   #include<string.h>
   #define INPUT 0
   #define OUTPUT 1
   int main(){
       //1.创建管道
       int fd[2];
       pipe(fd);
       //2.创建子进程
       pid_t pid = fork();
       if (pid < 0){
       	printf("fork error!\n");
       	exit(-1);
       }
       else if (pid == 0){//执行子进程
       	printf("Child process is starting...\n");
           //3. 子进程向父进程写数据，关闭管道的读端
           close(fd[INPUT]);
           write(fd[OUTPUT], "hello douya!", strlen("hello douya!"));
           exit(0);
       }
       else{//执行父进程
        	printf ("Parent process is starting......\n");
           //4.父进程从管道读取子进程写的数据 ，关闭管道的写端
           close(fd[OUTPUT]);
           char buf[255];
           int output = read(fd[INPUT], buf, sizeof(buf));
           printf("%d bytes of data from child process: %s\n", output, buf);   
       }
       
       return 0;
       
   }
   ```

9. 常见的信号有哪些

   - | 信号代号 | 名称    | 说明                                                         |
     | -------- | ------- | ------------------------------------------------------------ |
     | **1**    | SIGHUP  | 该信号让进程立即关闭.然后重新读取配置文件之后重启            |
     | 2        | SIGINT  | 程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键     |
     | 19       | SIGSTOP | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |
     | **15**   | SIGTERM | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |
     | **9**    | SIGKILL | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |
     | **17**   | SIGCHLD | 子进程结束时, 父进程会收到这个信号。                         |
     | 18       | SIGCONT | 该信号可以让暂停的进程恢复执行。本信号不能被阻断             |

10. linux进程调度算法

   - 先来先服务调度算法：按照进程队列的先后选择一个或多个作业
   2. 短作业(进程)优先调度算法：从进程队列选择一个或若干估计运行时间最短的
   3. 高优先级优先调度算法
   4. 时间片轮转法
   5. 多级反馈队列调度算法：综合前面多种调度算法。
   - 这些调度算法中，抢占式和非抢占式的区别：
     - 非抢占式：进程一旦被执行，就直到完成，除非主动放弃处理机。可用于对实时性要求不严的实时系统中
     - 抢占式：正在执行的进程，和新的就绪进程的优先级比较，高者获取执行权。故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

11. 进程的状态

    - 创建、就绪、执行、阻塞、终止。
    - 一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。
    - ![](./legend/进程状态转换.jpg)
    - [**IO操作，为什么不要CPU**](https://blog.csdn.net/weixin_37989267/article/details/111041650)：IO所需要的CPU资源非常少。大部分工作是分派给DMA（**Direct Memory Access**）完成的
      - 磁盘IO：CPU计算文件地址 ==> 委派DMA读取文件 ==> DMA接管总线 ==> CPU的A进程阻塞，挂起 ==> CPU切换到B进程 ==> DMA读完文件后通知CPU（一个中断异常） ==> CPU切换回A进程操作文件

12. 死锁，产生条件，如何解决

    - 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。
    - 四个必要条件：
      - 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
      - 请求保持：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
      - 不可剥夺：进程已获得的资源，只能自己释放，不可剥夺；
      - 环路等待：若干进程之间形成一种头尾相接的循环等待资源关系。
    - 如何解决
      - 资源一次性分配，解决请求保持
      - 可剥夺资源：当新的资源未得到满足，释放已有资源，破坏不可剥夺条件
      - 资源有序分配，破坏环路等待条件

13. 线程间通信（同步）的方式

    - 临界区、互斥量、信号量、条件变量、读写锁
    - 临界区
      - 访问临界资源的代码段
      - 临界资源：同一时刻，只允许被一个进程或线程访问的资源
    - 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
    - 读写锁：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。
    - 信号量：计数器，允许多个线程同时访问同一个资源。
    - 条件变量：
      - 条件变量是利用线程间共享的全局变量进行同步的一种机制
      - 主要包括两个动作：一个线程等待条件变量的条件成立而挂起;另一个线程使条件成立（给出条件成立信号）。
      - 为了防止竞争，条件变量的使用总是和一个互斥量结合在一起。

14. 有了进程为什么还要线程

    - 在早期的多任务操作系统，进程是基本的执行单元，每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。但是进程频繁切换将引起额外开销从而严重影响性能，为了减小进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小粒度的执行单元来实现并发执行，这就是线程。
    - 线程的切换开销更小，

15. 单核机器上写多线程程序，是否还要加锁

    - 要加锁
    - 时间片的大小不定。比如单个时间片只能完成给定任务的一半，剩下的那一半就只有等下一个时间片了。而在等待的过程中，如果不加锁，就没法保证其他线程不使用我们的资源，数据就有可能出错。
    - A在吃饭用碗，还没吃完（时间片结束），给碗加个锁。下一个时间片，B过来吃饭，看见碗被锁住，所以这个时间片将等待，再下一个时间片，A吃完，将碗的锁释放。下一个时间片，B就可以吃饭用碗。

16. 互斥锁和读写锁

    - 互斥锁同一时间只允许一个线程访问该对象，无论读写；
    - 读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

17. 信号量，有什么作用

    - 信号量是一个特殊的变量，一般取正数值。它的值代表允许访问的资源数目。
    - 获取资源时，需要对信号量的值进行原子减一，该操作被称为 P 操作。当信号量值为 0 时，代表没有资源可用，P 操作会阻塞。
    - 释放资源时，需要对信号量的值进行原子加一，该操作被称为 V 操作。
    - 信号量主要用来同步进程。信号量的值如果只取 0,1，将其称为二值信号量。如果信号量的值大于 1，则称之为计数信号量。
    - 用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。

18. 进程和线程的中断切换是怎样的

    - 上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。

    - 进程上下文切换

      - 保护被中断进程的处理器现场信息

      - 修改被中断进程的进程控制块（PCB：process control block）有关信息，如进程状态等

      - 把被中断进程的进程控制块加入有关队列

      - 选择下一个占有处理器运行的进程

      - 根据被选中进程设置操作系统用到的地址转换和存储保护信息

        - 切换页目录以使用新的地址空间

        - 切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）

      - 根据被选中进程恢复处理器现场

    - 线程上下文切换

      - 保护被中断线程的处理器现场信息
      - 修改被中断线程的线程控制块（TCB：thread CB）有关信息，如线程状态等
      - 把被中断线程的线程控制块加入有关队列
      - 选择下一个占有处理器运行的线程
      - 根据被选中线程设置操作系统用到的存储保护信息，切换内核栈和硬件上下文（切换堆栈，以及各寄存器）
      - 根据被选中线程恢复处理器现场

19. 自旋锁和互斥锁的使用场景

    - 互斥锁：用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑
      - 临界区有IO操作
      - 临界区代码复杂或者循环量大
      - 临界区竞争非常激烈
      - 单核处理器
    - 自旋锁：持锁时间短且CPU资源不紧张，而且线程并不希望在重新调度上花太多的成本。
    - 自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。
    - 对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态，通过休眠使进程阻塞（等待期间放弃cpu）。但是自旋锁不会，获取锁之前一直处于忙等（自旋，原地打转）阻塞状态（没有放弃CPU）。

20. 多线程编程需要注意什么，加锁要注意什么

    - 多线程编程需要考虑同步问题，线程间的同步方式包括互斥锁、信号量、条件变量、读写锁。
    - 多线程加锁，主要需要注意死锁的问题。破坏死锁的必要条件从而避免死锁。

21. sleep和wait的区别

    - sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。linux sleep函数参数的单位是s，而windows 是ms
    - wait是父进程回收子进程PCB资源的系统调用，进程一旦调用了wait函数，就立即阻塞自己本身。然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。
    - 区别：
      - sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。
      - wait是父进程回收子进程PCB（Process Control Block）资源的一个系统调用。

22. 线程池的设计思路，线程池中线程的数量由什么确定？

    - 实现线程池设计思路：
      - 设置一个生产者消费的任务队列，作为临界资源。
      - 初始化n个线程，并让其运行起来，对任务队列加锁，去队列里取任务运行
      - 当任务队列为空时，所有线程阻塞。
      - 当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。
    - 线程池中线程数量，[实际](https://juejin.cn/post/7067183465224994852),[理论](https://juejin.cn/post/7066675779966337031)
      - 因素：CPU，IO、并行、并发
      - 线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。
      - 最佳线程数目：`（线程等待时间与线程CPU执行时间之比 + 1 ）* 2`
      - 对于计算密集型应用，线程池中线程数目推荐：`CPU核数 + 1`
      - 对于IO密集型应用：`2 * CPU核数 + 1`
      - 计算密集型如果是完成一件事情，线程为越少越好。可以减少上下文切换的时间。
      - I/O密集在线程池线程的数量在一定范围内越多越好，处理完成一件事情耗时也越少。但是增加到一定程度后会增加上下文的切换耗时反而导致时间增加。
      - 对于完成一件事情，线程池数量的多少不影响。

23. 进程和线程相比，为什么慢

    - 资源开销：进程系统开销显著大于线程开销。进程需要独立的内存空间
    - 切换开销：进程需要刷新TLB（Translation Lookaside Buffer，简单说，TLB就是页表缓存）获取新的地址空间，切换硬件上下文和内核栈，线程只需要切换后二者
    - 进程通信比线程通信开销大：进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

    

## IO

1. linux零拷贝原理

   - 零拷贝就是一种避免 CPU 将数据从一块存储（缓存）拷贝到另外一块存储（缓存）的技术。
   - 传统linux IO接口是基于数据拷贝做的，数据可以从缓存区到缓存区之间传输，从而减少磁盘的IO操作。但是数据传输过程的数据拷贝操作却导致了极大的 CPU 开销
   - 优点
     - 节省CPU
     - 减少内存之间的数据拷贝，节省内存带宽
     - 减少用户态和内核态之间数据拷贝，和上下文切换
   - 实例：用户态和内核态之间并没有拷贝。
   - mmap()来代替read调用：减少了一次拷贝
     - ![](./legend/零拷贝.png)
   - sendfile：从linux内核2.1开始，就用sendfile简化操作，带DMA的sendfile还可以减少页缓存到socket缓冲区的拷贝

2. epoll和select的区别，epoll为什么高效

   - 原理解释：[select和epoll](https://www.jianshu.com/p/c9190109c7d8)

   - select与epoll的使用场景：都是IO多路复用的机制，应用于高并发的网络编程场景。IO多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪，能够通知应用程序进行相应的读写操作。

   - 进程A执行到创建socket语句的时候，创建socket对象，进程A进入阻塞态，等待接收socket传来的网络数据，当socket已接收到数据之后，进程A进入执行态

     ![](./legend/进程与单个socket.png)

   - 进程正是通过**IO多路复用**的形式来监听多个socket（select和epoll）

   - select准备一个数组fds（文件描述符），存放需要监视的所有socket，然后调用select，如果fds中所有的socket都没有数据，select会阻塞，直到有一个socket收到数据，select返回，唤醒进程，用户可以遍历fds，通过FD_ISSET判断哪个socket收到了数据，然后做出处理。

     ![](./legend/select.png)

   - epoll创建epoll对象，维护一个就绪列表和等待队列。当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，由于rdlist的存在，进程A可以知道哪些socket发生了变化

     ![](./legend/epoll.png)

   - select与epoll的区别

     - 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。
     - 每调用一次select都会遍历一次fd集合，知晓哪个有数据，而epoll只会轮询一次fd集合，查看rdlist
     - select最大支持1024个fd，而epoll没有这个限制

   - epoll水平触发和边缘触发

3. Reactor、Proactor模式

   - 在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
   - Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中需要用户区传递缓存区，应用程序直接使用数据就行。

4. [同步和异步，阻塞与非阻塞](https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247526626&idx=4&sn=21178025390cbb53d2e89c918340e747&chksm=fbb1e11cccc6680a9ba746e7c092ce34e82ba9c786c251a4a89b3cb62c796bdf03303165ee36&scene=27)

   - 同步和异步指的是：当前线程是否需要等待方法调用执行完毕。（进程内部）
     - 同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。
     - 异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。
   - 阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。（阻塞让出cpu，进程之间）

5. [IO模型的类型](https://blog.csdn.net/qq_45981295/article/details/121409837)

   - 演唱会卖票，等票---第一阶段---->买票----第二阶段--->取票

   - <img src="./legend/io分类.png" style="zoom: 33%;" />

   - 阻塞io：调用io函数，等待返回，不停检查有无返回，返回后才能下一步。
   - 非阻塞io：调用io函数，每隔一段时间，检查io事件是否就绪，没就绪就可以做其他事情。
   - io多路复用（阻塞）：能实现对多个io端口进行监听，会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作
   - 信号驱动io（非阻塞）：首先开启接口信号驱动io功能，通过系统调用sigation执行一个信号处理函数（此信号调用直接返回，进程继续工作），就绪时，生成一个signal信号，通知应用程序来取数据。
   - 异步io（非阻塞）：Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。
   - 前四种模型--阻塞IO、非阻塞IO、多路复用IO和信号驱动IO都属于同步模式，因为其中真正的IO操作(将数据从内核拷到用户空间)都将会阻塞进程，只有异步IO模型真正实现了IO操作的异步性。
   - 异步和同步的区别就在于，异步是内核将数据拷贝到用户区，不需要用户再自己接收数据，直接使用就可以了，而同步是内核通知用户数据到了，然后用户自己调用相应函数去接收数据。

6. 客户端和服务端用到哪些函数

   - TCP
   - - server：
       1. socket创建一个套接字
       2. bind绑定ip和port
       3. listen使套接字变为可以被动链接
       4. accept等待客户端的链接
       5. write/read接收发送数据
       6. close关闭连接
     - client
       1. 创建一个socket，用函数socket()
       2. bind绑定ip和port
       3. 连接服务器，用函数connect()
       4. 收发数据，用函数send()和recv()，或read()和write()
       5. close关闭连接
   - UDP
   - - server
       1. 创建一个socket，socket()
       2. 设置服务器地址和端口并绑定,bind()
       3. 接受客户端数据,recvfrom()
       4. 发送数据,sendto()
       5. 关闭,close()
     - client
       1. 创建一个socket，socket()
       2. 设置想要连接对方的ip和端口
       3. 收发数据,sendto()/recvfrom()
       4. 关闭连接,close()

   ![](./legend/客户端和服务端用到哪些函数.jpg)

7. 

8. GDB常见调试命令，条件断点，多进程如何调试

# 3 计算机网络

## 路由

1. 静态路由和动态路由

   - 静态路由是由系统管理员设计与构建的路由表规定的路由。
     - 场景：适用于网关数量有限的场合，且网络拓朴结构不经常变化的网络。
     - 缺点：不能动态地适用网络状况的变化，当网络状况变化后必须由网络管理员修改路由表。
   - 动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。
     - 缺点：路由广播更新信息将占据大量的网络带宽。

2. 路由协议，都是如何更新的

   - 路由协议是路由器之间实现路由信息共享的一种机制，它允许路由器之间相互交换和维护各 自的路由表。当一台路由器的路由表由于某种原因发生变化时，它需要及时地将这一变化通 知与之相连接的其他路由器，以保证数据的正确传递。

   - 路由可分为静态和动态路由。静态路由由管理员手动维护；动态路由由路由协议自动维护。

   - 自治系统（Autonomous System，自治域）：单一技术管理下的一组路由器，这些路由器在AS内部使用同一种路由选择协议，在AS之间也使用同一种路由协议

   - 路由选择算法又分：域内路由选择，域间路由选择（自治系统间）

   - 路由选择算法必要步骤：

     1. 向其它路由器传递路由信息；
     2. 接收其它路由器的路由信息；
     3. 根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表；
     4. 根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由信息的形式向其它路由器宣告。

   - 两种主要算法：距离向量法（Distance Vector Routing，RIP、IGRP、EIGRP）和链路状态算法（Link-State Routing，OSPF、IS-IS）。

   - RIP（路由信息协议）：

     - 路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路 径信息，除到达目的地的最佳路径外，任何其它信息均予以丢弃。同时路由器也把所收集的 路由信息用 RIP 协议通知相邻的其它路由器。这样，正确的路由信息逐渐扩散到了全网。
     - 路由器根据距离（跳数）选择路由，路由表包含的内容：目的网络，距离（跳数，最大跳数15），下一跳路由。**每隔30秒**一次路由信息广播，仅和相邻路由器交换信息
     - 适合：小型同构网络

   - OSPF（开放最短路径优先）：

     - 采用洪泛法交换链路状态信息。（向相邻发信息，相邻再转发）
     - 各路由器之间交换链路状态信息，所有路由器最终能建立一个链路状态数据库，这个数据库就是AS下的全网拓扑结构图，然后通过Dijkstra算法计算自己到目的网络的距离，以此构造路由表。
     - 为了支持更大网络，OSPF将一个自治系统再分区，好处是将利用洪泛交换链路状态信息范围局限于每个区域而非整个AS，在区域内部只知道本区域的拓扑结构。
     - **只有当链路状态发生变化时，才交换链路信息**

   - BGP（边界网关协议）：自治域间路由选择，**路径向量算法**

     - 每个AS选一个BGP发言人，BGP就是来建立BGP发言人之间的拓扑结构。BGP所交换的网络可达性就是要到达某个网络所要经过的一系列AS。寻找一条能够到达目的网络且**比较好**的路由（因为是发言人，而不是所有路由）。
     - BGP的路由表：目的网络前缀，下一跳路由，到达目的网络所要经过的各个自治系统序列。

   - |          | RIP          | OSPF               | BGP                                        |
     | -------- | ------------ | ------------------ | ------------------------------------------ |
     | 类型     | AS内         | AS内               | AS间                                       |
     | 路由算法 | 距离-向量    | 链路状态           | 路径-向量                                  |
     | 传递协议 | UDP          | IP                 | TCP                                        |
     | 路径选择 | 跳数最少     | 代价最低           | 较好，非最佳                               |
     | 交换节点 | 相邻路由器   | 网络中所有路由     | 相邻路由器                                 |
     | 交换内容 | 自己的路由表 | 所有路由的链路状态 | 首次：整个路由表<br />非首次：有变化的部分 |

3. 域名解析过程，本机如何干预域名解析（ARP，Address Resolution Protocol，地址解析协议）

   1. 浏览器中输入www.qq.com 域名，操作系统查本地的hosts文件，有无映射关系，有则完成解析

   2. 如本地hosts无，就查本地DNS解析器（一般是网络接入服务器商提供，比如中国电信，中国移动。），有则完成

   3. 如本地DNS无，会找TCP/IP参数中设置的首选DNS服务器（本地DNS服务器），包含在本地配置资源中，则完成，此解析具有权威性

   4. 如查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则完成，但该解析不具权威性

   5. 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，

      - **如果未用转发模式**，
        - 本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。
        - 本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，
        - 如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com 主机。
      - **如果用的是转发模式**，
        - 此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。
        - 不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服
          务器再返回给客户机。

   6. 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

   7. 干预域名解析

      - 修改本机host来干预域名解析，/etc/hosts

      - 每一行为一条记录，分成两部分，第一部分是IP，第二部分是域名。

      - ```text
        192.168.188.1 www.baidu.com
        ```

      - ip对域名，是1对多

      - 重复ip行，按前面的记录解析

4. DNS劫持

   - DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

   - DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。

5. 网关的作用，同一网段主机如何通信

   - 网关即网络中的关卡，我们的互联网是一个一个的局域网、城域网、等连接起来的，在连接点上就是一个一个网络的关卡，即我们的网关，他是保证网络互连的，翻译和转换，使得不同的网络体系能够进行。
   - 网段内主机通信，即通信双方都位处同一网段中，数据传输无需经过路由器(或三层交换机)，即可由本网段自主完成。
   - 假设发送主机的ARP表中并无目的主机对应的表项，则发送主机会以目的主机IP地址为内容，广播ARP请求以期获知目的主机MAC地址，并通过交换机(除到达端口之外的所有端口发送，即洪泛(Flooding))向全网段主机转发，而只有目的主机接收到此ARP请求后会将自己的MAC地址和IP地址装入ARP应答后将其回复给发送主机，发送主机接收到此ARP应答后，从中提取目的主机的MAC地址，并在其ARP表中建立目的主机的对应表项(IP地址到MAC地址的映射)，之后即可向目的主机发送数据，将待发送数据封装成帧，并通过二层设备(如交换机)转发至本网段内的目的主机，自此完成通信。

6. CSRF：

   - 客户端脚本安全：跨站脚本攻击（XSS)，跨站点请求伪造（CSRF），点击劫持

   - 服务端安全：注入攻击，文件上传漏洞，分布式拒绝服务（DDOS）

   - 跨站请求伪造。就是黑客可以伪造用户的身份去做一些操作，进而满足自身目的。

   - 登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B，B获取A的cookie，去请求A的api。

   - 解决方法：

     - 在请求地址中添加 token 并验证

     - 在http头中自定义属性并验证

7. SYN flood，如何防止这类攻击

   - SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS(分布式拒绝服务攻击)的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，使被攻击方资源耗尽（CPU满负荷或内存不足)的攻击方式.
   - 防御
     - 反向代理 CDN，反向代理服务器位于用户与目标服务器之间，使用反向代理作为 Web 服务器的前置机来降低网络和服务器的负载，提高访问效率。
     - 充足的网络带宽保证：网络带宽直接决定了能抗受攻击的能力，假若仅有 10M 带宽，无论采取何种措施都很难对抗现在的 SYNFlood 攻击，当前至少要选择 100M 的共享带宽
     - 使用入侵防御系统/防火墙技术和专用于防御DDoS攻击的专用硬件来实现内部预防和响应DDoS攻击。
     - 从ISP购买DDOS缓解服务。

8. MAC和IP地址的作用

   - MAC地址：物理地址，是数据链路的地址，用来识别同一链路中的不同计算机和设备。（点到点，提供结点到结点）
   - IP 地址：逻辑地址，是网络层中的地址，用来识别计算机网路中互连的主机和路由器。（提供主机到主机逻辑通信）
   - 程序地址：端口号

9. 

## TCP

1. [TCP的三次握手和四次挥手](https://blog.51cto.com/jinlong/2065461)

   - 置位概念：根据TCP的包头字段，存在3个重要的标识ACK、SYN、FIN

     - ACK：表示验证字段
     - SYN：位数置1，表示建立TCP连接
     - FIN：位数置1，表示断开TCP连接

   - 三次握手过程说明：

     1. 由客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）
     2. 由服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接。
     3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）

   - ![](./legend/三次招手四次挥手.png)

   - 四次挥手说明

     1. 客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）

     2. 服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）

     3. 服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）

     4. 客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）

        至此TCP断开的4次挥手过程完毕

2. TCP两次握手行不行，为什么要三次

   - 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
   - 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

3. 三次握手时候每次握手信息对方没收到会怎么样

   - 如果第一次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
   - 如果第二次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
   - 如果第三次握手消息丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

4. [TCP连接和关闭的状态转移](https://blog.51cto.com/jinlong/2065461)

   - 11种状态
   - 三次握手

   1. 一开始，建立连接之前服务器和客户端的状态都为CLOSED；
   2. 服务器创建socket后开始监听，变为LISTEN状态；
   3. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT；
   4. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD；
   5. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED；
   6. 服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！

   ![](./legend/TCP三次握手四次挥手状态转移.png)

   - 四次挥手
     1. 客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1；
     2. 服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT；
     3. 客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；
     4. 直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；
     5. 客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；
     6. 再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
     7. 至此，还有一个状态没有出来：CLOSING状态。客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。

5. TCP 的 TIME_WAIT，为什么需要有这个状态

   - 报文段最大生存时间MSL（Maximum Segment Lifetime），2MSL——两个来回的报文最大生存时间。
   - TCP实现必须可靠地终止连接的两个方向(全双工关闭)，客户端必须进入 TIME_WAIT 状态，因为客户端可能面 临重发最终ACK的情形（2MSL，ACK发一次，丢失后，再发一次）

6. MSL，为什么客户端连接要等待2MSL的时间才能完全关闭

   - 报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
   - 为什么客户端连接要等待2MSL的时间才能完全关闭
     - 保证客户端发送的最后一个ACK报文段能够到达服务端。
       - 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的服务端收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
     - 防止“已失效的连接请求报文段”出现在本连接中。
       - 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

7. TCP慢启动

   - TCP拥塞控制：慢开始，拥塞避免，快重传和快恢复算法是对前二者的优化。都是基于重传超时和重复确认设计的算法。
   - TCP要求发送方必须有两个窗口：接收窗口rwnd（接收方许诺发送方的窗口字段），拥塞窗口cwnd（发送方自身估算的拥塞程度而设置的窗口值），发送窗口（滑动窗口）的上限值 = min{ rwnd，cwnd}
   - 慢开始：TCP建立一开始，令cwnd=1（最大报文段长度MSS），每收到一个报文的接收确认，cwnd=cwnd * 2，但增加到ssthresh阈值，就改用拥塞避免算法
   - 拥塞避免算法：当cwnd>ssthresh，cwnd = cwnd + 1
   - 当发送方检测到有确认超时发生时，ssthresh = cwnd / 2，cwnd =1，
   - 乘法减小算法：不论是在慢开始阶段，还是拥塞避免阶段，只要出现确认超时，即执行ssthresh = cwnd / 2
   - 加法增大算法：经过RTT（往返时间）之后，cwnd = cwnd + 1
   - 快重传：在连续收到3个重复的ACK后，直接重传对方尚未收到的报文段，不必等确认超时
   - 快恢复：在连续收到3个重复的ACK后，执行乘法减小，同时执行加法增大

8. TCP拥塞控制的算法有哪些

   - TCP Tahoe/Reno，基于重传超时和重复确认
     - Tahoe：慢启动，拥塞避免，快重传
     - Reno：快速恢复
   - TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）：2016年发布，google设计
     - BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。
     - 数据包传输的每个累积或选择性确认，用于生成，记录在数据包的传输过程 和 确认返回期间的时间内所传送数据量的采样率
     - 该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，

9. TCP超时重传

   - TCP可靠性中最重要的一个机制是处理数据超时和重传。
   - TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

10. TCP可靠性保证

    - TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。
    - 校验和：
      - 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。
      - TCP接收端在计算检验和时，要加上一个12字节的伪首部。
      - TCP首部校验和计算三部分：TCP首部+TCP数据+TCP伪首部。
    - 序列号/确认应答：发送端会给发送每个字节都编上序号，发送一个，接收端要回应一个
    - 超时重传：
      - 是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传
      - 但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。
    - 最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。
    - 滑动窗口：
      - 超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。滑动窗口就是用来解决这个问题
      - 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。
      - 发送端丢包（快重传）：当发送方丢包，接收端会连续回复多个相同的确认，表明数据丢失，当即重发。
      - 接收方确认信号丢失：序号大的确认信息表明序号小的数据包已送达，否则不会回复序号大的确认信息。
    - 拥塞控制：为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度（滑动窗口）传送数据。
    - 
    - <img src="./legend/滑动窗口.png" style="zoom:67%;" />

11. 滑动窗口以及重传机制

    - 滑动窗口：
      - 用来解决超时重传效率低下的问题，
      - 窗口大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。
      - 它的上限是：由接收端窗口大小、发送端拥塞窗口大小共同决定，swnd = min{ rwnd, cwnd }
    - 重传机制：
      - 超时重传：送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。如果多次重发皆没收到确认，即认为接收端异常，强制关闭连接。
      - 快重传：在连续收到3个重复的ACK后，直接重传对方尚未收到的报文段，不必等确认超时

12. 滑动窗口的大小影响

    - 网络性能：
      - 如果滑动窗口过小，则需要在网络上频繁的传输确认信息，占用了大量的网络带宽；
      - 如果滑动窗口过大，对于利用率较高，容易产生丢包现象的网络，则需要多次发送重复的数据，也同样耗费了网络带宽

13. TCP 粘包和拆包

    - TCP是个“流”协议，所谓流，就是没有界限的一串数据。
    - TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

14. TCP和UDP在网络协议的哪一层，二者的区别，头部结构

    - 在传输层。
    - 连接：TCP有连接，UDP无连接
    - TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。
    - TCP面向的是字节流的服务，UDP面向的是报文的服务。
    - 可靠机制：
      - TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，
      - UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
    - 报头大小：TCP首部需要20byte（不包含可选项），UDP首部只需要8byte
    - 拥塞控制：TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
    - 应用场景：
      - TCP适用于高可靠性并且传输时间要求不高的应用
      - UDP适用于实时性要求高的应用。大量游戏、视频、娱乐应用
    - 上层协议依赖：
      - 基于TCP协议的：HTTP，Telnet，FTP以及SMTP协议。
      - 基于UDP协议的：DHCP、DNS、SNMP、TFTP、BOOTP。

    ```c
    /*TCP头定义，共20个字节*/
    typedef struct _TCP_HEADER
    {
    short m_sSourPort; // 源端口号16bit
    short m_sDestPort; // 目的端口号16bit
    unsigned int m_uiSequNum; // 序列号32bit
    unsigned int m_uiAcknowledgeNum; // 确认号32bit
    short m_sHeaderLenAndFlag; // 前4位：TCP头长度；中6位：保留；后6位：标志
    位
    short m_sWindowSize; // 窗口大小16bit
    short m_sCheckSum; // 检验和16bit
    short m_surgentPointer; // 紧急数据偏移量16bit
    }__attribute__((packed))TCP_HEADER, *PTCP_HEADER;
    
    /*UDP头定义，共8个字节*/
    typedef struct _UDP_HEADER
    {
    unsigned short m_usSourPort; // 源端口号16bit
    unsigned short m_usDestPort; // 目的端口号16bit
    unsigned short m_usLength; // 数据包长度16bit
    unsigned short m_usCheckSum; // 校验和16bit
    }__attribute__((packed))UDP_HEADER, *PUDP_HEADER;
    ```

15. TCP如何保证有序

    - 发送方：发送数据时，给每个数据报分配一个序列号，并且在等待确认，如果确认超时，则发送方重传此数据包。
    - 接收方：按照序列号对接收的数据进行确认，检测丢失或乱序，接收到顺序化的数据后，整理成数据流，交给上层。
    - 具体步骤：
      - 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
      - 并为每个已发送的数据包启动一个超时定时器；
      - 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
      - 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

16. TCP如何加速一个大文件的传输

    - TCP 优化的本质就是用带宽换用户体验感
    - 建立连接优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。
    - 带宽评估：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更合理的控制发包速度。
    - 丢包预判：有些网络的丢包是有规律性的，掌握规律后，就可以针对性提前多发数据，减少重传时间、提高有效发包率。
    - RTO探测
    - `RTT(Round Trip Time)`：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；
    - `RTO(Retransmission Time Out)`：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。

17. 从系统层面上，UDP 如何保证尽量可靠

    - UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。
    - 最简单的方式是在应用层模仿传输层TCP的可靠性传输
      - 添加seq/ack机制，确保数据发送到对端
      - 添加发送和接收缓冲区，主要是用户超时重传。
      - 添加超时重传机制。

18. 服务端怎么判断客户端断开了连接

    - 检测连接是否丢失有两种：keep-alive和heart-beat
    - keep-alive：对端发送报文，尝试多次后，仍没反应，则判断连接中断，tcp断开连接
    - heart-beat：按较短的时间周期进行连接测试，如果连接测试失败，则认为判断失败，一般在应用层实现，用户可以自行决定中断后的行为，

19. 端到端和点到点

    - 端到端通信

      - 是针对传输层来说的，无论是TCP还是UDP，都负责将数据从发送端传输到接收端。
      - 指的是在数据传输之前，在发送端与接收端之间（**忽略中间有多少设备**）为数据的传输建立一条**逻辑链路**
      - 端到端通信建立在点到点的通信基础之上，它是由一段段的点到点通信链路构成的，完成应用程序（进程）之间的通信

      - 优点：
        - 链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。
      - 缺点：
        - 发送端的设备从数据的发送到接收要全过程参与，对发送端设备造成很大的浪费
        - 如果接收设备关机或故障，那么端到端传输不可能实现。

    - 点到点通信

      - 直接相连的节点对等实体的通信叫点到点通信，点到点通信是针对数据链路层或网络层来说的，只负责直接相连的两个节点之间的通信。通信子网
      - 优点：
        - 发送端只负责发送，不参与整个传输过程，不会浪费发送端设备的资源
        - 即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。
      - 缺点：
        - 点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。

    - 

20. TCP 的 keepalive和 HTTP 的 keepalive

    - HTTP keep-alive
      - 在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。
      - 使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。
      - 通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(**更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用**)。
      - keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用，正确地设置keep-alive timeout时间非常重要。
    - TCP keep-alive
      - 链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持
      - TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。
    - 区别：
      - 两个是完全不同的东西，
      - tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。
      - http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。

21. TCP 延迟ACK和累计应答

    - 延迟ACK：就是让接收方在收到数据后不立即反馈ACK消息，而是等到一小段时间，如果之后还有收到其他包就把这些ACK消息一起放入一个包中反馈给客户端。当然ack不能无限延长（超时重传，网络延迟），一般为200ms。
    - 累计应答：一个包的确认，它代表此包（确认号ack）之前的包都已收到，而不需要对每个包都要发送确认。

22. 



## HTTP

1. [http与https](<https://blog.csdn.net/xiaoming100001/article/details/81109617>)

   - http：
     - 超文本传输协议，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。
     - HTTP 协议有一个缺陷：通信只能由客户端发起。
     - 是一个基于请求与响应，无状态的，无连接应用层的协议，常基于TCP/IP协议传输数据。
       - 无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。第一次访问和第二次访问同一个服务器响应相同。通常用Cookie/Session加数据库的方式来跟踪用户的行动
       - 无连接：在http1.1以前，每次访问都需要通过Tcp的三次握手四次挥手，和服务器重新建立连接。HTTP/1.1持久连接Connection：keep-alive，手动断连。
       - 基于请求和响应，客户端发起请求，服务器响应
       - 优点：简单快速灵活
       - 缺点：明文传输，请求和响应不需要通信双方的确认，无法保证数据的完整性。
   - https：
     - 基于HTTP协议+SSL或TLS协议，通过提供SSL或TLS加密处理数据(采用混合加密技术)、验证对方身份(通过证书认证)以及数据完整性保护(防止篡改和冒充)
     - 安全低效，有偿享用。

2. http的referer头的作用

   - HTTP Referer是header的一部分，其表示请求当前资源的客户端来源。当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该请求是从哪个域过来的，服务器因此可以获得一些信息用于处理。
   - 作用：
     - 防盗链
       - 只允许我本身的网站访问本身的图片服务器，假如域是www.google.com ，那么图片服务器每次
         取到Referer来判断一下域名是不是www.google.com ，如果是就继续访问，不是就拦截。
         将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发
         送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访
         问。
     - 防止恶意请求
       - 对于风险较高的文件类型，可使用Referer使得该类型资源只能来自我所指定的网站。
     - 防御CSRF
       - 比对HTTP 请求的来源地址，如果Referer中的地址是安全可信任的地址，那么就放行
     - 空referer
       - 允许Referer为空，意味着你允许比如浏览器直接访问。

3. [http状态码](<https://www.cnblogs.com/xflonga/p/9368993.html>)：

   - 1xx：通知，系列响应状态码仅在与HTTP服务器沟通时使用。
   - 2xx：成功，系列响应状态码表明操作成功了
   - 3xx：重定向，客户端需要做些额外工作才能得到所需要的资源。 
     - 301：Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI 代替。
     - 302：Found，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来继续以后的请求。
     - 304：Not Modified 未修改。所请求的资源自上次访问后，请求的内容未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
   - 4xx：客户端错误，表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。
     - 400（Bad Request）：请求无效，前端提交数据的字段名称和字段类型与后台的实体没有保持一致，协商不一致
     - 401（Unauthorized）：当前请求需要用户验证，客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书（登录等）。
     - 403（Forbidden）：服务器已经得到请求，但是拒绝执行。常用于一个资源只允许在特定时间段内访问，或者允许特定IP地址的用户访问的情况。
     - 404（Not Found）：服务器无法把客户端请求的URI转换为一个资源。
   - 5xx：服务端错误，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。
     - 500（Internal Server Error）：服务器如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。
     - 502 （bad gateway）：表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。

4. GET和POST的区别

   - 关于url长度：http没有做长度限制，只是说浏览器做了长度显示，2048个字符。GET数据有长度限制。
   - 关于安全性：post比get要好一点，但这个在安全问题面前影响很小，一般情况下，私密数据传输用POST + body就好。
   - 关于参数：GET参数通过URL传递，POST放在Request body中。
   - 关于编码：GET的参数只能支持ASCII（url上只支持ASCII），而POST能支持任意binary（body支持任意编码），包括中文。但用作接口时，GET实际上也可以带body，POST也可以在url上携带数据。
   - 关于缓存：GET请求会被浏览器主动cache，而POST不会，除非手动设置。

5. http八种请求方法：

   - 表明对Request-URL指定的资源不同的操作方式
   - http1.0 
     - GET：向特定资源发出请求（请求指定页面信息，并返回实体主体）
     - POST：向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改
     - HEAD：get请求类似，返回的响应中没有具体内容，用于获取报头（用于检查超链接的有效性）
   - http1.1增加了
     - OPTIONS：返回服务器针对特定资源所支持的HTML请求方法
     - PUT：向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）
     - DELETE：请求服务器删除request-URL所标示的资源
     - TRACE：回显服务器收到的请求，用于测试和诊断
     - CONNECT ：能够将连接改为管道方式的代理服务器

6. HTTP的缓存机制

   - HTTP 缓存即是浏览器第一次向一个服务器发起HTTP 请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段如：cache-control，expires，last-modifed，ETag,Date等，之后浏览器再向该服务器请求资源就可以视情况使用强缓存和协商缓存，
   - 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。
   - 协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。

7. HTTP1.0，1.1，2.0区别

   - 1.0 :
     1. 默认不支持长连接，需要设置keep-alive参数指定
        - 长连接是使用同一个[TCP](https://baike.baidu.com/item/TCP?fromModule=lemma_inlink)连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。
     2. 强缓存expired、协商缓存last-modified\if-modified-since 有一定的缺陷
   - 1.1
     1. 默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请
        求在一个Tcp中是串行的)
     2. 增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化

   - 2.0
     - 多路复用
       - http1.1浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞，可以通过多CDN(content delivery network）解决同一域名请求的数量限制。
       - ![http1.1请求数量限制.jpg](./legend/http1.1请求数量限制.jpg)
       - 而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的<strong>请求-响应</strong>
       - ![](./legend/http2.0多路复用.jpg)
     - 服务器推送
       - 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。比如说一个页面
       - 服务器推送还有一个很大的优势：可以缓存
     - 二进制分帧
       - 在应用层与传输层之间加了一个分帧层
       - HTTP/2 会将所有传输的信息分割为更小的消息和帧
       - 实现低延迟和高吞吐量
     - 首部压缩

8. cookie和session的区别：

   - 二者都用于会话跟踪。**Cookie通过在客户端记录信息确定用户身份（克服http无状态）**，**Session通过在服务器端记录信息确定用户身份**。
   - cookie数据存放在客户的浏览器上（不是很安全），session数据放在服务器上。
   - session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   - 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

9. 输入URL到展现页面的全过程

   - DNS 解析、TCP 连接、发送HTTP 请求、服务器处理请求并返回HTTP 报文、浏览器解析渲染页面、连接结束

10. 

    

    




# 4 数据库

DDL，DML，DCL，DQL

## 4.1 SQL

1. 分页及优化

   ```sql
   # 1.limit子句实现
   -- 在所有的查询结果中，返回前5行记录。
   SELECT prod_name FROM products LIMIT 5;
   -- 在所有的查询结果中，从第5行开始，返回5行记录。
   SELECT prod_name FROM products LIMIT 5,5;
   
   #在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后
   #只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。
   
   # 2.利用索引覆盖扫描
   ```

   

2. 

# offer

# 1 C/C++

1. C++语言特点

   - 继承C的面向过程，结构化语言，执行效率高（比汇编慢10%~20%）。
   - 面向对象：封装（结构清晰），继承（代码重用），多态（丰富扩展性，面向接口编程）。
   - 泛型编程：引入模板编程思想，在此基础上实现STL，实现算法和数据结构的分离，极大提高代码的可复用度，提高开发效率。
   - 更加安全易用，增加了引用，四个类型转换，try_catch异常类型机制
   - 发展的语言：lambda函数、右值引用，可变参数模板，智能指针等。

2. C和C++的特点

   - C++是C的超集，C++可以很好的兼容C，并且增加了许多新特性。
   - C++是面向对象的语言，而C面向过程
   - C++可复用性更高，引入泛型编程中的模板思想，在此基础上构建了STL，使C++相较于C更加灵活，更加通用
   - C++更安全，引用，智能指针，try_catch异常机制，cast转换。

3. C++中class与struct的区别

   - 使用场景：struct更多用于描述一个数据结构集合，而class是对一个对象数据的封装。
   - 本质区别是：访问控制
     - struct默认的访问权限是public，而class是private
     - struct默认的继承权限是public，而class是private
   - 泛型方面：struct不支持模板参数，而class可以。
   - 其余方面struct和class没什么大的区别:
     - class可以继承struct，struct也可以继承class，取决于继承者的类型
   - 

4. C++中的struct和C中的struct的区别

   - 声明时：

     |          | C                      | C++                      |
     | -------- | ---------------------- | ------------------------ |
     | 成员函数 | 不能有                 | 可以有                   |
     | 静态成员 | 不能有                 | 可以有                   |
     | 访问控制 | public，不可修改       | public/private/protected |
     | 继承关系 | 不可继承               | 可从其他类或结构体继承   |
     | 初始化   | 不能直接初始化数据成员 | 可以                     |

   - 初始化声明时：C中必须加上关键字struct，而C++中可以省略。

5. [include头文件中双引号""和尖括号<>的区别](https://blog.csdn.net/qq_27825451/article/details/102568482)

   - 头文件的文件类型：尖括号中的系统文件，双引号中的是自定义文件
   - 查找文件的路径顺序：
     - 双引号：
       1. 当前源文件所在的工作目录
       2. 编译器设置的头文件查找路径，编译器有默认的头文件查找路径。（当然也可以-i指定）
       3. 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径（vs，如果安装在C盘就在programfile x86下的Windows Kits\10\Source\10.0.22000.0\ucrt，如果在其他盘就在盘下的Windows Kits\10\Source\10.0.22000.0\ucrt）
     - 尖括号就在后两个路径上找

6. 在C++中导入C语言代码的关键字。

   - 关键字是extern，表达形式是extern "C"
   - 主要作用：为了实现C++代码调用其他C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言进行编译，而不是C++
   - 在函数方面，C编译器和C++编译器编译有所不同，由于C++支持函数重载，编译时函数名会加上参数的类型，而C不会。

7. 简述C++从代码到可执行的二进制文件的过程

   - C++和C语言类似，总过程：预处理（预编译，.i），编译（.s），汇编（.o），链接（.exe）
   - 预处理阶段：主要做宏处理，宏分四类：define宏定义，include宏，if条件编译宏，预定义宏
     - 处理宏定义展开
     - 处理所有条件编译宏
     - 处理include宏，将被包含的文件插入到预编译指令的位置
     - 处理预定义宏，添加行号，文件名，日期等。
     - 生成.i的临时文件
   - 编译阶段
     - 词法分析，语法分析，语义分析，代码优化，生成汇编代码，汇编代码优化
     - 生成.s临时文件
   - 汇编阶段
     - 将汇编代码转变为机器可以执行的指令。
     - 生成目标文件.o或.obj
   - 链接阶段
     - 将不同源文件产生的目标文件进行链接，从而形成可执行的程序。
     - 生成可执行文件（window为.exe，linux为.out)
     - 链接分为静态和动态链接：
       - 静态链接：将函数和数据编译成一个静态链接库文件（windows为.lib，linux为.a），在链接的时候，把需要调用的函数或过程嵌入链接到生成的可执行文件中，现在就算你把静态库删除也不会影响可执行程序的执行。
         - 静态库本身并不需要与可执行文件一起发行。
       - 动态链接：将函数和数据编译成生成动态链接库文件（windows为.dll，linux为.so），在链接的时候，并没有把调用的函数和过程嵌入链接进入可执行文件中，只包含函数的重定位信息。所以当你删除动态链接库的时候，可执行程序就不能运行。

8. 关键字static的作用

   - 静态局部变量和静态全局变量，
     - 静态全局变量：
     - 静态局部变量：在编译时分配内存并赋初值（之后不再赋初值），函数调用后，内存不释放
   - 静态函数
   - 静态变量和静态函数都被限制在本文件中。
   - 在C++的类中，被用于定义静态成员（变量和函数），
     - 静态成员只有一份拷贝，为所有对象共享
     - this指针无法引用

9. [指针和数组的区别](https://blog.csdn.net/qq_36992917/article/details/79238874)

   - |          | 数组                                               | 指针                       |
     | -------- | -------------------------------------------------- | -------------------------- |
     | 访问效率 | 直接访问，效率高                                   | 间接访问，效率低           |
     | 字节大小 | 不固定，数组类型和元素个数决定                     | 固定，由操作系统的字长决定 |
     | 标识符   | 指针常量，不可以使用自增++                         | 指针变量，可以使用自增++   |
     | 内存空间 | 存储的是一系列数值，对应的空间大小不可变，内容可变 | 存储的是地址               |
     | 赋值     | 遍历数组进行赋值                                   | 同类型指针变量可以相互赋值 |

   - 数组对应一块内存区域，地址和容量在其生命周期不会改变，其内容可变。而指针指向一块内存区域，指向的区域地址和大小可变。

10. 函数指针

    - 概念：指向函数的指针，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址

    - 定义：

      ```c
      int func(){}
      int (*f)();
      f= &func;
      ```

    - 应用场景：做回调函数。

11. [静态变量初始化时机](https://blog.csdn.net/u011723812/article/details/78151533)

    - 全局变量，文件域的静态变量和类的静态成员变量，在main执行之前，分配内存并初始化（编译期初始化）
    - 局部静态变量在第一次使用时分配内存并初始化。
    - 初始化线程安全性：非局部静态变量线程安全。而局部静态变量线程不安全（编译器的实现是通过一个标识，来标定这个局部静态变量是否初始化），而在支持C++11标准的编译环境下，它是线程安全的。
    - 全局或静态对象当且仅当对象首次用到时才进行构造

12. 用nullptr初始化类的对象，可不可以调用类的成员函数

    - nullptr可以调用成员函数，因为成员函数在编译对象时，就已经绑定了函数地址，和指针空不空没有关系

    - ```c++
      class animal{
      	public:
      		void sleep(){ cout << "animal sleep" << endl; }
      		void breathe(){ cout << "animal breathe haha" << endl; }
      };
      class fish :public animal{
      	public:
      		void breathe(){ cout << "fish bubble" << endl; }
      };
      int main(){
      	animal *pAn=nullptr;
      	pAn->breathe(); // 输出：animal breathe haha
      	fish *pFish = nullptr;
      	pFish->breathe(); // 输出：fish bubble
      }
      ```

13. [野指针](https://blog.csdn.net/qq_40927789/article/details/80686723)

    - 没有初始化的指针，指针指向的位置不可知。

    - 悬垂指针：指向已经释放内存区域的指针

    - 危害：

      - 指向一个不可访问的空间
      - 指向一个没有明确意义的空间，在这种情况下， 程序是正确的，可以正常运行，然而事实上是有问题存在，掩盖了程序上的错误
      - 指向一个可用，并且正在被使用的空间，如果我们用这样的指针对所指空间进行了修改，这个修改对程序的运行大概率会有影响，进而导致程序崩溃，或数据被损坏

    - 避免方法:

      - 初始化置NULL

      - 申请内存后判空

      - 内存释放后指针置空

      - 使用智能指针

      - ```c
        int *p = NULL; //初始化置NULL
        
        p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间
        assert(p != NULL); //判空，防错设计
        
        p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
        free(p);
        p = NULL; //释放后置空
        ```

14. 静态局部变量，静态全局变量，全局变量，局部变量的区别。

    - 作用域：
      - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件
      - 静态全局变量：文件作用域
      - 局部变量：局部作用域
      - 静态局部变量：局部作用域，只初始化一次，直到程序结束
    - 所在空间
      - 除局部变量在栈区（动态存储区），其他都在静态存储区。
    - 生命周期
      - 由于局部变量在栈上，出了作用域就回收存储，而其他都在静态存储区上，知道程序结束才回收内存。

15. 内联函数和宏函数的区别

    - 内联函数：广义的来说，定义时被inline修饰的函数。一般用于比较小而简单的，频繁调用的函数。
    - 宏函数：通过define定义的标识符，带参数的宏
    - 相同点：
      - 宏函数和内联函数都会在适当位置进行展开，都是以代码膨胀为代价，避免函数调用开销。
    - 区别：
      - 性质：宏函数不是函数（只是像，但不是），而内联函数是函数。
      - 处理阶段：宏函数在预处理阶段，而内联函数在编译阶段
      - 参数方面：宏函数没有类型检查（只进行简单的字符串替换），而内联函数会进行类型检查。

16. 内联函数和函数的区别

    - 定义需要inline修饰
    - 内联函数没有函数调用开销
    - 内联函数无需寻址（代码在调用处展开）
    - 选择：调用开销、执行函数体时间、代码量，三个维度来决定函数是内联还是普通

17. 运算符`i++和++i`的区别

    - 赋值顺序不同，
    - 效率不同：后置++比前置++效率低，后置`++`要多生成一个局部对象 tmp，因此执行速度比前置的慢。
    - i++不能作为左值，而++i可以
    - 二者都不是原子操作。

18. new和malloc的区别，各自底层实现原理

    - 区别：

      |      | new                                                          | malloc                                     |
      | ---- | ------------------------------------------------------------ | ------------------------------------------ |
      | 类型 | 操作符                                                       | 函数                                       |
      | 重载 | 可重载                                                       | 不可重载                                   |
      | 异常 | 发生错误，抛异常，分配内存更直接更安全，                     | 返回NULL                                   |
      | 构造 | **new** 和 **delete** 分别是 **开空间+构造函数**、**析构函数+释放空间** | 开空间和释放空间                           |
      |      | 会调用构造函数，无需指定内存大小，指针无需强转               | 需要给定申请的内存大小，返回的指针需要强转 |

    - [malloc底层实现](https://blog.csdn.net/Allelujah123/article/details/123874128)

      - https://blog.csdn.net/weixin_43340455/article/details/124570759

    - new底层实现

      - 创建一个新的对象
      - 将构造函数的作用域赋值给这个新的对象
      - 执行构造函数的代码
      - 返回新对象

19. [const详解](https://blog.csdn.net/qq_40337086/article/details/125519833)

    - [const 修饰变量](https://blog.csdn.net/weiyuanzhang123/article/details/117592035)：**const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。**
      - const int * ：`(const int) *`——指针指向一个整型常量，不可改变指针指向的内容，但指针本身可以改变
      - int const *：`(int const) *`——同上
      - int * const：`int (* const)`——指针常量指向一个整型变量，可改变指针指向的内容，但指针本身不可改变
      - const int * const：`(const int) (* const) `——指针常量指向整型常量
      - int const *const：`(int const) (* const)`
    - 

20. C++有几种传值方式

    - 值传递：改变形参的值，不会改变实参的值
    - 引用传递：改变形参的值，会改变实参的值
    - 指针传递：如果指针的指向没有改变，改变形参的值，会影响实参的值

21. 使用指针的注意

    - 防止野指针：
      - 定义指针变量时，初始化为NULL
      - 申请内存后，判空
      - 释放内存后，置为NULL
    - 动态内存申请和释放必须配对，防止内存泄漏
    - 避免指针越界

22. 常量定义：const和define 

    - 生效阶段：const在编译阶段，define在预处理阶段
    - 内存占用：const定义的变量需要占用内存空间，define运行时时直接的操作数
    - 类型：const定义的变量时有类型的，而define无

23. 






# offer

# 1 C/C++

## 1.1 语言基础

1. C++语言特点

   - 继承C的面向过程，结构化语言，执行效率高（比汇编慢10%~20%）。
   - 面向对象：封装（结构清晰），继承（代码重用），多态（丰富扩展性，面向接口编程）。
   - 泛型编程：引入模板编程思想，在此基础上实现STL，实现算法和数据结构的分离，极大提高代码的可复用度，提高开发效率。
   - 更加安全易用，增加了引用，四个类型转换，try_catch异常类型机制
   - 发展的语言：lambda函数、右值引用，可变参数模板，智能指针等。

2. C和C++的特点

   - C++是C的超集，C++可以很好的兼容C，并且增加了许多新特性。
   - C++是面向对象的语言，而C面向过程
   - C++可复用性更高，引入泛型编程中的模板思想，在此基础上构建了STL，使C++相较于C更加灵活，更加通用
   - C++更安全，引用，智能指针，try_catch异常机制，cast转换。

3. C++中class与struct的区别

   - 使用场景：struct更多用于描述一个数据结构集合，而class是对一个对象数据的封装。
   - 本质区别是：访问控制
     - struct默认的访问权限是public，而class是private
     - struct默认的继承权限是public，而class是private
   - 泛型方面：struct不支持模板参数，而class可以。
   - 其余方面struct和class没什么大的区别:
     - class可以继承struct，struct也可以继承class，取决于继承者的类型
   - 

4. C++中的struct和C中的struct的区别

   - 声明时：

     |          | C                      | C++                      |
     | -------- | ---------------------- | ------------------------ |
     | 成员函数 | 不能有                 | 可以有                   |
     | 初始化   | 不能直接初始化数据成员 | 可以                     |
     | 静态成员 | 不能有                 | 可以有                   |
     | 访问控制 | public，不可修改       | public/private/protected |
     | 继承关系 | 不可继承               | 可从其他类或结构体继承   |

   - 初始化声明时：C中必须加上关键字struct，而C++中可以省略。

5. [include头文件中双引号""和尖括号<>的区别](https://blog.csdn.net/qq_27825451/article/details/102568482)

   - 头文件的文件类型：尖括号中的系统文件，双引号中的是自定义文件
   - 查找文件的路径顺序：
     - 双引号：
       1. 当前源文件所在的工作目录
       2. 编译器设置的头文件查找路径，编译器有默认的头文件查找路径。（当然也可以-**i**指定）
       3. 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径（vs，如果安装在C盘就在programfile x86下的Windows Kits\10\Source\10.0.22000.0\ucrt，如果在其他盘就在盘下的Windows Kits\10\Source\10.0.22000.0\ucrt）
     - 尖括号就在后两个路径上找

6. 在C++中导入C语言代码的关键字。

   - 关键字是extern，表达形式是extern "C"
   - 主要作用：为了实现C++代码调用其他C语言代码，加上extern "C"后，会指示编译器这部分代码按C语言进行编译，而不是C++
   - 在函数方面，C编译器和C++编译器编译有所不同，由于C++支持函数重载，编译时函数名会加上参数的类型，而C不会。

7. 简述C++从代码到可执行的二进制文件的过程

   - C++和C语言类似，总过程：预处理（预编译，.i），编译（.s），汇编（.o），链接（.exe）
   - 预处理阶段：主要做宏处理，宏分四类：define宏定义，include宏，if条件编译宏，预定义宏
     - 处理宏定义展开
     - 处理所有条件编译宏
     - 处理include宏，将被包含的文件插入到预编译指令的位置
     - 处理预定义宏，添加行号，文件名，日期等。
     - 生成.i的临时文件
   - 编译阶段
     - 词法分析，语法分析，语义分析，代码优化，生成汇编代码，汇编代码优化
     - 生成.s临时文件(semble 装配)
   - 汇编阶段
     - 将汇编代码转变为机器可以执行的指令。
     - 生成目标文件.o或.obj
   - 链接阶段
     - 将不同源文件产生的目标文件进行链接，从而形成可执行的程序。
     - 生成可执行文件（window为.exe，linux为.out)
     - 链接分为静态和动态链接：
       - 静态链接：将函数和数据编译成一个静态链接库文件（windows为.lib，linux为.a），在链接的时候，把需要调用的函数或过程嵌入链接到生成的可执行文件中，现在就算你把静态库删除也不会影响可执行程序的执行。
         - 静态库本身并不需要与可执行文件一起发行。
       - 动态链接：将函数和数据编译成生成动态链接库文件（windows为.dll，linux为.so），在链接的时候，并没有把调用的函数和过程嵌入链接进入可执行文件中，只包含函数的重定位信息。所以当你删除动态链接库的时候，可执行程序就不能运行。

8. 关键字static的作用

   - 静态局部变量和静态全局变量，
     - 静态全局变量：静态全局变量、全局变量 和 类的静态数据成员都在编译时（程序运行前）分配内存和初始化
     - 静态局部变量：在第一次使用到的时候分配内存并初始化。（之后不再赋初值），函数调用后，内存不释放
   - 静态函数
   - 静态变量和静态函数都被限制在本文件中。
   - 在C++的类中，被用于定义静态成员（变量和函数），
     - 静态成员只有一份拷贝，为所有对象共享
     - this指针无法引用

9. [指针和数组的区别](https://blog.csdn.net/qq_36992917/article/details/79238874)

   - |          | 数组                                                         | 指针                                     |
     | -------- | ------------------------------------------------------------ | ---------------------------------------- |
     | 访问效率 | 直接访问，效率高                                             | 间接访问，效率低                         |
     | 内存空间 | 不固定，数组类型和元素个数决定，<br />对应的空间大小不可变，内容可变 | 固定，存储的是地址，由操作系统的字长决定 |
     | 标识符   | **指针常量**，不可以使用自增++                               | **指针变量**，可以使用自增++             |
     | 赋值     | 遍历数组进行赋值                                             | 同类型指针变量可以相互赋值               |
     
   - 数组对应一块内存区域，地址和容量在其生命周期不会改变，其内容可变。而指针指向一块内存区域，指向的区域地址和大小可变。
   
10. 函数指针

    - 概念：指向函数的指针，每一个函数都有一个入口地址，该入口地址就是函数指针指向的地址

    - 指针函数：返回值为指针的函数。

    - 定义：

      ```c
      int func(){}
      int (*f)();
      f= &func;
      ```

    - 应用场景：做回调函数。

11. [静态变量初始化时机](https://blog.csdn.net/u011723812/article/details/78151533)

    - 全局变量，文件域的静态变量和类的静态成员变量，在main执行之前，分配内存并初始化（编译期初始化）
    - 局部静态变量在第一次使用时分配内存并初始化。
    - 初始化线程安全性：非局部静态变量线程安全。而局部静态变量线程不安全（编译器的实现是通过一个标识，来标定这个局部静态变量是否初始化），而在支持C++11标准的编译环境下，它是线程安全的。
    - 全局或静态对象当且仅当对象首次用到时才进行构造

12. 用nullptr初始化类的对象，可不可以调用类的成员函数

    - nullptr可以调用成员函数，因为成员函数在编译对象时，就已经绑定了函数地址，和指针空不空没有关系

    - ```c++
      class animal{
      	public:
      		void sleep(){ cout << "animal sleep" << endl; }
      		void breathe(){ cout << "animal breathe haha" << endl; }
      };
      class fish :public animal{
      	public:
      		void breathe(){ cout << "fish bubble" << endl; }
      };
      int main(){
      	animal *pAn=nullptr;
      	pAn->breathe(); // 输出：animal breathe haha
      	fish *pFish = nullptr;
      	pFish->breathe(); // 输出：fish bubble
      }
      ```

13. [野指针](https://blog.csdn.net/qq_40927789/article/details/80686723)

    - 没有初始化的指针，指针指向的位置不可知。

    - 空指针常量，NULL值，空指针，野指针，悬垂指针，void指针

    - 悬垂指针：指向已经释放内存区域的指针

    - 危害：

      - 指向一个不可访问的空间
      - 指向一个没有明确意义的空间，在这种情况下， 程序是正确的，可以正常运行，然而事实上是有问题存在，掩盖了程序上的错误
      - 指向一个可用，并且正在被使用的空间，如果我们用这样的指针对所指空间进行了修改，这个修改对程序的运行大概率会有影响，进而导致程序崩溃，或数据被损坏

    - 避免方法:

      - 初始化置NULL

      - 申请内存后判空

      - 内存释放后指针置空

      - 使用智能指针

      - ```c
        int *p = NULL; //初始化置NULL
        
        p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间
        assert(p != NULL); //判空，防错设计
        
        p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
        free(p);
        p = NULL; //释放后置空
        ```

14. 静态局部变量，静态全局变量，全局变量，局部变量的区别。

    - 作用域：
      - 全局变量：全局作用域，可以通过extern作用于其他非定义的源文件
      - 静态全局变量：文件作用域
      - 局部变量：局部作用域
      - 静态局部变量：局部作用域，只初始化一次，直到程序结束
    - 所在空间
      - 除局部变量在栈区（动态存储区），其他都在静态存储区。
    - 生命周期
      - 由于局部变量在栈上，出了作用域就回收存储，而其他都在静态存储区上，直到程序结束才回收内存。

15. 内联函数和宏函数的区别

    - 内联函数：广义的来说，定义时被inline修饰的函数。一般用于比较小而简单的，频繁调用的函数。
    - 宏函数：通过define定义的标识符，带参数的宏
    - 相同点：
      - 宏函数和内联函数都会在适当位置进行展开，都是以代码膨胀为代价，避免函数调用开销。
    - 区别：
      - 性质：宏函数不是函数（只是像，但不是），而内联函数是函数。
      - 处理阶段：宏函数在预处理阶段，而内联函数在编译阶段
      - 参数方面：宏函数没有类型检查（只进行简单的字符串替换），而内联函数会进行类型检查。

16. 内联函数和函数的区别

    - 定义需要inline修饰
    - 内联函数没有函数调用开销
    - 内联函数无需寻址（代码在调用处展开）
    - 选择：调用开销（空间复杂度）、执行函数体时间（时间复杂度）、代码量，三个维度来决定函数是内联还是普通

17. 运算符`i++和++i`的区别

    - 赋值顺序不同，
    - 效率不同：后置++比前置++效率低，后置`++`要多生成一个局部对象 tmp，因此执行速度比前置的慢。
    - i++不能作为左值，而++i可以
    - 二者都不是原子操作。

18. new和malloc的区别，各自底层实现原理

    - 区别：

      |      | new                                                          | malloc                                     |
      | ---- | ------------------------------------------------------------ | ------------------------------------------ |
      | 类型 | 操作符                                                       | 函数                                       |
      | 重载 | 可重载                                                       | 不可重载                                   |
      | 异常 | 发生错误，抛异常，分配内存更直接更安全，                     | 返回NULL                                   |
      | 构造 | **new** 和 **delete** 分别是 **开空间+构造函数**、**析构函数+释放空间** | 开空间和释放空间                           |
      |      | 会调用构造函数，无需指定内存大小，指针无需强转               | 需要给定申请的内存大小，返回的指针需要强转 |

    - [malloc底层实现](https://blog.csdn.net/Allelujah123/article/details/123874128)

      - https://blog.csdn.net/weixin_43340455/article/details/124570759
      - malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表为每一个空闲块记录了一个未分配的、连续的内存地址。

    - new底层实现

      - 创建一个新的对象
      - 将构造函数的作用域赋值给这个新的对象
      - 执行构造函数的代码
      - 返回新对象
      
      ```c++
      A *pc = new A(1, 2);
      
      // 编译器会转化为下面的样子
      A* pc;
      try {
      	void* mem = operator new(sizeof(A)); //申请内存
      	pc = static_cast<A*>(mem);           //类型转换
      	pc->A::A();                          //调用构造函数
      }
      catch (std::bad_alloc) {
      	......
      }
      ```
      
      

19. [const详解](https://blog.csdn.net/qq_40337086/article/details/125519833)

    - [const 修饰变量](https://blog.csdn.net/weiyuanzhang123/article/details/117592035)：**const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。**
      - const int * ：`(const int) *`——指针指向一个整型常量，不可改变指针指向的内容，但指针本身可以改变
      - int const *：`(int const) *`——同上
      - int * const：`int (* const)`——指针常量指向一个整型变量，可改变指针指向的内容，但指针本身不可改变
      - const int * const：`(const int) (* const) `——指针常量指向整型常量
      - int const *const：`(int const) (* const)`——同上
    - 

20. C++有几种传值方式

    - 值传递：改变形参的值，不会改变实参的值
    - 引用传递：改变形参的值，会改变实参的值
    - 指针传递：如果指针的指向没有改变，改变形参的值，会影响实参的值

21. 使用指针的注意

    - 防止野指针：
      - 定义指针变量时，初始化为NULL
      - 申请内存后，判空
      - 释放内存后，置为NULL
    - 动态内存申请和释放必须配对，防止内存泄漏
    - 避免指针越界

22. 常量定义：const和define 

    - 生效阶段：const在编译阶段，define在预处理阶段

    - 内存占用：const定义的变量需要占用内存空间，define运行时是直接的操作数

    - 类型：const定义的变量时有类型的，而define无

    - ```c
      #define PI 3.1415
      const float pi=3.1415
      ```

23. 



## 1.2 C++内存

1. [堆和栈的区别](https://blog.csdn.net/mynameisJW/article/details/105150558)
   - 是什么，生长方向，生长空间大小，管理方式，分配方式，分配效率，存储内容，生命周期
   - 数据结构：栈是一种**线性数据结构**，遵守FILO的规则，而堆是一种非线性的**完全二叉树**
   - 生长方向：堆生长方向向上，内存地址由低到高，栈的生长方向向下，内存地址由高到低。
   - 空间大小：每个进程拥有的栈空间要远远小于堆的大小，64bits windows默认栈是1M，64bits linux默认10M，而可申请的堆理论大小是虚拟内存的大小
   - 管理方式：栈由操作系统自动分配和释放，堆的分配释放由开发者控制，容易产生内存泄漏。
   - 分配方式：
     - 静态分配：开辟的空间大小固定，
     - 堆只能动态分配，栈动态和静态分配都有。
     - 静态分配是由操作系统完成的，比如局部变量的分配。
     - 堆的动态分配由malloc或new函数进行分配，须手动free和delete。栈的动态分配不同于堆，**栈中动态分配内存**的函数`alloca`，用法与malloc，但不用free，由操作系统自动释放。
   - 分配效率：
     - 栈由操作系统自动分配，会在硬件层级对栈提供支持：提供专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，效率高
     - 堆则由C/C++提供库函数或运算符来完成管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片，效率低。
   - 存放内容:
     - 栈存放函数变量、参数、地址、寄存器内容
     - 堆一般存放对象，具体内容由开发者填充
   - 生命周期：栈短堆长，栈中存储的数据随函数执行完成而结束，系统自动释放空间。而堆如果不手动释放，其生命周期等同进程生命周期
2. [C++内存管理](https://blog.csdn.net/weixin_41055260/article/details/118981630?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-118981630-blog-124414552.pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3)
   - 内存管理（分配方式）机制：分为5个区，栈区，堆区，自由存储区，静态存储区，常量区，代码区。
     - 栈区：存放函数内的局部存储单元
     - 堆区：由new分配的内存块，需要delete释放
     - 自由存储区：由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。（在C里面，这就是堆）
     - 静态存储区：存放全局，静态变量
     - 常量存储区：存储的是常量，不允许修改
     - 代码区：存放可执行的机器码
   - 内存泄漏机制：
     - 内存泄漏：程序在申请内存后，忘记释放已申请的空间，占用有用内存，最终导致内存溢出。
     - 泄漏分为两类：
       - 堆内存泄漏：堆上申请资源后，使用结束后，未释放
       - 资源泄漏：通常指系统资源，比如socket，文件描述符等。因为这些在系统中都是有限的，创建而不释放，系统资源会耗尽
     - 产生方式分类：
       - 常发性内存泄漏：每执行一次，就会造成一次泄漏
       - 偶发性内存泄漏：特定场景下执行，就会一次泄漏
       - 一次性内存泄漏：造成泄漏的代码只会被执行一次。
       - 隐式内存泄漏：不停分配内存。
     - 泄漏的场景：
       - new和malloc申请资源使用后，没有用delete和free释放；
       - 子类继承父类时，父类析构函数不是虚函数。
       - Windows句柄资源使用后没有释放。
     - 怎么检测（避免）内存泄漏：
       - 申请和释放一定要成对存在
       - 分配的内存的指针以链表形式管理，使用完成后从链表中删除，程序结束时检查链表中的指针是否都得到了释放。
       - 使用智能指针
       - 一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。
   - 内存回收机制
     - 垃圾回收技术所解决只有两个问题：
       - 如何识别当前内存中未被引用的内存块
       - 如何将失去管理的内存进行回收
     - 引用计数：除内存块外增加一个引用计数，当内存块被引用，计数加1，当内存块失去引用，计数减1，同时检查引用计数，如果为0，就销毁释放内存
     - 标记清除：垃圾回收器扫描所有内存块，将被引用的内存块进行标记，标记完成后，统一检测内存，将所有未被标记的内存块回收
   - 
3. [内存对齐](https://blog.csdn.net/qq_39397165/article/details/119745975)
   - 由于CPU对内存的访问不是随机的，而是在特定地址或字长的整数位置访问内存，所以对数据的存储要按照一定的空间规则，使CPU对一个数据单元访问的次数尽量小，这就是内存对齐。
4. C++程序启动过程
   - 操作系统首先创建相应的进程并分配私有的进程空间，操作系统的加载器负责把可执行文件的数据段和代码段映射到进程虚拟内存空间。
   - 加载器读入可执行程序的导入符号表，根据这些符号可以查找出该可执行程序的所有依赖的动态链接库。
   - 加载器针对该进程的每个动态链接库，调用LoadLibrary
     - 查找动态库文件，读入动态链接库，调用动态链接库初始化应用程序的函数
   - 初始化应用程序的全局变量，对于全局对象自动调用构造函数
   - 进入应用程序入口点函数开始执行
5. 

## 1.3 面向对象

1. 三大特征：

   - 封装：将数据和操作数据的方法进行有机结合，加以权限区分，隐藏对象的属性和实现细节，仅对外公开部分函数，来和对象进行交互。
   - 继承：利用已有类定义新类，新类可以使用和扩展已有类的功能。
     - 三种继承方式：public，private，protected（父类成员权限被继承方式限制）
     - 构造函数，析构函数，operator=，都不能继承（子类不会复制父类的函数，类的函数，只有一份，为所有对象共享，包括子类对象），对象的空间计算包含：对象的父类和本身的非静态属性。
   - 多态：
     - **同一类型的多个实例，在执行同一方法时，呈现出多种行为特征——多态**
     - 静态多态（编译时多态）：重载，重定义（子类重新定义父类的非虚函数，覆盖）
     - 动态多态（运行时多态）：重写（子类重写父类虚函数）
       - 协变（子替代父）是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针。
       - 不变（两个毫不相关的类，不能相互替代），协变（子替代父），逆变（父替代子）
   - 

2. C++的重载和重写

   - 重载：同一作用域，同名函数，参数的顺序、个数、类型不同 都可以重载。（返回值类型不同不能作为重载的条件）
     - 采用命名倾轧技术，重载函数在编译时，会将参数类型的首字母作为函数名的一部分，以此来区分重载的多个函数。
   - 重写：子类重写父类的虚函数，返回值类型、函数名，参数顺序，个数，类型都必须一致。
     - 在基类的函数前加virtual修饰，在子类中重写该函数，运行时将会根据对象的实际类型调用相应的函数
     - 采用虚函数动态绑定原理，
       - 当声明父类一个函数为虚函数时，就会为这个类声明一个虚函数指针vfptr，这个指针指向一个虚函数表vftable，表里记录这虚函数的入口地址。
       - 当子类继承父类时，会继承这个vfptr和vftable，当子类重写了父类虚函数的同时，通过vfptr找到vftable，修改这个函数对应的入口地址为子类的函数地址。
       - 当父类指针指向子类的空间时，本质上还是调用父类的那个函数，当调用父类的那个函数时，发现此函数是一个虚函数指针，通过这个指针找到这个vftable，从而找到子类函数的入口地址，间接调用了子类函数
   - 重定义：子类重定义父类的同名函数（非虚），参数的顺序，个数，类型可以不同。

3. C实现函数重载

   - C不允许函数同名，因为编译时，同名函数名都是一样的

   - 采用函数指针，将一个函数的一个参数类型定义为函数指针，其他参数为这个函数指针的参数

   - 使用可变参数函数（stdarg.h，val_list类型和三个宏函数va_start，va_arg，va_end）

   - [gcc内置函数](https://www.it1352.com/1987845.html)可以实现函数重载

   - ```c++
     // 函数指针实现函数重载
     #include<stdio.h>
     
     typedef void (*ptr)(void *); //typedef申明一个函数指针
     
     void func_int(void * a){
     	printf("%d\n",*(int*)a); //输出int类型，注意 void * 转化为int
     }
     void func_double(void * b){
     	printf("%.2f\n",*(double*)b);
     }
     
     void c_func(ptr p,void *param){
     	p(param); //调用对应函数
     }
     
     int main(){
     	int a = 23;
     	double b = 23.23;
     	c_func(func_int,&a);
     	c_func(func_double,&b);
     	return 0;
     }
     
     // 可变参数实现函数重载
     #include<stdarg.h>
     int fun(int n, ...){
         //1. 在函数中创建一个va_list类型的变量
         val_list ap;
         //2. 初始化一个参数列表
         va_start(ap,n);
     //    for(int i = 0;i < n; i++){
     		//3.访问参数列表的内容
         	va_arg(ap,int);
     //    }
     	//4. 清理
         va_end(ap);
     };
     ```

   - 

4. 仿函数

   - 重载了operator()的类，其对象称为函数对象，是行为类似函数的对象，也叫仿函数
   - 它是一个类的实例，而不是函数。
   - 超出普通函数概念，可以拥有自己的状态。
   - 函数模板使得函数对象的通用型更好，这也是它的优点之一。

5. 类 方法和数据 的权限

   - public：类的实例可以**直接访问**
   - protected：允许本类及子类的**成员函数可以访问**
   - private：允许本类的成员函数可以访问。

6. 派生类的继承方式（权限）影响对父类成员的访问。

   - 继承方式（权限）会限制对父类成员的访问权限，继承权限大的不会影响访问权限小的父类成员，继承权限小的会缩小访问权限大的父类成员至继承权限。

7. 构造函数的种类

   - 默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数，转换构造函数。
   
   - 默认构造函数（无参构造）和初始化构造函数（有参构造）
   
     - 在定义对象时，完成对象的初始化工作，
   
     - 定义了有参构造，编译器不再提供无参构造
   
   - 拷贝构造函数
   
     - 完成对是整个对象的拷贝，旧对象和复制构造的对象各自占有不同的地址，但同样大小的堆内存。
     - 拷贝构造的形参是一个左值引用。
     - 三种情况被调用：
       - **旧对象初始化（构造）新对象**，记得是初始化，而不是赋值（=），如果等号的左边是一个已定义的对象，那么就不会发生拷贝构造
       - 函数的参数是对象，而非对象的引用。在调用函数的时候，会发生拷贝构造
       - 函数的返回值是对象，而非对象的引用。在调用函数并执行返回的时候，会发生拷贝构造。所以**引用可以大大减小拷贝构造开销**
   
    - 移动构造函数：**右值（临时（匿名）对象、不可寻址的字面常量）初始化新对象时**（C++11）
   
      - 生成一个指针指向源对象地址，接管源对象的内存。
   
      - 移动构造的形参是一个右值引用。
   
   - 转换构造函数：通过利用单参数的构造函数（转换构造）可以隐式转换  参数类型对象  为本构造对象，再配合相应的运算符重载，完成相关运算。
   
     - 类型转换函数：将本对象隐式转换为其他类型对象，完成相应的计算。
   
     - 写法：1. operator修饰函数名，函数名称为要转换的类型 2.函数无形参

8. 拷贝构造和移动构造的区别

   - 形参：拷贝是左值引用，移动是右值引用
   - 拷贝是对整个对象的拷贝，移动是生成一个指针指向源对象的地址，接管源对象。

9. 拷贝构造参数是什么传递方式，为什么

   - 引用传递方式
   - 如果是传值，传值的方式会调用该类的拷贝构造，从而造成无穷递归调用拷贝构造

10. 空类默认有哪些函数

    - 默认构造，拷贝构造，重载赋值，析构

11. 多重继承下的构造和析构

    - 父类构造函数–>成员类对象构造函数–>自身构造函数
    - 其中成员变量的构造与在当前类声明顺序有关，父类构造函数的调用顺序是当前子类继承列表中的顺序。（与当前子类初始化列表顺序无关）
    - 析构顺序和构造顺序相反。

12. 类型转换

    - 上下行转换：
      - 上行转换：父类指针指向子类空间，不会造成内存越界，安全
      - 下行转换：子类指针指向父类空间，可能会造成内存越界，不安全
    - C++提供四种类型转换
      - static_cast：用于基类与派生类之间的指针或引用转换
      - dynamic_cast：用于类层次的上行转换
      - const_cast：用于将const修饰和非const修饰的对象之间的转换
      - reinterpret_cast：重新解释类型转换（可用于无关类之间的转换）

13. 深拷贝和浅拷贝

    - 浅拷贝：将原对象的引用直接赋值给新对象，新对象只是原对象的一个引用
    - 深拷贝：开辟一个和原对象一样的空间，创建一个新的对象，把原对象属性的“值”拷贝一份，是值而不是引用。（如果这个值是对象，那就还需迭代开辟空间）

14. 常函数

    - 类的成员函数后边被const修饰，被称作常函数。
    - 常函数体内不可修改对象中任何非静态成员变量，但是可以修改静态成员变量和mutable修饰的成员变量。
    -  const修饰的实例对象 可以调用const 成员函数，而不能调用非const修饰的函数（因为非const修饰的函数可能会修改原对象里的非静态成员变量）。正如非const类型的数据可以给const类型的变量赋值一样。

15. 菱形继承

    - 孙子类的多个父类有共同的祖先
    - 孙子类及其派生类会拥有多份公共的数据，当孙子类及其派生类访问这份公共数据时，出现二义性，而出错

16. 虚继承

    - 在继承方式前加virtual修饰，子类虚继承父类，子类只会保存一份公共数据。
    - 虚继承解决 菱形继承中，多份公共祖先数据的问题。

    ```c++
    class Animal1 {
    public:
    	int data;
    };
    class Sheep1 : virtual public Animal1 {};
    class Tuo1 : virtual public Animal1 {};
    
    class SheepTuo : public Sheep1, public Tuo1 {};
    ```

    

17. 多态

    - 同一个类型的不同实例，在执行同一方法时，呈现出多种行为特征。
    - 除了虚函数（动态多态，运行时）可以实现多态， 还有函数重载（静态多态，编译时）可以实现多态。

18. 为什么要虚析构，而不能虚构造

    - 虚析构：
      - 虚析构：析构函数被virtual修饰
      - 通过父类指针 释放整个子类空间，防止内存泄漏。原理：vfptr，通过vftable，找到虚析构函数，而这个析构函数实际指的是子类的析构函数，子类析构之后，会自动调父类的析构函数。
    - 虚构造
      - 从功能上说：虚函数是用来实现多态的，也就是对象的动态行为，而构造函数的作用是提供初始化，在对象的生命周期只执行一次，不是对象的动态行为，没有必要用虚函数。
      - 构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用

19. 哪些函数不能是虚函数

    - 普通函数（非成员函数）：只能被重载，不能被重写。
    - 构造函数：执行初始化行为，而不是对象的动态行为。自动调用，而不是通过父类指针或引用去调用
    - 三个修饰符修饰后，不能再被virtual修饰：
      - inline修饰：内联成员函数、编译时被展开，而虚函数是运行时动态绑定函数
      - static修饰：静态成员函数、属于一个类，而非某个对象，没有this指针，无法进行对象的判别
      - friend修饰：友元函数、无法继承，所以没有虚函数的说法。

20. 虚函数表里存放的内容？什么时候写进去的？

    - 存储虚函数地址的数组，存放该类重写的及父类未被重写的所有虚函数入口地址。
    - [虚表写入时机](https://blog.csdn.net/weixin_43919932/article/details/104356460)：分配内存空间后，调用构造函数前。

21. 构造函数中能不能调用虚函数

    - 语法上讲：调用完全没有问题
    - 从效果上讲：不能达到多态的效果，
      - 因为派生类对象构造期间（父类构造函数在派生类构造之前调用），派生类还没完全创建，此时它当做一个父类对象，
      - 同样，进入基类析构函数时（子类析构函数在父类析构之前调用），对象也是基类类型。
    - 基类中声明纯虚函数并且在基类的析构函数中调用，编译器会报错。
      - 如果在**基类构造函数中调用虚函数**被解析成**调用派生类的虚函数**，而**派生类的虚函数中又访问到未初始化的派生类数据**，这是危险的，将会导致程序出现未知行为及bug。

22. 虚函数与纯虚函数的区别

    - 作用方面：
      - 虚函数的作用主要为了实现多态。
      - 纯虚函数的作用主要是为了实现一个接口，用来规范派生类的行为。
    - 可以同时定义一个类中，都可以被重写，以多态的形式被调用。
    - 含有纯虚函数的类被称为抽象类，只含有虚函数的类不能被称为抽象类；
    - 虚函数在基类中已定义，而纯虚函数在基类中仅仅只声明。虚函数可以直接被使用，因为在父类中有函数体，也可以被子类重写，以多态的形式调用。而纯虚函数必须在子类中实现，因为纯虚函数在父类中没有函数体。
    
24. 含有纯虚函数的类能实例化吗？它的派生类要必须重写纯虚函数吗？

    - 含有纯虚函数的类被称为抽象类，抽象类不能实例化对象。在底层，拥有虚函数都有一个vftable，纯虚函数的对应的函数入口地址为0，也就是指向一个不存在的函数，由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能实例化对象。
    - 抽象类的派生类必须重写所有纯虚函数，否则依然是一个抽象类，抽象类不能实例化对象。
    - 定义纯虚函数是为了实现一个接口，用来规范派生类的行为。

25. 抽象类

    - 抽象类：有**纯虚函数**的类
    - 纯虚函数：函数原型后加“=0”
    - 特点：
      - 抽象类只能用作其他类的基类，不能建立抽象类对象。
      - 抽象类不能用作函数的返回值类型，参数类型或显示转换的类型
      - 可以定义指向抽象类的指针和引用，指针可以指向它的派生类，继而实现多态

25. 类模板和模板类的区别

    - 类**模板**是一个模板的定义，**含有通用类型参数的类定义**，可以看作是做蛋糕的模具

    - 模板**类**：**类模板中通用类型具体化后的类**，可以看作是通过蛋糕模具做出来的蛋糕。

    - ```c++
      // 类模板
      template<class T1, class T2>
      class Data{}
      
      // 模板类
      Data<int, float>
      ```

27. 函数模板

    - 会编译两次：在编译时编译，在调用处类型具体化后的编译
    - 每使用一次函数模板（模板的类型不同的话），都会产生一个新的函数空间

28. 

## 1.4 STL

1. STL基本组成部分

   - 广义上来讲分三类：容器，迭代器，算法，容器和算法之间通过迭代器进行无缝衔接。

   - 详细来说有六类：容器，迭代器，算法，仿函数，适配器，空间配置器
   - 容器（container）：是一种数据结构，用来存放对象的模板类，为了访问容器内的数据，可以通过容器类提供的迭代器
   - 算法（algorithm）：操作容器中数据的函数模板，函数本身与操作的数据的结构和类型无关。
   - 迭代器（iterator）：提供访问容器中对象的方法。事实上，指针也是一种迭代器，迭代器也可以是那些定义了operator*()以及其他重载了指针的操作符方法的类对象，类模板;
   - 仿函数（functor）：又称函数对象，重载了"operator()"的类，它是一个类，不是一个函数，可以拥有自己的状态
   - 适配器（adapter）：简单来说是一个接口类，专门用来修改现有类的接口，提供一种新的接口，或调用现有函数来实现某种功能。主要包含三类：容器适配器，迭代器适配器，函数适配器。
   - 空间配置器（allocator）：为STL提供空间控制系统，主要包括两部分：对象的创建和销毁，内存的获取与释放

2. STL中常见的容器

   - 分为三类：顺序容器，关联式容器，容器适配器
   - 顺序容器
     - 容器并非排序的，元素插入位置同元素值无关。包含vector，deque，list
     - vector：单端动态数组，内存连续，存取常数时间，在尾端增删元素具有较佳性能
     - deque：双向队列。内存连续，存取常数时间（仅次于vector），在两端增删元素具有较佳性能
     - list：双向链表，内存不连续。任何位置增删常数时间。不支持随机存取。
       - 还有forward_list——单向链表，链表中的节点只能向后搜索，支持前向迭代器。
   - 关联性容器
     - 有序关联：set、multiset、map、multimap，支持双向迭代器
       - 元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；查找性能高；通常以**平衡二叉树（红黑树）**的方式实现。
     - 无序关联：unordered_set/unordered_multiset，unordered_map/unordered_multimap，支持前向迭代器，
       - 元素无序，按**哈希表**存放，查找速度比有序关联的快。
   - 容器适配器（不支持迭代器）：封装了一些基本的容器，底层可能是序列容器或者链表。
     - stack：默认的底层容器是deque，FILO
     - queue：默认的底层容器是deque，FIFO
     - priority_queue：内部元素按照有序堆（大顶堆降序、小顶堆升序）进行存放，按优先级执行，高级先出，同级才FIFO

3. STL中map、unordered_map、deque、list的实现原理

   - map：红黑树（非严格平衡二叉搜索树）
     - map内部实现了红黑树，它有自动排序功能，树的每个节点都代表map的一个元素，因此对map的增删查等操作就是对红黑树的操作。由于map中的元素是按照二叉树存储的，所有左子树的所有节点都比根节点小，右子树都比所有根节点大，使用树的中序遍历，可将键值按照从小到大遍历出来。
   - unordered_map：hashtable，散列表
     - 采用函数映射思想将元素的存储位置和元素的关键字联系起来，它能快速的定位到想要查找的元素，而不是依靠元素的关键字进行比较来进行查找
   - deque：双向队列
     - 内部实现了一个双向队列，元素在内存连续存放，随机存取常数时间，两端增删性能较优
   - list：双向链表
     - 内部实现的是一个双向链表，内存不连续，任意位置增删常数时间，不支持随机存取，访问第i个元素都需从头挨个遍历到第i

4. 介绍一下STL空间配置器

   - 程序包括数据结构和算法，而数据结构作为存储数据的组织形式，与内存分配有着密切的联系，在C++ STL中，空间配置器便是用来实现内存空间分配的工具。每一种空间的分配都是通过空间配置器来实现。
   - 空间配置器没有简单采用new和delete的方式，而是采用了一个高效的方式。
   - 首先把对象构造始末分成了空间配置和对象构造两部分，
     - 空间配置：内存配置allocator，内存释放deallocator
     - 对象构造：构造construct，释放destroy
   - 对于内存空间的配置，SGI STL采用类两级结构：
     - 一级空间配置器：管理大块内存
       - 对malloc和free进行了封装，同时增加了申请空间失败抛出异常机制
       - 主要作用：向操作系统申请内存，申请失败抛异常
     - 二级空间配置器：管理小块内存
       - 采用内存池来提高申请空间速度和减少额外空间的浪费，在内存池内又采用哈希桶来提高获取空间的速度和高效管理（但增加了内存碎片），也有在内存池内采取链表的形式来管理，可是获取空间的速度不高。

5. 各种容器的时间复杂度

   |      | vector<br />（单端数组） | deque<br />(双向队列) | list<br />（双向链表） | map/multi~<br />set/multi~<br />（红黑树） | unordered_map/~_multimap<br />unordered_set/~_multiset<br />（散列表） |
   | ---- | ------------------------ | --------------------- | ---------------------- | ------------------------------------------ | ------------------------------------------------------------ |
   | 插入 | O(N)                     | O(N)                  | O(1)                   | O(logN)                                    | O(1)，最坏O(N)                                               |
   | 查看 | O(1)                     | O(1)                  | O(N)                   | O(logN)                                    | O(1)，最坏O(N)                                               |
   | 删除 | O(N)                     | O(N)                  | O(1)                   | O(logN)                                    | O(1)，最坏O(N)                                               |

6. 迭代器什么时候失效（STL怎么删除元素）

   - 对于顺序容器的vector、deque来说，使用erase后，后面每个元素的迭代器都会失效，后面每一个元素都会往前移动一位。erase返回下一个有效迭代器。
   - 对于关联容器map、set来说，使用了erase后，当前元素的迭代器会失效，但其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调erase方法之前，记录下一个元素的迭代器即可
   - 对于list来说，它使用了不连续的内存，并且erase会返回下一个有效的迭代器，因此上面两种方式都可用。

7. 迭代器的作用，有指针为什么还要迭代器

   - 用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
   - 作用：
     - 用于指向顺序容器和关联容器中的元素
     - 通过迭代器可以读取它指向的元素
     - 通过非const迭代器还可以修改其指向的元素
   - 迭代器不是指针，是类模板，表现的像指针，他只是模拟了指针的一些功能，重载了指针的一些操作符。本质是封装了原生指针。
   - 迭代器返回的是对象的引用而不是对象的值。

   ```c++
   int main() {
   	vector<int> v; //一个存放int元素的数组，一开始里面没有元素
   	v.push_back(1);
   	v.push_back(2);
       v.push_back(3);
       v.push_back(4);
   	vector<int>::const_iterator i; //常量迭代器
   	for (i = v.begin(); i != v.end(); ++i){ //v.begin()表示v第一个元素迭代器指针，++i指向下一个元素
           cout << *i << ","; //*i表示迭代器指向的元素
           cout << endl;
       }
   	vector<int>::reverse_iterator r; //反向迭代器
       for (r = v.rbegin(); r != v.rend(); r++){
           cout << *r << ",";
           cout << endl;
       }
       vector<int>::iterator j; //非常量迭代器
       for (j = v.begin();j != v.end();j++){
       	*j = 100;
       }
       for (i = v.begin();i != v.end();i++){
       	cout << *i << ",";
       }
   return 0;
   }
   /*
   运行结果：
   1,2,3,4,
   4,3,2,1,
   100,100,100,100,
   */
   ```

8. 迭代器分类

   - 输入迭代器（读），输出迭代器（写），前向迭代器（读写，只是单向遍历），双向迭代器（双向遍历），随机访问迭代器
   - 容器支持情况：
     - vector，deque：随机访问迭代器
     - list，map，multimap，set，multiset：双向迭代器
     - forward_list，unordered_map，~set，~multimap，~multiset：前向迭代器
     - stack，queue，priority_queque：不支持迭代器

9. STL 中resize和reserve的区别

   - size和capacity
     - size：容器中元素的个数
     - capacity：容器的容量，拥有capacity属性的容器只有vector和string。
   - resize
     - resize(num)：重新指定容器size为num，容器原有个数大于num直接截断，容器原有个数小于num，增加新位置并以默认值填充新位置
     - resize(num)的作用：size变成指定的num，capacity视情况变化，
       - num<capacity，capacity不变
       - num>capacity，capacity变得大于等于num
   - reserve
     - 预留容器空间
     - reserve(num1)的作用：不改变size，capacity视情况变化，
       - num1>size，capacity置为num1
       - num1<size，capacity不变

10. STL 动态链接可能产生的问题

    - 给动态库函数传递容器对象本身，可能会出现**内存堆栈破坏**的问题
    - 容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。

11. map和unordered_map的区别，底层实现

    - map元素排列有序，unordered_map无序，归根结底是底层实现不同。
    - map内部实现了一个红黑树，红黑树有自动排序功能
    - unordered实现了一个hash表，采用函数映射思想将元素的存储位置和元素的关键字联系起来

12. hash冲突的解决办法

    - 由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。
    - 开放寻址法、链地址法（拉链法）、再哈希法、建立公共溢出区
    - 开放寻址法：当一个地址冲突后，在寻找一个空闲地址存放该元素
    - 链地址法：地址存放的是冲突链元素的首地址，这个地址后代表一个链表，由冲突元素组成的链表
    - 再哈希法：同时构造多个不同的哈希函数，一个哈希得出的地址冲突，则换用第二个hash计算
    - 建立公共溢出区：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

13. vector和list区别，应用场景

    - vector：是一个单端动态数组，内存连续，支持随机存取，插入删除数据和扩容开辟空间比较麻烦，适用于高效访问的场景。
    - lsit：是一个双向链表，内存不连续，支持任意位置插入删除，适用于高效插入和删除的场景

14. vector实现原理

    - 底层实现原理为一维数组，内存连续
    - 新增时：
      - 如果数组已满，则需要另辟更大的空间，复制原数据，然后再新增和插入
      - 在尾端新增，很简单
      - 通过迭代器在中间插入数据，需要当前迭代器后面的所有元素向后移动一位，腾开一个位置给这个新插入的数据
    - 删除时：
      - 在尾端删除pop_back很简单
      - 通过迭代器在中间删除，当前迭代器后面的所有元素向前移动一位，尾端多出的空间空闲在那，不释放。

15. push_back和emplace_back的区别

    - 传匿名对象或旧对象时，二者效率相同，会先调构造，再调移动构造
    - 传单构造参数时，emplace_back效率高，都会调构造，但emplace_back不会调用移动构造

16. 

## 1.5 新特性

1. c++11新特性

   - 统一初始化形式，还提供了模板类initializer_list
   - 成员变量默认初始化：构建一个类的对象不需要用构造函数初始化成员变量。
   - auto关键字：用于定义变量，编译器可以自动判断的类型，定义时必须初始化，否则无法推导类型
   - decltype(exp)：根据exp表达式来推导类型，定义时可不必初始化，因为变量的类型和左值右值没有关系，类型由exp决定。
   - 智能指针：shared_ptr，weak_ptr（配合shared_ptr解决循环引用的问题），unique_ptr
     - 作用：免去手动释放内存、避免try catch异常去手动释放内存。
     - shared_ptr：多个指针指向相同的对象，使用引用计数来释放内存。避免同一指针初始化多个shared_ptr，因为这样可能造成二次释放。
     - weak_ptr：没有共享资源，它的构造不会引起指针引用计数的增加，检测资源使用情况，解决shared_ptr相互引用时的死锁问题。
     - unique_ptr：不能赋值，不能拷贝
   - 空指针nullptr：nullptr_t类型的右值常量，专用于初始化空类型指针。依据nullptr 我们也可以创建属于自己的空指针对象
   - 右值引用和move语义 让程序员有意识减少进行深拷贝操作
   - 增加stl模板类：无序关联容器unordered_map/~multimap，~set/~multiset
   - 正则表达式，实质是一个字符串，该字符串描述了一种特定模式的字符串
   - Lambda表达式：最简：`[捕获上下文列表](参数列表){函数体}`，底层实现是一个匿名对象。
   - 可变参数模板
   - 原子操作：
     - 在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。

   ```c++
   // 统一初始化形式
   int a{1};//等价int a(1);，等价int a=1;
   int b{2+2};
   	//c++11后
   Student stu{ 1,85.5f,"qqq" };//结构体
   Data d{1,1.2};//自定义对象
   
   // 成员变量默认初始化
   class Data {
   public:
   	int a = 1;
   };
   
   // auto
   auto var = 55; 
   vector< vector<int> >::iterator i = v.begin();// 类型太长时，可以不用写，用auto代替
   auto i = v.begin();
   
   // decltype
   decltype<1+1> a;
   a = 100;
   sizeof(decltype(1+1.5));
   ```

   

2. 

# 2 操作系统

1. 常用的linux命令

   - 文件权限：chmod
   - 文件与目录管理：
     - 目录：cd/pwd
     - 文件：touch/rm/mv/cp
   - 文件压缩与备份：
     - 压缩：tar/gzip/zip
     - 备份：dump/restore
   - 用户管理：
     - su/useradd/userdel/usermod
   - 例行工作：
     - 突发性：at
     - 例行性：crontab/anacron(任务补漏)
   - 程序管理：
     - 工作管理：jobs(查看后台工作情况)/fg/bg/nohup(脱机管理)
     - 进程管理：ps(当前进程情况)/top(持续检测)/kill/free(资源查看)
   - 服务管理
     - stand alone（自行单独启动的服务daemon）：service
     - super daemon（由super daemon来统一管理的服务daemon）：xinted
   - 软件安装：
     - yum/apt-get

2. 文件权限修改chmod

   - `chmod nnn file_name`

3. 如何以root权限运行某程序

   ```bash
   sudo chown root filename
   sudo chmod u+s filename # 就是给某个程序的所有者以suid权限,可以像root用户一样操作。
   ./filename
   ```

## 内存管理

1. 软连接和硬链接

   - 文件系统将文件数据分为两个部分：文件权限和属性、文件内容
   - 文件权限和属性，存放在inode中，文件内容存放在data block中，inode有指向datablock的指针
   - 定义上：
     - 软连接又叫符号链接，这个文件的文件内容里包含了另一个文件的路径名，相当于**具有快捷方式功能的文件**。
     - 硬连接就是**一个文件的一个或多个多件名**，
     - ![](./legend/连接文件.png)
   - 限制上：
     + 硬链接只能对同一文件系统下的文件进行链接
     + 软连接可以跨文件系统，对文件和目录都可以链接
   - 操作上：
     - 修改：通过链接来编辑文件，都会导致源文件爱被修改
     - 删除：
       - 当指向inode的硬链接（所有文件名的都是硬链接）数目为0的时候就会删除源文件本身。
       - 软链接是本身就是一个文件，你删除了就删除了软链接本身，不会对源文件造成影响。但如果源文件被删除，这个软链接就成了死链接，如果恢复源文件，那这个软链接也可恢复。

2. 动态库和静态库的制作，及区别

   ```bash
   # 静态库制作
   # 1.编译生成.o文件
   gcc -c add.c
   gcc -c sub.c
   # 2.由.o文件生成静态库，使用ar（archive 归档）工具，r——replace，c——create
   ar -rc libcal.a add.o sub.o # 库名称cal，lib是它的前缀，.a是它的后缀
   # 3.整理liccal.a和add.h，sub.h到一个文件结构下，供他人使用
   mkdir -p mathlib/lib
   mkdir -p mathlib/include
   cp *.a mathlib/lib
   cp *.h mathlib/include
   
   #4.编译含有main函数的test.c文件，test.c中用到了add.h的函数
   gcc test.c -I ./mathlib/include -L ./mathlib/lib -l cal -o mytest
   # I——include，L——library 路径，l——库名称
   
   #5.运行可执行文件
   ./mytest
   
   # 动态库制作
   # 1.编译生成位置无关的.o文件
   gcc -fPIC -c add.c
   gcc -fPIC -c sub.c
   # 2.由.o文件生成共享库格式的动态库
   gcc -shared -o libcal.so add.o sub.o
   # 3.整理库结构，同上
   # 4.编译含有main函数的test.c文件
   gcc test.c -I mlib/include/ -L mlib/lib/ -l cal -o mytest
   # 5.告诉操作系统运行时在哪找动态库
   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/mylib/lib/
   # 6.运行可执行文件
   ./mytest
   ```

   - 区别：
     - 静态库代码装载速度快，执行速度也比动态库快
     - 动态库更加节省内存，可执行文件体积比静态库小很多
     - 静态库在编译时加载，动态库是在运行时加载
     - 生成静态库，windows是.lib，linux是.a。生成动态库，windows是.dll，linux是.so
   - 

3. LRU算法及其实现方式

   - LRU（Least Recently Used）算法：用于缓存淘汰，思路是将缓存中最近最少使用的对象删除掉

   - 实现方式：利用链表和hashmap

     - 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。
     - 如果命中，则移至头部，如果未命中，则创建在头部，链表最后一个节点即为最久未访问数据

   - ```c++
     class LRUCache {
     	list<pair<int, int>> cache;//创建双向链表
     	unordered_map<int, list<pair<int, int>>::iterator> map;//创建哈希表
     	int cap;
     public:
     	LRUCache(int capacity) {
     		cap = capacity;
     	}
     	int get(int key) { 
             if (map.count(key) > 0){
                 auto temp = *map[key];
                 cache.erase(map[key]);
                 map.erase(key);
                 cache.push_front(temp);
                 map[key] = cache.begin();//映射头部
                 return temp.second;
             }
             return -1;
     	}
         void put(int key, int value) {//添加数据
             //如果查询到链表里有这个数据，则删除；这个if{}里的和else if{}后面的内容和get方法内容相似
             //都为的是将历史同样数移至链表头部
             if (map.count(key) > 0){
                 cache.erase(map[key]);
                 map.erase(key);
             }
             else if (cap == cache.size()){//这里是查询链表是否已满，如果满，则删除链表尾部数据
                 auto temp = cache.back();
                 map.erase(temp.first);
                 cache.pop_back();
             }
             cache.push_front(pair<int, int>(key, value));
             map[key] = cache.begin();//映射头部
         }
     };
     
     int main(){
         LRUCache* obj = new LRUCache(capacity);
     	//访问查询数据
         int param_1 = obj->get(key);
         // 添加数据
         obj->put(key,value);
     }
     ```

4. 一个线程占多大的内存

   - linux中大概8M

5. 虚拟内存和物理内存

   - 物理内存：寄存器，高速缓存器，主存，磁盘。访问速度一次递减，访问容量依次增大。有一个专门的内存管理器记录内存的使用情况，完成分配和回收的工作。

     <img src="./legend/物理内存存储层次结构.png" style="zoom:50%;" />

   - 虚拟内存：操作系统为每一个进程分配一个独立的地址空间，它是虚拟的空间。虚拟内存与物理内存通过页表建立映射关系。

   - 早期内存分配方式存在的问题：

     - 进程地址空间不隔离，会导致数据被随意修改。
     - 内存使用效率低。
     - 程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。

   - 虚拟内存的优点

     - 扩大地址空间，每个进程占4G，真实物理空间并没有那么大
     - 内存保护，防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。
     - 内存共享，方便进程通信。
     - 可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。

   - 虚拟内存的缺点

     - 虚拟内存需要额外构建数据结构，占用空间。
     - 虚拟地址到物理地址的转换，增加了执行时间。
     - 页面换入换出耗时。
     - 一页如果只有一部分数据，浪费内存。

6. 什么是页表

   - 操作系统虚拟内存到物理内存的映射表，就被称之为页表
   - 如果虚拟内存的每个字节都对应到物理内存上，那么这张表将大得真正的物理地址也放不下。于是操作系统引入页（page）的概念。
   - 在64位的操作系统中，虚拟内存每页的大小为4kbyte（物理内存的页框大小同样），即2*12次方，需要12位来表示页内的所有地址（页内偏移最大为2^12）,如果用64位中的48位来表示虚拟地址，48位的低12位用来记录数据在页内的地址，高36位用来表示页码（页号）
   - 系统在启动时，操作系统将将整个物理内存以4K为单位，划分为各个页，之后进行内存分配时，都以页为单位，那么虚拟内存页到物理内存页框的映射表就大大减小，4G内存只需要8M大小的页表就可以映射。

7. 缺页，缺页异常，缺页中断

   - 缺页：一个程序被加载运行时，只是加载了很少一部分到内存，另外一部分在需要时再从磁盘载入，被加载到内存的部分标识为“驻留”，而未被加载的部分标识为“未驻留”，当操作系统根据需要读取虚拟地址表，如果读取到虚拟地址表中记录的地址为“未驻留”，表示这部分地址记录内存未被加载到内存，需要从磁盘读入，则这种情况就是缺页。
   - 缺页异常：malloc和mmap函数在分配内存时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常，引发缺页中断。
   - 缺页中断：缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

8. 虚拟地址到物理地址怎么映射

   - 操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表中的每一项都记录了这个页的基地址。
   - 三级页表转换 方法：
     - 逻辑地址转线性地址：段起始地址+段内偏移地址=线性地址
     - 线性地址转物理地址：每一个32位的线性地址被划分为三部分：页目录索引（DIRECTORY，10位）、页表索引（TABLE，10位）、页内偏移（OFFSET，12位）
       - 从cr3中取出进程的页目录地址（操作系统调用进程时，这个地址被装入寄存器中）
         - 页目录地址 + 页目录索引 = 页表地址
         - 页表地址 + 页表索引 = 页地址
         - 页地址 + 页内偏移 = 物理地址
   - ![](./legend/三级页表转换示意.jpg)

9. 堆栈溢出

   - 堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。
   - 本质上一种数据结构的满溢情况。
   - 堆溢出：假如不断的new，而不释放，最终导致堆内存不足，报OutOfMemory Error
   - 栈溢出：一次函数调用中，栈中将被依次压入：参数，返回地址等，而方法如果递归比较深或进去死循环，就会导致栈溢出。将会报错：StackOverflow Error。

10. 操作系统的malloc实现原理

    - 当开辟空间小于128kb时，调用brk函数。
      - brk是将数据段(.data)的最高地址指针_edata往高地址推
      - brk分配的内存需要等到高地址内存释放以后才  能释放
    - 当开辟空间大于128kb时，调用mmap函数，mmap分配的内存可以单独释放
    - malloc采用的是内存池的管理方式，先申请一大块内存作为堆区，然后将堆区分为多个内存块，采用隐式链表记录所有空闲块块，用户申请时，就分配一个空闲块。

11. mmap的原理和使用场景

    - mmap是一种**内存映射文件**的方法，即将一个文件或者其它对象映射到进程的地址空间（文件被映射到多个页上），实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。
    - 进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面（以文件格式当然看不懂指针到底写了什么进去）到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。
    - 相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。
    - ![](./legend/mmap.jpg)
    - 使用场景：
      - 对同一块区域频繁读写操作；（自己）
      - 可用于实现用户空间和内核空间的高效交互（内核与用户）
      - 可提供进程间共享内存及相互通信（用户与用户）
      - 可实现高效的大规模数据传输。（同步）

12. 进程空间从高位到低位都有什么

    - 内核空间：1G
    - 程序空间：3G，由高到低：环境变量，命令行参数，栈空间，共享区，堆空间，.bss(未初始化全局)，.data(已初始化全局)，代码段，受保护的地址。

    ![](./legend/进程空间.jpg)

13. 32位系统能访问4G以上的内存空间吗？

    - 正常情况下不可以，2^32次方等于4G，一个操作字长最多能到4G的空间。
    - PAE（physical address extension）技术，PAE最初是为了弥补32位地址在PC服务器应用上的不足而推出的，4GB普通桌面应用差不多够用，但对于服务器来说还是显不足，PAE技术将地址扩展至36位，系统能够容纳64G的内存。

14. 大小端

    - 字节序是指**多字节数据**的存储顺序。

    - 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，**和我们的阅读习惯一致**

    - 小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，

    - ```c++
      bool isLittleEndian(){
          unsigned short a = 0x1218;//0x表示这个数按照16进制数识别，一个数字占4bit，所以1218占用2byte
      
          if( (*(char*)&a)  == 0x12){//unsigned short占两个字节，而char占一个字节，所以可以取到低地址的一个字节
              return false;
          }else{
              return true;
          }
      }
      ```

15. C++如果运行程序后，报Segement fault（段错误），怎么定位

    - 一般在堆栈溢出时，会报segement fault。

    - 方式1：gdb core文件，麻烦一点

      ```bash
      $> gcc -g -o book book.c
      $> ./book.out
      段错误
      # 查看当前用户的所有限制情况
      $> ulimit -a
      core file size   (blocks , -c)  0
      # 可以看到此时用户的core文件的大小被限制为0，不能生成core文件
      $> ulimit -c 1000
      # 表示限制为1000kb
      # ulimit -c unlimited 设置core文件大小为不限制大小
      
      # 现在再去运行有段错误的book.out
      $> ./book
      段错误(吐核)
      # 现在就可以看到当前文件夹下生成了一个类似于core.19356的文件
      # centos8 core文件有变化，可以自行百度
      
      # 调试core文件
      $> gdb book core.19356
      
      # 从这里面调试可以看到在程序出错时（core dump时），程序的运行出错情况
      # bt，可以查看在core dump时，的程序调用栈情况
      ```

    - 方式2：使用execinfo.h里的backtrace函数及信号处理机制, 来让程序在发生段错误时自动打印调用堆栈。

16. c++内存泄漏怎么排查

    - [windows环境](https://blog.csdn.net/weixin_42364825/article/details/126571519)：LeakDiag，VLD
    - [linux环境](https://blog.csdn.net/qq_27399933/article/details/127190980)：valgrind，AddressSanitizer

17. 

## 进程

1. [linux内核态（系统态）与用户态，什么时候会进入内核态](https://blog.csdn.net/qq_41709234/article/details/124320482)

   - **内核态：**也叫**内核空间**，是内核进程/线程所在的区域。**主要负责运行系统、硬件交互。**
   - **用户态：**也叫**用户空间**，是用户进程/线程所在的区域。**主要用于执行用户程序。**
   - 区别：
     - **内核态：**运行的代码**不受任何限制**，CPU可以执行任何指令。
     - **用户态：**运行的代码需要受**到CPU的很多检查**，不能直接访问内核数据和程序，也就是说不可以像内核态线程一样访问任何有效地址。
   - 何时进入内核态：操作系统**在执行用户程序时**，主要工作在用户态，只有在其执行**没有权限完成的任务**时才会切换到内核态。
   - 为什么要区分这二态：保护机制。**防止用户进程误操作或者是恶意破坏系统。**
   - 用户态切换到内核态的方式：
     - 系统调用（主动）：由于用户态无法完成某些任务，**用户态会请求切换到内核态**，内核态通过为用户专门开放的中断完成切换。
     - 异常（被动）：在执行用户程序时**出现某些不可知的异常**，会从用户程序切换**到内核中处理该异常的程序**，也就是切换到了内核态。
     - 外围设备中断：外围设备发出中断信号，当中断发生后，**当前运行的进程暂停运行，**并由**操作系统内核**对中断进程处理，如果中断之前CPU执行的是用户态程序，就相当于从用户态向内核态的切换。

2. 并发和并行

   - 并发：单核CPU（单个处理器），在同一时刻只有一个进程在运行，多个线程的执行在不同时间片中。

   - 并行：多核CPU，多个处理器，同时处理多个进程。

   - 区别：

     - | 并发（时分复用）                     | 并行（空分复用）       |
       | ------------------------------------ | ---------------------- |
       | 多个事件（任务）在同一时间间隔发生。 | 多个事件同时发生       |
       | 在同一实体（处理器）上的多个事件     | 在不同实体上的多个事件 |

       <img src="./legend/并行与并发.png" style="zoom:80%;" />

3. 进程，线程，协程

   - 进程：

     - 是程序的实体，是系统进行资源分配和调度的基本单位，

     - 进程有5种基本状态：初始态、就绪状态、执行状态、等待（阻塞）状态、终止状态。

   - 线程：

     - 是程序执行中一个单一的顺序控制流程，是处理器调度和分派的基本单位。
     - 一个进程可以有多个线程，多个线程共享进程中的所有资源，各个线程有各自的调用栈和线程本地存储
     - 也有五个状态

   - 协程：

     - 微线程，比线程更加轻量的存在，协程不被操作系统所管理，完全由程序所控制
     - 一个线程可以有多个协程，可以比作子程序，子程序可中断。
     - 协程适用于IO阻塞且需要大量并发的场景

   - <img src="./legend/进程线程协程.png" style="zoom:50%;" />
   - 进程和线程的区别
     - 线程从属于进程，
     - 进程是系统资源调度的最小单位，线程是CPU调度的最小单位
     - 进程拥有独立的内存单元，多个线程共享进程的内存，线程拥有自己的栈段和寄存器组
     - 进程切换需要刷新页表缓冲并获取新的地址空间，然后切换硬件上下文和内核栈。线程切换只执行后二者。
     - 通信方式不一样，进程通过管道（匿名和具名管道），IPC（消息队列，信号量，共享内存，信号）。线程通过互斥锁，读写锁，条件变量。
     - 进程适用于多核，多机分布。线程适用于多核
   - 线程和协程的区别
     - 协程执行效率极高，切换开销更小更快，直接操作栈没有内核切换的开销。
     - 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

4. linux fork函数

   - 用于创建子进程，我们在shell下执行一个命令其实也是通过fork()实现的。
   - fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。
   - fork()最大的特点就是一次调用，两次返回，两次返回主要是区分父子进程，因为fork()之后将出现两个进程，所以有两个返回值，父进程返回子进程ID，子进程返回0。如果创建失败返回-1

5. 孤儿进程，僵尸进程

   - 孤儿进程：父进程退出后，而子进程还在运行，被称作孤儿进程，孤儿进程将被init进程（进程号为1）接管和记录状态
   - 僵尸进程：一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。
   - 解决僵尸进程
     - fork子进程后，都要及时调用wait系统调用。
     - kill进程。

6. 守护进程，[如何实现](https://blog.csdn.net/m0_72772587/article/details/126692497)

   - 运行在后台，长生存期（系统启动到关闭）的进程，通常独立于控制终端，并且周期性的执行某种任务或等待处理某些发生的事件。Daemon，处理一些系统级的任务。

   - 如何实现：

     - 创建子进程，终止父进程。(使子进程称为后台进程)：调用fork，然后杀父进程

     - 创建一个新会话，使进程完全独立：调用setid()

       - linux以会话，进程组的方式管理进程，每个进程属于一个进程组，会话则是多个进程组的集合。

     - 将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。

       - 便于让守护进程以绝对路径的形式访问资源

     - 重设文件权限掩码。

       - 将文件掩码设置为0，方便后续守护进程创建时，创建出来的文件权限符合我们的预期，增强守护进程的灵活性

     - 关闭子进程从父进程继承打开的文件描述符。

       - 进程继承了父进程已经打开的文件，这些文件可能永远不会被守护进程读写，但一样会消耗资源，所以需要关闭这些不用的文件描述符。

       ```c
       #include <stdio.h>
       #include <sys/stat.h>
       #include <sys/types.h>
       #include <unistd.h>
       #include <stdlib.h>
        
       int main()
       {
       	//1.创建子进程，关闭父进程
       	pid_t pid=0;
       	pid=fork();
       	if(pid<0)
       	{
       		perror("fork error");
       		return -1;
       	}
       	if(pid>0)
       	{
       		exit(0);//关闭父进程
       	}
       	//2.创建新会话
       	pid=setsid();
           //如果调用此函的进程不是一个进程组长，则此函数创建一个新的会话，具体如下：
           //(1)   该进程变为新会话的会话首进程。
           //(2)   该进程成为一个新进程组的组成进程，新进程组ID是该进程ID。
           //(3)   该进程没有控制终端。
           
           
       	if(pid<0)
       	{
       		perror("setsid error");
       		return -1;
       	}
       	//3.设置工作目录
       	chdir("/tmp");
       	//4.重设文件掩码
       	umask(0);
       	//5.关闭从父进程继承下来的文件描述符
       	int i=0;
       	for(i=0;i<getdtablesize();i++)
       	{
       		close(i);
       	}
       	//6.执行任务(每5秒记录一次系统时间)
       	while(1)
       	{
       		system("echo `date` >> time.txt");
       		sleep(5);
       	}
       	return 0;
       }
       //根目录tmp文件夹下多了一个time.txt文件。查看该文件，可以看到守护进程每5秒写入的系统时间。
       ```

7. [会话，作业，进程组，进程，控制终端，守护进程](https://blog.csdn.net/lyshark_lyshark/article/details/125847000)

   - 一个会话又可以包含多个进程组。一个会话对应一个控制终端
   - 进程组：进程组就是一个或多个进程的集合，他们彼此之间或者存在父子、兄弟关系
   - 作业与进程组的区别：如果作业中的某个进程又创建了子进程，则子进程不属于作业。一旦作业运行结束，Shell就把自己提到前台，如果原来的前台进程还存在(如果这个子进程还没终止)，它自动变为后台进程组。
   - 一次登录形成一个会话，一个会话可包含多个进程组，但只能有一个前台进程组。每个会话都有一个会话首领(leader)，即创建会话的进程。 sys_setsid()调用能创建一个会话。必须注意的是，只有当前进程不是进程组的组长时，才能创建一个新的会话。调用setsid 之后，该进程成为新会话的leader。

8. 进程间通信

   - 进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存）、套接字socket。
   - 管道：管道本质是一种文件，
     - 无名管道（半双工，pipe）：只能用于具有亲缘关系的进程直接通信
     - 命名管道（mkfifo）：可以允许无亲缘关系进程间的通信。
   - 系统IPC(inter-process communication)
     - 消息队列（sys/msg.h，msgget）
     - 信号量semaphore（sys/sem.h）：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。
     - 信号：用于通知接收进程某个事件的发生。（软中断）
     - 内存共享（sys/shm.h）：使多个进程访问同一块内存空间。
   - 套接字socket：用于不同主机直接的通信。

9. 进程通信中管道的实现原理

   - 操作系统在内核中开辟一块缓冲区（称为管道）用于通信，管道本质是文件，一般文件的 I/O 函数都可以用于管道，如close()、read()、write()等。
   - 管道具有单向通信的机制，所以要实现全双工需要两个管道
   - 

   ```c
   // 父子进程间的管道通信
   #include<unistd.h>
   #include<stdio.h>
   #include<stdlib.h>
   #include<string.h>
   #define INPUT 0
   #define OUTPUT 1
   int main(){
       //1.创建管道
       int fd[2];
       pipe(fd);
       //2.创建子进程
       pid_t pid = fork();
       if (pid < 0){
       	printf("fork error!\n");
       	exit(-1);
       }
       else if (pid == 0){//执行子进程
       	printf("Child process is starting...\n");
           //3. 子进程向父进程写数据，关闭管道的读端
           close(fd[INPUT]);
           write(fd[OUTPUT], "hello douya!", strlen("hello douya!"));
           exit(0);
       }
       else{//执行父进程
        	printf ("Parent process is starting......\n");
           //4.父进程从管道读取子进程写的数据 ，关闭管道的写端
           close(fd[OUTPUT]);
           char buf[255];
           int output = read(fd[INPUT], buf, sizeof(buf));
           printf("%d bytes of data from child process: %s\n", output, buf);   
       }
       
       return 0;
       
   }
   ```

10. 常见的信号有哪些

   - | 信号代号 | 名称    | 说明                                                         |
     | -------- | ------- | ------------------------------------------------------------ |
     | **1**    | SIGHUP  | 该信号让进程立即关闭.然后重新读取配置文件之后重启            |
     | 2        | SIGINT  | 程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键     |
     | 19       | SIGSTOP | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |
     | **15**   | SIGTERM | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |
     | **9**    | SIGKILL | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |
     | **17**   | SIGCHLD | 子进程结束时, 父进程会收到这个信号。                         |
     | 18       | SIGCONT | 该信号可以让暂停的进程恢复执行。本信号不能被阻断             |

11. linux进程调度算法

   - 先来先服务调度算法：按照进程队列的先后选择一个或多个作业
   - 短作业(进程)优先调度算法：从进程队列选择一个或若干估计运行时间最短的
   - 高优先级优先调度算法
   - 时间片轮转法
   - 多级反馈队列调度算法：综合前面多种调度算法。

   - 这些调度算法中，抢占式和非抢占式的区别：
     - 非抢占式：进程一旦被执行，就直到完成，除非主动放弃处理机。可用于对实时性要求不严的实时系统中
     - 抢占式：正在执行的进程，和新的就绪进程的优先级比较，高者获取执行权。故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

11. 进程的状态

    - 创建、就绪、执行、阻塞、终止。
    - 一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。
    - ![](./legend/进程状态转换.jpg)
    - [**IO操作，为什么不要CPU**](https://blog.csdn.net/weixin_37989267/article/details/111041650)：IO所需要的CPU资源非常少。大部分工作是分派给DMA（**Direct Memory Access**）完成的
      - 磁盘IO：CPU计算文件地址 ==> 委派DMA读取文件 ==> DMA接管总线 ==> CPU的A进程阻塞，挂起 ==> CPU切换到B进程 ==> DMA读完文件后通知CPU（一个中断异常） ==> CPU切换回A进程操作文件

12. 死锁，产生条件，如何解决

    - 是指多个进程在执行过程中，因争夺资源而造成了互相等待。此时系统产生了死锁。比如两只羊过独木桥，若两只羊互不相让，争着过桥，就产生死锁。
    - 四个必要条件：
      - 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问，只能等待，直到进程使用完成后释放该资源；
      - 请求保持：进程获得一定资源后，又对其他资源发出请求，但该资源被其他进程占有，此时请求阻塞，而且该进程不会释放自己已经占有的资源；
      - 不可剥夺：进程已获得的资源，只能自己释放，不可剥夺；
      - 环路等待：若干进程之间形成一种头尾相接的循环等待资源关系。
    - 如何解决
      - 资源一次性分配，解决请求保持
      - 可剥夺资源：当新的资源未得到满足，释放已有资源，破坏不可剥夺条件
      - 资源有序分配，破坏环路等待条件

13. 怎么定位死锁问题

    - [windows定位死锁](https://blog.csdn.net/LearnLHC/article/details/115594187)

    - 初步诊断：死循环还是死锁

      - 死循环：CPU一直保持非0，处于活跃状态，软件状态：未响应，如果主线程出现死循环，那么windows将不能从中取出消息，并进行处理
      - 死锁：进程的 cpu 使用率一般是0，那么主线程会一直等待资源或者锁，导致主线程不能继续往下执行，分发和处理消息，所以出现卡死

    - 进一步分析

      - 使用任务管理器来分析

      - 死锁：

        - 任务管理器 - 详细信息 - 分析等待链，可以看到程序处于死锁的提示，如图中的橙色框

          ![](./legend/分析等待链.png)

        - 对其进行【创建转储文件】转换为dump，再通过WinDbg（Attach 程序）对dump进行分析

          - ![](./legend/windows查看锁状态.png)

        - 

      - 死循环：任务管理器 \- 详细信息 - 创建转储文件

    - [linux c 死锁问题定位](https://blog.csdn.net/zsiming/article/details/126695393)

      ```bash
      # 拿到进程的id
      ps aux | grep 目标进程
      # 分析CPU和内存占有率，如CPU利用率和内存为0，则考虑为死锁
      top -Hg 进程id
      
      gdb attach 进程id
      # 查看三个线程的堆栈情况
      thread apply all bt
      # 查看线程id
      info threads
      # 切换线程，分别查看锁信息。
      thread 线程id
      ```

      

14. 线程间通信（同步）的方式

    - 临界区、互斥锁、读写锁、信号量、条件变量
    - 临界区
      - 指访问公共资源的程序代码段
      - 临界资源：同一时刻，只允许被一个进程或线程访问的资源
    - 互斥锁：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
    - 读写锁：读写锁与互斥锁类似。但互斥锁要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。
    - 信号量：计数器，允许多个线程同时访问同一个资源。
    - 条件变量：
      - 条件变量是利用线程间共享的全局变量进行同步的一种机制
      - 主要包括两个动作：一个线程等待条件变量的条件成立而挂起;另一个线程使条件成立（给出条件成立信号）。
      - 为了防止竞争，条件变量的使用总是和一个互斥量结合在一起。

15. 有了进程为什么还要线程

    - 在早期的多任务操作系统，进程是基本的执行单元，每次进程切换，都要先保存进程资源然后再恢复，这称为上下文切换。但是进程频繁切换将引起额外开销从而严重影响性能，为了减小进程切换的开销，人们把两个任务放到一个进程中，每个任务用一个更小粒度的执行单元来实现并发执行，这就是线程。
    - 线程的切换开销更小，

16. 单核机器上写多线程程序，是否还要加锁

    - 要加锁
    - 时间片的大小不定。比如单个时间片只能完成给定任务的一半，剩下的那一半就只有等下一个时间片了。而在等待的过程中，如果不加锁，就没法保证其他线程不使用我们的资源，数据就有可能出错。
    - A在吃饭用碗，还没吃完（时间片结束），给碗加个锁。下一个时间片，B过来吃饭，看见碗被锁住，所以这个时间片将等待，再下一个时间片，A吃完，将碗的锁释放。下一个时间片，B就可以吃饭用碗。

17. 互斥锁和读写锁

    - 互斥锁同一时间只允许一个线程访问该对象，无论读写；
    - 读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

18. 信号量，有什么作用

    - 信号量是一个特殊的变量，一般取正数值。它的值代表允许访问的资源数目。
    - 获取资源时，需要对信号量的值进行原子减一，该操作被称为 P 操作。当信号量值为 0 时，代表没有资源可用，P 操作会阻塞。
    - 释放资源时，需要对信号量的值进行原子加一，该操作被称为 V 操作。
    - 信号量主要用来同步进程。信号量的值如果只取 0,1，将其称为二值信号量。如果信号量的值大于 1，则称之为计数信号量。
    - 用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。

19. 进程和线程的中断切换是怎样的

    - 上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。

    - 进程上下文切换

      - 保护被中断进程的处理器现场信息

      - 修改被中断进程的进程控制块（PCB：process control block）有关信息，如进程状态等

      - 把被中断进程的进程控制块加入有关队列

      - 选择下一个占有处理器运行的进程

      - 根据被选中进程设置操作系统用到的地址转换和存储保护信息

        - 切换页目录以使用新的地址空间

        - 切换内核栈和硬件上下文（包括分配的内存，数据段，堆栈段等）

      - 根据被选中进程恢复处理器现场

    - 线程上下文切换

      - 保护被中断线程的处理器现场信息
      - 修改被中断线程的线程控制块（TCB：thread CB）有关信息，如线程状态等
      - 把被中断线程的线程控制块加入有关队列
      - 选择下一个占有处理器运行的线程
      - 根据被选中线程设置操作系统用到的存储保护信息，切换内核栈和硬件上下文（切换堆栈，以及各寄存器）
      - 根据被选中线程恢复处理器现场

20. 自旋锁和互斥锁的使用场景

    - 互斥锁：用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑
      - 临界区有IO操作
      - 临界区代码复杂或者循环量大
      - 临界区竞争非常激烈
      - 单核处理器（cpu资源紧张）
    - 自旋锁：持锁时间短且CPU资源不紧张，而且线程并不希望在重新调度上花太多的成本。
    - 自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。
    - 对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态，通过休眠使进程阻塞（等待期间放弃cpu）。但是自旋锁不会，获取锁之前一直处于忙等（自旋，原地打转）阻塞状态（没有放弃CPU）。

21. 多线程编程需要注意什么，加锁要注意什么

    - 多线程编程需要考虑同步问题，线程间的同步方式包括互斥锁、信号量、条件变量、读写锁。
    - 多线程加锁，主要需要注意死锁的问题。破坏死锁的必要条件从而避免死锁。

22. sleep和wait的区别

    - sleep是一个延时函数，让进程或线程进入休眠（阻塞）。休眠完毕后继续运行。linux sleep函数参数的单位是s，而windows 是ms
    - wait是父进程回收子进程PCB资源的系统调用，进程一旦调用了wait函数，就立即阻塞自己本身。然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。
    - 区别：
      - sleep是一个延时函数，让进程或线程进入休眠。休眠完毕后继续运行。
      - wait是父进程回收子进程PCB（Process Control Block）资源的一个系统调用。

23. 线程池的设计思路，线程池中线程的数量由什么确定？

    - 实现线程池设计思路：
      - 设置一个生产者消费的任务队列，作为临界资源（任何时候只有一个进程访问的资源）。
      - 初始化n个线程，并让其运行起来，对任务队列加锁，去队列里取任务运行
      - 当任务队列为空时，所有空闲的线程阻塞。
      - 当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。
    - 线程池中线程数量，[实际](https://juejin.cn/post/7067183465224994852),[理论](https://juejin.cn/post/7066675779966337031)
      - 因素：CPU，IO、并行、并发
      - 线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。
      - 最佳线程数目：`（线程等待时间与线程CPU执行时间之比 + 1 ）* 2`
      - 对于计算密集型应用，线程池中线程数目推荐：`CPU核数 + 1`
      - 对于IO密集型应用：`2 * CPU核数 + 1`
      - 计算密集型如果是完成一件事情，线程为越少越好。可以减少上下文切换的时间。
      - I/O密集在线程池线程的数量在一定范围内越多越好，处理完成一件事情耗时也越少。但是增加到一定程度后会增加上下文的切换耗时反而导致时间增加。
      - 对于完成一件事情，线程池数量的多少不影响。

24. 进程和线程相比，为什么慢

    - 资源开销：进程系统开销显著大于线程开销。进程需要独立的内存空间
    - 切换开销：进程需要刷新TLB（Translation Lookaside Buffer，简单说，TLB就是页表缓存）获取新的地址空间，切换硬件上下文和内核栈，线程只需要切换后二者
    - 进程通信比线程通信开销大：进程通信需要借助管道、队列、共享内存，需要额外申请空间，通信繁琐；而线程共享进程的内存，如代码段、数据段、扩展段，通信快捷简单，同步开销更小。

    

## IO

1. linux零拷贝原理

   - 零拷贝就是一种避免 CPU 将数据从一块存储（缓存）拷贝到另外一块存储（缓存）的技术。
   - 传统linux IO接口是基于数据拷贝做的，数据可以从缓存区到缓存区之间传输，从而减少磁盘的IO操作。但是数据传输过程的数据拷贝操作却导致了极大的 CPU 开销
   - 优点
     - 节省CPU
     - 减少内存之间的数据拷贝，节省内存带宽
     - 减少用户态和内核态之间数据拷贝，和上下文切换
   - 实例：用户态和内核态之间并没有拷贝。
   - mmap()来代替read调用：减少了一次拷贝
     - ![](./legend/零拷贝.png)
   - sendfile：从linux内核2.1开始，就用sendfile简化操作，带DMA的sendfile还可以减少页缓存到socket缓冲区的拷贝

2. epoll和select的区别，epoll为什么高效

   - 原理解释：[select和epoll](https://www.jianshu.com/p/c9190109c7d8)

   - select与epoll的使用场景：都是IO多路复用的机制，应用于高并发的网络编程场景。IO多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪，能够通知应用程序进行相应的读写操作。

   - 进程A执行到创建socket语句的时候，创建socket对象，进程A进入阻塞态，等待接收socket传来的网络数据，当socket已接收到数据之后，进程A进入执行态

     ![](./legend/进程与单个socket.png)

   - 进程正是通过**IO多路复用**的形式来监听多个socket（select和epoll）

   - select准备一个数组fds（文件描述符），存放需要监视的所有socket，然后调用select，如果fds中所有的socket都没有数据，select会阻塞，直到有一个socket收到数据，select返回，唤醒进程，用户可以遍历fds，通过FD_ISSET判断哪个socket收到了数据，然后做出处理。

     ![](./legend/select.png)

   - epoll创建epoll对象，维护一个就绪列表和等待队列。当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，由于rdlist的存在，进程A可以知道哪些socket发生了变化

     ![](./legend/epoll.png)

   - select与epoll的区别

     - 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。
     - 每调用一次select都会遍历一次fd集合，知晓哪个有数据，而epoll只会轮询一次fd集合，查看rdlist
     - select最大支持1024个fd，而epoll没有这个限制

   - epoll水平触发和边缘触发

3. Reactor、Proactor模式

   - 在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
   - Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中需要用户区传递缓存区，应用程序直接使用数据就行。

4. [同步和异步，阻塞与非阻塞](https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247526626&idx=4&sn=21178025390cbb53d2e89c918340e747&chksm=fbb1e11cccc6680a9ba746e7c092ce34e82ba9c786c251a4a89b3cb62c796bdf03303165ee36&scene=27)

   - 同步和异步指的是：当前线程是否需要等待方法调用执行完毕。（线程内部，不让出cpu）
     - 同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。
     - 异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。
   - 阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。（阻塞让出cpu，线程之间）

5. [IO模型的类型](https://blog.csdn.net/weixin_43705195/article/details/120099487)

   - <img src="./legend/io分类.png" style="zoom: 33%;" />

   - 阻塞io：调用io函数，阻塞等待返回，返回后才能下一步。
   - 非阻塞io：调用io函数，每隔一段时间，检查io事件是否就绪，没就绪就可以做其他事情。
   - io多路复用（阻塞）：能实现对多个io端口进行监听，会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作
   - 信号驱动io（非阻塞）：首先开启接口信号驱动io功能，通过系统调用sigation执行一个信号处理函数（此信号调用直接返回，进程继续工作），就绪时，生成一个signal信号，通知应用程序来取数据。
   - 异步io（非阻塞）：Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。
   - 前四种模型--阻塞IO、非阻塞IO、多路复用IO和信号驱动IO都属于同步模式，因为其中真正的IO操作(将数据从内核拷到用户空间)都将会阻塞进程，只有异步IO模型真正实现了IO操作的异步性。
   - 异步和同步的区别就在于，异步是内核将数据拷贝到用户区，不需要用户再自己接收数据，直接使用就可以了，而同步是内核通知用户数据到了，然后用户自己调用相应函数去接收数据。
   
6. 客户端和服务端用到哪些函数

   - TCP
   - - server：
       1. socket创建一个套接字
       2. bind绑定ip和port
       3. listen使套接字变为可以被动链接
       4. accept等待客户端的链接
       5. write/read接收发送数据
       6. close关闭连接
     - client
       1. 创建一个socket，用函数socket()
       2. bind绑定ip和port
       3. 连接服务器，用函数connect()
       4. 收发数据，用函数send()和recv()，或read()和write()
       5. close关闭连接
   - UDP
   - - server
       1. 创建一个socket，socket()
       2. 设置服务器地址和端口并绑定,bind()
       3. 接受客户端数据,recvfrom()
       4. 发送数据,sendto()
       5. 关闭,close()
     - client
       1. 创建一个socket，socket()
       2. 设置想要连接对方的ip和端口
       3. 收发数据,sendto()/recvfrom()
       4. 关闭连接,close()

   ![](./legend/客户端和服务端用到哪些函数.jpg)

7. GDB常见调试命令，条件断点，多进程如何调试

   - b，r，c，p，s，n
   - b linenum if cond
   - 多进程：set follow-fork-mode child，set detach-on-fork off
   - 多线程：thread 线程id，set scheduler-locking on，thread apply 线程id cmd

8. 

# 3 计算机网络

## 路由

1. 静态路由和动态路由

   - 静态路由是由系统管理员设计与构建的路由表规定的路由。
     - 场景：适用于网关数量有限的场合，且网络拓朴结构不经常变化的网络。
     - 缺点：不能动态地适用网络状况的变化，当网络状况变化后必须由网络管理员修改路由表。
   - 动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。
     - 缺点：路由广播更新信息将占据大量的网络带宽。

2. 路由协议，都是如何更新的

   - 路由协议是路由器之间实现路由信息共享的一种机制，它允许路由器之间相互交换和维护各 自的路由表。当一台路由器的路由表由于某种原因发生变化时，它需要及时地将这一变化通 知与之相连接的其他路由器，以保证数据的正确传递。

   - 路由可分为静态和动态路由。静态路由由管理员手动维护；动态路由由路由协议自动维护。

   - 自治系统（Autonomous System，自治域）：单一技术管理下的一组路由器，这些路由器在AS内部使用同一种路由选择协议，在AS之间也使用同一种路由协议

   - 路由选择算法又分：域内路由选择，域间路由选择（自治系统间）

   - 路由选择算法必要步骤：

     1. 向其它路由器传递路由信息；
     2. 接收其它路由器的路由信息；
     3. 根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表；
     4. 根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由信息的形式向其它路由器宣告。

   - 两种主要算法：距离向量法（Distance Vector Routing，RIP、IGRP、EIGRP）和链路状态算法（Link-State Routing，OSPF、IS-IS）。

   - RIP（路由信息协议）：

     - 路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路 径信息，除到达目的地的最佳路径外，任何其它信息均予以丢弃。同时路由器也把所收集的 路由信息用 RIP 协议通知相邻的其它路由器。这样，正确的路由信息逐渐扩散到了全网。
     - 路由器根据距离（跳数）选择路由，路由表包含的内容：目的网络，距离（跳数，最大跳数15），下一跳路由。**每隔30秒**一次路由信息广播，仅和相邻路由器交换信息
     - 适合：小型同构网络

   - OSPF（开放最短路径优先）：

     - 采用洪泛法交换链路状态信息。（向相邻发信息，相邻再转发）
     - 各路由器之间交换链路状态信息，所有路由器最终能建立一个链路状态数据库，这个数据库就是AS下的全网拓扑结构图，然后通过Dijkstra算法计算自己到目的网络的距离，以此构造路由表。
     - 为了支持更大网络，OSPF将一个自治系统再分区，好处是将利用洪泛交换链路状态信息范围局限于每个区域而非整个AS，在区域内部只知道本区域的拓扑结构。
     - **只有当链路状态发生变化时，才交换链路信息**

   - BGP（边界网关协议）：自治域间路由选择，**路径向量算法**

     - 每个AS选一个BGP发言人，BGP就是来建立BGP发言人之间的拓扑结构。BGP所交换的网络可达性就是要到达某个网络所要经过的一系列AS。寻找一条能够到达目的网络且**比较好**的路由（因为是发言人，而不是所有路由）。
     - BGP的路由表：目的网络前缀，下一跳路由，到达目的网络所要经过的各个自治系统序列。

   - |          | RIP          | OSPF               | BGP                                        |
     | -------- | ------------ | ------------------ | ------------------------------------------ |
     | 类型     | AS内         | AS内               | AS间                                       |
     | 路由算法 | 距离-向量    | 链路状态           | 路径-向量                                  |
     | 传递协议 | UDP          | IP                 | TCP                                        |
     | 路径选择 | 跳数最少     | 代价最低           | 较好，非最佳                               |
     | 交换节点 | 相邻路由器   | 网络中所有路由     | 相邻路由器                                 |
     | 交换内容 | 自己的路由表 | 所有路由的链路状态 | 首次：整个路由表<br />非首次：有变化的部分 |

3. 域名解析过程，本机如何干预域名解析（ARP，Address Resolution Protocol，地址解析协议）

   1. 浏览器中输入www.qq.com 域名，操作系统查本地的hosts文件，有无映射关系，有则完成解析

   2. 如本地hosts无，就查本地DNS**解析器**（一般是网络接入服务器商提供，比如中国电信，中国移动。），有则完成

   3. 如本地DNS无，会找TCP/IP参数中设置的首选DNS**服务器**（本地DNS服务器），包含在本地配置资源中，则完成，此解析具有权威性

   4. 如查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则完成，但该解析不具权威性

   5. 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，

      - **如果未用转发模式**，
        - 本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。
        - 本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，
        - 如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com 主机。
      - **如果用的是转发模式**，
        - 此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。
        - 不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服
          务器再返回给客户机。

   6. 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。

   7. 干预域名解析

      - 修改本机host来干预域名解析，/etc/hosts

      - 每一行为一条记录，分成两部分，第一部分是IP，第二部分是域名。

      - ```text
        192.168.188.1 www.baidu.com
        ```

      - ip对域名，是1对多

      - 重复ip行，按前面的记录解析

4. DNS劫持

   - DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

   - DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。

5. 网关的作用，同一网段主机如何通信

   - 网关即网络中的关卡，我们的互联网是一个一个的局域网、城域网、等连接起来的，在连接点上就是一个一个网络的关卡，即我们的网关，他是保证网络互连的，翻译和转换，使得不同的网络体系能够进行。
   - 网段内主机通信，即通信双方都位处同一网段中，数据传输无需经过路由器(或三层交换机)，即可由本网段自主完成。
   - 假设发送主机的ARP表中并无目的主机对应的表项，则发送主机会以目的主机IP地址为内容，广播ARP请求以期获知目的主机MAC地址，并通过交换机(除到达端口之外的所有端口发送，即洪泛(Flooding))向全网段主机转发，而只有目的主机接收到此ARP请求后会将自己的MAC地址和IP地址装入ARP应答后将其回复给发送主机，发送主机接收到此ARP应答后，从中提取目的主机的MAC地址，并在其ARP表中建立目的主机的对应表项(IP地址到MAC地址的映射)，之后即可向目的主机发送数据，将待发送数据封装成帧，并通过二层设备(如交换机)转发至本网段内的目的主机，自此完成通信。

6. CSRF：

   - 客户端脚本安全：跨站脚本攻击（XSS)，跨站点请求伪造（CSRF），点击劫持

   - 服务端安全：注入攻击，文件上传漏洞，分布式拒绝服务（DDOS）

   - 跨站请求伪造。就是黑客可以伪造用户的身份去做一些操作，进而满足自身目的。

   - 登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B，B获取A的cookie，去请求A的api。

   - 解决方法：

     - 在请求地址中添加 token 并验证

     - 在http头中自定义属性并验证

7. SYN flood（syn洪泛攻击），如何防止这类攻击

   - SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS(分布式拒绝服务攻击)的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求（第一次握手后，服务器会将这次请求放入一个未连接队列），使被攻击方资源耗尽（造成未连接队列满，而新的请求无法提供服务，CPU满负荷或内存不足)的攻击方式.
   - 防御
     - 反向代理 CDN，反向代理服务器位于用户与目标服务器之间，使用反向代理作为 Web 服务器的前置机来降低网络和服务器的负载，提高访问效率。
     - 充足的网络带宽保证：网络带宽直接决定了能抗受攻击的能力，假若仅有 10M 带宽，无论采取何种措施都很难对抗现在的 SYNFlood 攻击，当前至少要选择 100M 的共享带宽
     - 使用入侵防御系统/防火墙技术和专用于防御DDoS攻击的专用硬件来实现内部预防和响应DDoS攻击。
     - 从ISP购买DDOS缓解服务。

8. MAC和IP地址的作用

   - MAC地址：物理地址，是数据链路的地址，用来识别同一链路中的不同计算机和设备。（点到点，提供结点到结点）
   - IP 地址：逻辑地址，是网络层中的地址，用来识别计算机网路中互连的主机和路由器。（提供主机到主机逻辑通信）
   - 程序地址：端口号

9. 

## TCP

1. [TCP的三次握手和四次挥手](https://blog.51cto.com/jinlong/2065461)

   - 置位概念：根据TCP的包头字段，存在3个重要的标识ACK、SYN、FIN

     - ACK：表示验证字段
     - SYN：位数置1，表示建立TCP连接
     - FIN：位数置1，表示断开TCP连接

   - 三次握手过程说明：

     1. 由客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）
     2. 由服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ack=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接。
     3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ack=y+1，seq=x+1）

   - ![](./legend/三次招手四次挥手.png)

   - 四次挥手说明

     1. 客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）

     2. 服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ack=x+1，seq=y，y由服务端随机生成）

     3. 服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到客户端的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ack=x+1，seq=z，z由服务端随机生成）

     4. 客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ack=z+1，seq=h，h为客户端随机生成）

        至此TCP断开的4次挥手过程完毕

2. TCP两次握手行不行，为什么要三次

   - 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
   - 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

3. 三次握手时候每次握手信息对方没收到会怎么样

   - 如果第一次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
   - 如果第二次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传
   - 如果第三次握手消息丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以设置/proc/sys/net/ipv4/tcp_synack_retries修改，默认值为5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

4. [TCP连接和关闭的状态转移](https://blog.51cto.com/jinlong/2065461)

   - 11种状态
   - 三次握手

   1. 一开始，建立连接之前服务器和客户端的状态都为CLOSED；
   2. 服务器创建socket后开始监听，变为LISTEN状态；
   3. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变为SYN_SENT；
   4. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD；
   5. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED；
   6. 服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！

   ![](./legend/TCP三次握手四次挥手状态转移.png)

   - 四次挥手
     1. 客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1；
     2. 服务器收到FIN后向客户端发送ACK，服务器的状态变为CLOSE_WAIT；
     3. 客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；
     4. 直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；
     5. 客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；
     6. 再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
     7. 至此，还有一个状态没有出来：CLOSING状态。客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。

5. TCP 的 TIME_WAIT，为什么需要有这个状态

   - 报文段最大生存时间MSL（Maximum Segment Lifetime），2MSL——两个来回的报文最大生存时间。
   - TCP实现必须可靠地终止连接的两个方向(全双工关闭)，客户端必须进入 TIME_WAIT 状态，因为客户端可能面 临重发最终ACK的情形（2MSL，ACK发一次，丢失后，再发一次）

6. MSL，为什么客户端连接要等待2MSL的时间才能完全关闭

   - 报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
   - 为什么客户端连接要等待2MSL的时间才能完全关闭
     - 保证客户端发送的最后一个ACK报文段能够到达服务端。
       - 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的服务端收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
     - 防止“已失效的连接请求报文段”出现在本连接中。
       - 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

7. TCP慢启动

   - TCP拥塞控制：慢开始，拥塞避免，快重传和快恢复算法是对前二者的优化。都是基于重传超时和重复确认设计的算法。
   - TCP要求发送方必须有两个窗口：接收窗口rwnd（接收方许诺发送方的窗口字段），拥塞窗口cwnd（发送方自身估算的拥塞程度而设置的窗口值），发送窗口（滑动窗口）的上限值 = min{ rwnd，cwnd}
   - 慢开始：TCP建立一开始，令cwnd=1（最大报文段长度MSS），每收到一个报文的接收确认，cwnd=cwnd * 2，但增加到ssthresh(慢开始)阈值，就改用拥塞避免算法
   - 拥塞避免算法：当cwnd>ssthresh，cwnd = cwnd + 1
   - 当发送方检测到有确认超时发生时，ssthresh = cwnd / 2，cwnd =1，
   - 乘法减小算法：不论是在慢开始阶段，还是拥塞避免阶段，只要出现确认超时，即执行ssthresh = cwnd / 2
   - 加法增大算法：经过RTT（往返时间）之后，cwnd = cwnd + 1
   - 快重传：在连续收到3个重复的ACK后，直接重传对方尚未收到的报文段，不必等确认超时
   - 快恢复：在连续收到3个重复的ACK后，执行乘法减小，同时执行加法增大

8. TCP拥塞控制的算法有哪些

   - TCP Tahoe/Reno，基于重传超时和重复确认
     - Tahoe：慢启动，拥塞避免，快重传
     - Reno：快速恢复
   - TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）：2016年发布，google设计
     - BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。
     - 数据包传输的每个累积或选择性确认，用于生成，记录在数据包的传输过程 和 确认返回期间的时间内所传送数据量的采样率
     - 该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，

9. TCP超时重传

   - TCP可靠性中最重要的一个机制是处理数据超时和重传。
   - TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。

10. TCP可靠性保证

    - TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。
    - 校验和：
      - 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。
      - TCP接收端在计算检验和时，要加上一个12字节的伪首部。
      - TCP首部校验和计算三部分：TCP首部+TCP数据+TCP伪首部。
    - 序列号/确认应答：发送端会给发送每个字节都编上序号，发送一个分组，接收端要回应一个分组
    - 超时重传：
      - 是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传
      - 但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。
    - 最大长度：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。
    - 滑动窗口：
      - 超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。滑动窗口就是用来解决这个问题
      - 窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。
      - 发送端丢包（快重传）：当发送方丢包，接收端会连续回复多个相同的确认，表明数据丢失，当即重发。
      - 接收方确认信号丢失：序号大的确认信息表明序号小的数据包已送达，否则不会回复序号大的确认信息。
    - 拥塞控制：为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度（滑动窗口）传送数据。
    - 
    - <img src="./legend/滑动窗口.png" style="zoom:67%;" />

11. 滑动窗口以及重传机制

    - 滑动窗口：
      - 用来解决超时重传效率低下的问题，
      - 窗口大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。
      - 它的上限是：由接收端窗口大小、发送端拥塞窗口大小共同决定，swnd = min{ rwnd, cwnd }
    - 重传机制：
      - 超时重传：送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。如果多次重发皆没收到确认，即认为接收端异常，强制关闭连接。
      - 快重传：在连续收到3个重复的ACK后，直接重传对方尚未收到的报文段，不必等确认超时

12. 滑动窗口的大小影响

    - 网络性能：
      - 如果滑动窗口过小，则需要在网络上频繁的传输确认信息，占用了大量的网络带宽；
      - 如果滑动窗口过大，对于利用率较高，容易产生丢包现象的网络，则需要多次发送重复的数据，也同样耗费了网络带宽

13. TCP 粘包和拆包

    - TCP是个“流”协议，所谓流，就是没有界限的一串数据。
    - TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

14. TCP和UDP在网络协议的哪一层，二者的区别，头部结构

    - 在传输层。
    - TCP面向的是字节流的服务，UDP面向的是报文的服务。
    - 连接：TCP有连接，UDP无连接，TCP是一对一的连接，而UDP则可以支持一对一，一对多，多对多的通信。
    - 可靠机制：
      - TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，
      - UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
    - 报头大小：TCP首部需要20byte（不包含可选项），UDP首部只需要8byte
    - 拥塞控制：TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
    - 应用场景：
      - TCP适用于高可靠性并且传输时间要求不高的应用
      - UDP适用于实时性要求高的应用。大量游戏、视频、娱乐应用
    - 上层协议依赖：
      - 基于TCP协议的：HTTP，Telnet，FTP以及SMTP（Simple Mail Transfer Protocol）协议。
      - 基于UDP协议的：DHCP（Dynamic Host Configuration Protocol）、DNS、SNMP（Simple Network Management Protocol）、TFTP（Trivial FTP）、BOOTP。
    
    ```c
    /*TCP头定义，共20个字节*/
    typedef struct _TCP_HEADER
    {
    short m_sSourPort; // 源端口号16bit
    short m_sDestPort; // 目的端口号16bit
    unsigned int m_uiSequNum; // 序列号32bit
    unsigned int m_uiAcknowledgeNum; // 确认号32bit
    short m_sHeaderLenAndFlag; // 前4位：TCP头长度；中6位：保留；后6位：标志
    位
    short m_sWindowSize; // 窗口大小16bit
    short m_sCheckSum; // 检验和16bit
    short m_surgentPointer; // 紧急数据偏移量16bit
    }__attribute__((packed))TCP_HEADER, *PTCP_HEADER;
    
    /*UDP头定义，共8个字节*/
    typedef struct _UDP_HEADER
    {
    unsigned short m_usSourPort; // 源端口号16bit
    unsigned short m_usDestPort; // 目的端口号16bit
    unsigned short m_usLength; // 数据包长度16bit
    unsigned short m_usCheckSum; // 校验和16bit
    }__attribute__((packed))UDP_HEADER, *PUDP_HEADER;
    ```
    
15. TCP如何保证有序

    - 发送方：发送数据时，给每个数据报分配一个序列号，并且在等待确认，如果确认超时，则发送方重传此数据包。
    - 接收方：按照序列号对接收的数据进行确认，检测丢失或乱序，接收到顺序化的数据后，整理成数据流，交给上层。
    - 具体步骤：
      - 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
      - 并为每个已发送的数据包启动一个超时定时器；
      - 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
      - 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

16. TCP如何加速一个大文件的传输

    - TCP 优化的本质就是用带宽换用户体验感
    - 建立连接优化：TCP 在建立连接时，如果丢包，会进入重试，重试时间是 1s、2s、4s、8s 的指数递增间隔，缩短定时器可以让 TCP 在丢包环境建连时间更快，非常适用于高并发短连接的业务场景。
    - 带宽评估：通过单位时间内收到的 ACK 或 SACK 信息可以得知客户端有效接收速率，通过这个速率可以更合理的控制发包速度。
    - 丢包预判：有些网络的丢包是有规律性的，掌握规律后，就可以针对性提前多发数据，减少重传时间、提高有效发包率。
    - RTO探测
    - `RTT(Round Trip Time)`：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；
    - `RTO(Retransmission Time Out)`：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。

17. 从系统层面上，UDP 如何保证尽量可靠

    - UDP仅提供了最基本的数据传输功能，至于传输时连接的建立和断开、传输可靠性的保证这些UDP统统不关心，而是把这些问题抛给了UDP上层的应用层程序去处理，自己仅提供传输层协议的最基本功能。
    - 最简单的方式是在应用层模仿传输层TCP的可靠性传输
      - 添加seq/ack机制，确保数据发送到对端
      - 添加发送和接收缓冲区，主要是用户超时重传。
      - 添加超时重传机制。

18. 服务端怎么判断客户端断开了连接

    - 检测连接是否丢失有两种：keep-alive和heart-beat
    - keep-alive：每隔一段时间，对端发送报文，尝试多次后，仍没反应，则判断连接中断，tcp断开连接
    - heart-beat：按较短的时间周期进行连接测试，如果连接测试失败，则认为判断失败，一般在应用层实现，用户可以自行决定中断后的行为，

19. 端到端和点到点

    - 端到端通信

      - 是针对传输层来说的，无论是TCP还是UDP，都负责将数据从发送端传输到接收端。
      - 指的是在数据传输之前，在发送端与接收端之间（**忽略中间有多少设备**）为数据的传输建立一条**逻辑链路**
      - 端到端通信建立在点到点的通信基础之上，它是由一段段的点到点通信链路构成的，完成应用程序（进程）之间的通信

      - 优点：
        - 链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。
      - 缺点：
        - 发送端的设备从数据的发送到接收要全过程参与，对发送端设备造成很大的浪费
        - 如果接收设备关机或故障，那么端到端传输不可能实现。

    - 点到点通信

      - 直接相连的节点对等实体的通信叫点到点通信，点到点通信是针对数据链路层或网络层来说的，只负责直接相连的两个节点之间的通信。通信子网
      - 优点：
        - 发送端只负责发送，不参与整个传输过程，不会浪费发送端设备的资源
        - 即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。
      - 缺点：
        - 点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。

    - 

20. TCP 的 keepalive和 HTTP 的 keepalive

    - HTTP keep-alive
      - 在http早期，每个http请求都要求打开一个tcp socket连接，并且使用一次之后就断开这个tcp连接。
      - 使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。
      - 通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(**更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用**)。
      - keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用，正确地设置keep-alive timeout时间非常重要。
    - TCP keep-alive
      - 链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持
      - TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。
    - 区别：
      - 两个是完全不同的东西，
      - tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。
      - http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。

21. TCP 延迟ACK和累计应答

    - 延迟ACK：就是让接收方在收到数据后不立即反馈ACK消息，而是等到一小段时间，如果之后还有收到其他包就把这些ACK消息一起放入一个包中反馈给客户端。当然ack不能无限延长（超时重传，网络延迟），一般为200ms。
    - 累计应答：一个包的确认，它代表此包（确认号ack）之前的包都已收到，而不需要对每个包都要发送确认。

22. 



## HTTP

1. [http与https](<https://blog.csdn.net/xiaoming100001/article/details/81109617>)

   - http：
     - 超文本传输协议，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。
     - HTTP 协议有一个缺陷：通信只能由客户端发起。
     - 是一个基于请求与响应，无状态的，无连接应用层的协议，常基于TCP/IP协议传输数据。
       - 无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。第一次访问和第二次访问同一个服务器响应相同。通常用Cookie/Session加数据库的方式来跟踪用户的行动
       - 无连接：在http1.1以前，每次访问都需要通过Tcp的三次握手四次挥手，和服务器重新建立连接。HTTP/1.1持久连接Connection：keep-alive（一个tcp连接对应多个http请求，则有多-1个请求没有对应tcp连接，这就是无连接），手动断连。
       - 基于请求和响应，客户端发起请求，服务器响应
       - 优点：简单快速灵活
       - 缺点：明文传输，请求和响应不需要通信双方的确认，无法保证数据的完整性。
   - https：
     - 基于HTTP协议+SSL或TLS协议，通过提供SSL或TLS加密处理数据(采用混合加密技术)、验证对方身份(通过证书认证)以及数据完整性保护(防止篡改和冒充)
     - 安全低效，有偿享用。

2. http的referer头的作用

   - HTTP Referer是header的一部分，其表示请求当前资源的客户端来源。当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该请求是从哪个域过来的，服务器因此可以获得一些信息用于处理。
   - 作用：
     - 防盗链
       - 只允许我本身的网站访问本身的图片服务器，假如域是www.google.com ，那么图片服务器每次
         取到Referer来判断一下域名是不是www.google.com ，如果是就继续访问，不是就拦截。
         将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发
         送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访
         问。
     - 防止恶意请求
       - 对于风险较高的文件类型，可使用Referer使得该类型资源只能来自我所指定的网站。
     - 防御CSRF
       - 比对HTTP 请求的来源地址，如果Referer中的地址是安全可信任的地址，那么就放行
     - 空referer
       - 允许Referer为空，意味着你允许比如浏览器直接访问。

3. [http状态码](<https://www.cnblogs.com/xflonga/p/9368993.html>)：

   - 1xx：通知，系列响应状态码仅在与HTTP服务器沟通时使用。
   - 2xx：成功，系列响应状态码表明操作成功了
   - 3xx：重定向，客户端需要做些额外工作才能得到所需要的资源。 
     - 301：Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI 代替。
     - 302：Found，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来继续以后的请求。
     - 304：Not Modified 未修改。所请求的资源自上次访问后，请求的内容未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
   - 4xx：客户端错误，表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。
     - 400（Bad Request）：请求无效，前端提交数据的字段名称和字段类型与后台的实体没有保持一致，协商不一致
     - 401（Unauthorized）：当前请求需要用户验证，客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书（登录等）。
     - 403（Forbidden）：服务器已经得到请求，但是拒绝执行。常用于一个资源只允许在特定时间段内访问，或者允许特定IP地址的用户访问的情况。
     - 404（Not Found）：服务器无法把客户端请求的URI转换为一个资源。
   - 5xx：服务端错误，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。
     - 500（Internal Server Error）：服务器如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。
     - 502 （bad gateway）：表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。

4. GET和POST的区别

   - 关于url长度：http没有做长度限制，只是说浏览器做了长度显示，2048个字符。GET数据有长度限制。
   - 关于安全性：post比get要好一点，但这个在安全问题面前影响很小，一般情况下，私密数据传输用POST + body就好。
   - 关于参数：GET参数通过URL传递，POST放在Request body中。
   - 关于编码：GET的参数只能支持ASCII（url上只支持ASCII），而POST能支持任意binary（body支持任意编码），包括中文。但用作接口时，GET实际上也可以带body，POST也可以在url上携带数据。
   - 关于缓存：GET请求会被浏览器主动cache，而POST不会，除非手动设置。

5. http八种请求方法：

   - 表明对Request-URL指定的资源不同的操作方式
   - http1.0 
     - GET：向特定资源发出请求（请求指定页面信息，并返回实体主体）
     - POST：向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改
     - HEAD：get请求类似，返回的响应中没有具体内容，用于获取报头（用于检查超链接的有效性）
   - http1.1增加了
     - OPTIONS：返回服务器针对特定资源所支持的HTML请求方法
     - PUT：向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）
     - DELETE：请求服务器删除request-URL所标示的资源
     - TRACE：回显服务器收到的请求，用于测试和诊断
     - CONNECT ：能够将连接改为管道方式的代理服务器

6. HTTP的缓存机制

   - HTTP 缓存即是浏览器第一次向一个服务器发起HTTP 请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段如：cache-control，expires，last-modifed，ETag,Date等，之后浏览器再向该服务器请求资源就可以视情况使用强缓存和协商缓存，
   - 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。
   - 协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。

7. HTTP1.0，1.1，2.0区别

   - 1.0 :
     1. 默认不支持长连接，需要设置keep-alive参数指定
        - 长连接是使用同一个[TCP](https://baike.baidu.com/item/TCP?fromModule=lemma_inlink)连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。
     2. 强缓存expired、协商缓存last-modified\if-modified-since 有一定的缺陷
   - 1.1
     1. 默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请
        求在一个Tcp中是串行的)
     2. 增加了强缓存cache-control、协商缓存etag\if-none-match 是对http/1 缓存的优化

   - 2.0
     - 多路复用
       - http1.1浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞，可以通过多CDN(content delivery network）解决同一域名请求的数量限制。
       - ![http1.1请求数量限制.jpg](./legend/http1.1请求数量限制.jpg)
       - 而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的<strong>请求-响应</strong>
       - ![](./legend/http2.0多路复用.jpg)
     - 服务器推送
       - 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。比如说一个页面
       - 服务器推送还有一个很大的优势：可以缓存
     - 二进制分帧
       - 在应用层与传输层之间加了一个分帧层
       - HTTP/2 会将所有传输的信息分割为更小的消息和帧
       - 实现低延迟和高吞吐量
     - 首部压缩

8. cookie和session的区别：

   - 二者都用于会话跟踪。**Cookie通过在客户端记录信息确定用户身份（克服http无状态）**，**Session通过在服务器端记录信息确定用户身份**。
   - cookie数据存放在客户的浏览器上（不是很安全），session数据放在服务器上。
   - session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   - 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

9. 输入URL到展现页面的全过程

   - DNS 解析、TCP 连接、发送HTTP 请求、服务器处理请求并返回HTTP 报文、浏览器解析渲染页面、连接结束

10. [针对主动注册类设备，怎么实现从公网连接到服务内网？这个建立数据连接的过程是怎么做的？](https://blog.csdn.net/sunsineq/article/details/128575588)

    - 端口映射：设备通过公网ip:port通过网关（路由器WAN口）映射到内网一台电脑的某一个端口上。由内网电脑提供服务。
      - 内网的WAN必须要有公网IP。公网IP可以通过公司的名义向通信运营商申请
    - 建立专用网络：要运营商建立专线，将两个或几个地方连接起来。建立专线成本高，一般只有公安，交通部门能这样搞。
    - VPN：虚拟专用网络，在公用网络上建立专用网络，进行加密通讯。
      - 某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问
    - 内网穿透：在服务器上装一个软件（代表：花生壳），然后做设置。花生壳给你一个域名，将这个域名与你的一个服务进行映射。此后别人访问这个域名即可，实际上这个域名，在花生壳的服务器上做了一次解析，同时进行了数据的中转（他们是这么声称的）。
    - 建立虚拟局域网：在第三方服务器上申请一个虚拟网络ID，然后组网的几个电脑都安装软件，然后并输入这个ID，然后，服务器与软件一起，为这些软件都建立一个虚拟的网络IP，然后这些电脑的的虚拟网络IP是一个号段的，有第三方服务器负责路由、中转、穿透你原来的实际网络

11. 

    

    




# 4 数据库

DDL，DML，DCL，DQL

## 4.1 SQL

1. 数据库设计三大范式

   * 原子性，表的列具有原子性，不可再分解，列不可再分性。
   * 区分性，表的行必须可以被唯一的区分，我们通常设置一个主键（主键 不包含业务逻辑）来实现。行可唯一区分性
   * 一个数据表中应不包含已在其他表中已包含的非主键字段，能推导尽量推导

   - 三范式从前至后满足必要不充分关系，范式不是绝对要求，有时为了方便，还要违反三范式。

2. Mysql引擎的了解

   - MySQL 8.0支持的存储引擎有InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE等。其中，最常用的引擎是InnoDB和MyISAM。

3. 分页及优化

   ```sql
   # 1.limit子句实现
   -- 在所有的查询结果中，返回前5行记录。
   SELECT prod_name FROM products LIMIT 5;
   -- 在所有的查询结果中，从第5行开始，返回5行记录。
   SELECT prod_name FROM products LIMIT 5,5;
   
   #在偏移量非常大的时候，例如 LIMIT 10000,20 这样的查询，这时MySQL需要查询10020条记录然后
   #只返回最后20条，前面的10000条记录都将被抛弃，这样的代价是非常高的。
   
   # 2.利用索引覆盖扫描，并且尽可能查询索引列，然后关联回原表获取所需的内容列
   SELECT prod_name,prod_desc FROM products P 
   RIGHT JOIN  (SELECT prod_id FROM products LIMIT 1,2) AS PID# prod_id建了索引，并查询了尽可能少的列，然后右关联了
   ON P.prod_id = PID.prod_id;
   # 2.扫描
   ```

4. 聚合函数

   - COUNT()、AVG()、SUM()、MAX()、MIN()
   - 经常可以结和GROUP BY用来计算每个分组的情况

5. 表关联

   - 内连接（inner）
   - 外连接（左外，右外，满外，除左，除右，除中），两个重叠圆的各个部分
   - 左外（左连接），右外（右链接）

6. sql中怎么将行转列

   ```txt
   id	userid	subject	score			=>		userid	语文	数学	英语	政治
   1	001		语文		85			  			001		85	90	  95	0
   2	001		数学		90						002		80	95	  80    0
   3	001		英语		95						003		80	95	  90	80
   4	002		语文		80
   5	002		数学		95
   6	002		英语		90
   7	003		语文		80
   8	003		数学		95
   9	003		英语		90
   10	003		政治		80
   ```

   - 解决思路：将记录通过GROUP BY对userid进行分组，每一组里面的每个学科做聚合操作

   ```mysql
   # 如果每个学生只有一条语文记录，那sum score就是她的成绩，如果有多个成绩就是所有单科成绩之和
   SELECT userid,
   SUM(CASE `subject` WHEN '语文' THEN score ELSE 0 END) as '语文',
   SUM(CASE `subject` WHEN '数学' THEN score ELSE 0 END) as '数学',
   SUM(CASE `subject` WHEN '英语' THEN score ELSE 0 END) as '英语',
   SUM(CASE `subject` WHEN '政治' THEN score ELSE 0 END) as '政治'
   FROM tb_score
   GROUP BY userid
   
   # if也是如此，0是它的默认值
   SELECT userid,
   SUM(IF(`subject`='语文',score,0)) as '语文',
   SUM(IF(`subject`='数学',score,0)) as '数学',
   SUM(IF(`subject`='英语',score,0)) as '英语',
   SUM(IF(`subject`='政治',score,0)) as '政治'
   FROM tb_score
   GROUP BY userid
   ```

   

7. sql注入

   - SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。

   - 在一些对SERVER端发起的请求参数中植入一些SQL代码，SERVER端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。

   - ```sql
     # 参数正常
     SELECT * FROM user WHERE username = 'ls' AND password = '123456'
     # 如果username的参数值等于 “ ' or 1=1 #  ”，出现下面的意外操作
     select * from user where username='' or 1=1 #' and password='123456'
     ```

   - 解决：

     - 进行严格的参数校验

     - [sql预编译](https://blog.csdn.net/sangfor_edu/article/details/127571616)

       - sql语句在很多时候都是相似的，就像下面这两条，除了id的值不同，其余没什么不同，如果两条语法树相似的SQL语句都需要经过“词法语义解析优化、制定执行计划、执行并返回结果”这样一个过程，则很容易造成时间的浪费、效率的下降。

       - 所谓预编译语句就是将这类语句中的值用占位符（“?”）替代，可以视为将SQL语句模板化或者参数化

       - 预编译的机制下，用户在向原有SQL语句传入输入值之前，原有SQL语句的语法树就已经构建完成，因此无论用户输入什么样的内容，都无法再更改语法树的结构。至此，任何输入的内容都只会被当做值来看待，不会再出现非预期的查询，这便是预编译能够防御SQL注入的根本原因。

         ```sql
         SELECT username, password FROM users WHERE id=1;
         
         SELECT username, password FROM users WHERE id=2;
         ```

8. 将一个表的部分数据更新到另一张表

   - 可以采用关联（join）和更新（update）的方式

     ```mysql
     update b set b.col1=a.col1, b.col2=a.col2 from a,b where a.id=b.id;
     update b set col1=a.col1, b.col2=a.col2 from b inner join a on a.id=b.id;
     update b set b.col1=a.col1, b.col2=a.col2 from b left Join a on b.id = a.id;
     ```

9. where和having的区别

   - where是针对数据库文件过滤，having是针对查询结果过滤。

     - where可以使用表中有的字段，having中比较的字段只能是前面查询出来有的字段
     - where查询只能使用表里有的字段，不能使用字段的别名，having是可以的。

     ```sql
     select goods_price,goods_name from sw_goods where goods_price > 100
     select goods_price,goods_name from sw_goods having goods_price > 100
     
     # where不能使用ag，因为不能使用字段别名
     ```

   - where先于group by 先于having执行

     - where在分组之前过滤（过滤数据库的行），having在分组之后过滤（过滤分组）
     - where中不能使用聚合函数，而having可以

## 4.2 索引

1. 对索引的理解

   - 索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。

   - 所有列都可被索引，对相关列使用索引是提高查询操作速度的最佳途径。

   - 索引是在存储引擎中实现的，不同的引擎支持不同的索引类型，MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。

   - 索引分类：

     - 单列索引

       - 普通索引，无限制
       - 唯一索引，允许多列设置多个唯一索引，列值可以有多个null，列值要唯一
       - 主键索引，一张表只能有一个主键索引，列唯一且不能为null

     - 全文索引

       - 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找

       - 全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。

         ```mysql
         KEY `name_cid_INX` (`phone`,`address`)
         ```

     - 组合索引

       - 在多个列上建立单独的索引大部分情况下并不能提高MySQL的查询性能。
       - 指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循**最左**前缀集合。
       - 建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。

     - 空间索引

       - 空间索引是对空间数据类型的字段建立的索引

     - 外键索引

   - 优点：

     - 大大加快数据的查询速度
     - 加速表和表之间的连接。
     - 降低查询中分组和排序的时间。
     - 通过索引的唯一性，可以保证数据库表中的每一行数据的唯一性

   - 缺点：

     - 索引的存储需要占用磁盘空间；
     - 当每次执行CUD操作时，索引也需要动态维护，降低了数据的维护速度。随着数据量增大，维护时间愈长

1. 如何创建和保存mysql的索引

   ```mysql
   #1.已存在表上，添加索引
   # ALTER方式
   ALTER TABLE 表名 ADD [PRIMARY | UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [索引名] (字段名) [ASC | DESC] ;
   # CREATE方式
   CREATE [PRIMARY | UNIQUE | FULLTEXT | SPATIAL] INDEX 索引名 ON table_name (字段名 [length],...) [ASC|DESC]
   
   #2.创建表时，添加索引
   CREATE TABLE table_name(
   	[col_name data_type],
       ...
       [PRIMARY|UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [index_name] (col_name [length]) [ASC|DESC],
       ...
   )
   
   #3.删除索引
   ALTER TABLE 表名 DROP INDEX 索引名;
   DROP INDEX 索引名 ON 表名;
   ```

   

1. mysql 怎么判断要不要加索引（索引的合理性）

   - 频繁查询：

     - 较频繁的作为查询条件的字段应该创建索引

     - **不会出现**在WHERE子句中的字段不该创建索引
     - 在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。

   - 频繁更新：

     - 更新非常频繁的字段不适合创建索引
     - 避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。

   - 唯一性：

     - 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件。如状态字段、类型字段

     - 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。

   - 参与列计算的列不适合建索引。

   - 数据比较少的表不需要建索引；

1. [创建了索引，就一定会走索引吗？](https://zhuanlan.zhihu.com/p/66099093)，索引失效，

   - ```mysql
     # 不走索引情况
     # 1.查询条件在索引列上使用函数操作,或者运算的情况
     select * from student where abs(age) =18;
     # 2.查询条件字符串和数字之间的隐式转换
     select * from student where name=88;
     # 3.特殊修饰符 like %xx（左模糊）, 关键字“Or”将不走索引
     select * from student where name like'%name' ;
     select * from student where name ='name' or age = 18;
     # 左模糊不能使用索引，而右模糊可以使用索引
     # 4.使用组合索引的时候，如果没有遵从“最左前缀”的原则进行搜索，则索引是不起作用的。
     ```

   - 索引优化器选择最优索引，索引基数（不同值的行数）越大，那么区分度越高，查询速度越快。

     - 指定优化器执行固定索引force index，或者忽略某些索引ignore index

       ```mysql
       select * from student force index(idx_name) where name like 'name%';
       ```

1. 索引覆盖

   - select的数据列只用从索引中就能够取得（索引中存储有所需查询的数据的值），不必回表读取数据行。

1. explain

   - explain命令是查看MySQL查询优化器如何执行查询的主要方法，可以很好的分析SQL语句的执行情况。

   - id，select type，table，partitions，type，possible_key，key，key_len，ref，rows，filtered，extra

   - 重点关注：

   - | 列名    | 备注                                                         |
     | ------- | ------------------------------------------------------------ |
     | type    | 本次查询表联接/访问类型，从这里可以看到本次查询大概的效率。  |
     | key     | 最终选择的索引，如果没有索引的话，本次查询效率通常很差。     |
     | key_len | 本次查询用于结果过滤的索引实际长度。                         |
     | rows    | 预计需要扫描的记录数，预计需要扫描的记录数越小越好。         |
     | Extra   | 额外附加信息，主要确认是否出现 Using filesort、Using temporary 这两种情况 |

1. 如何判断数据库的索引有没有生效

   - 通过explain关键字分析select语句
   - possible_keys行给出了MySQL在搜索数据记录时可选用的各个索引。
   - key行是MySQL实际选用的索引。

1. Mysql的hash索引和B树索引的区别

   - hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表（hash表）查询获得实际数据。hash表映射了键值和数据存储的地址。
   - BTREE：多路平衡查找数，每一次查询都是从根节点出发，查到叶子结点获取地址（回表查询）或数据
   - 区别：
     - hash索引进行等值查询更快(一般情况下)，而BTREE可进行范围查询。
     - hash不支持索引排序、模糊和组合索引的最左匹配，也是因为hash函数的不可预测。
     - hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
     - hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
   - 因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。
   
1. [索引实现原理](https://blog.csdn.net/weixin_45525272/article/details/126483797)

   - MyISAM

     - MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址

     - MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

     - 辅助索引和主索引没有什么区别，只是主索引不能有重复的值

     - 下图为col1字段做索引的存储原理图

       ![B+Tree索引实现原理.png](./legend/B+Tree索引实现原理.png)

   - InnoDB

     - InnoDB也使用B+Tree作为索引结构，但实现完全不一样。叶节点data域保存了完整的数据记录。
     - InnoDB的数据文件本身就是索引文件。**索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引**。
     - InnoDB的辅助索引data域存储相应记录**主键的值而不是地址**。
     - 聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录
     - innoDB不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大
     - 用非单调的字段作为主键在InnoDB中不是个好主意，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的
       特性而频繁的分裂调整
     - <img src="./legend/innoDB_索引实现原理.png" style="zoom:67%;" />

     

     

1. 聚簇索引和非聚簇索引有什么区别？

   - 在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。
   - 聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。
   - 辅助索引是根据索引键创建的一棵B+树，其叶子节点仅存放索引键值，以及该索引键值指向的主键。
   - 通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。

1. 数据库索引重建过程

   - 什么时候需要重建索引

     - 表记录频繁发生update,delete操作；
     - [表发生了alter table ..move操作（move操作导致了rowid变化）](https://blog.csdn.net/gumengkai/article/details/51019998)。[参考二](https://blog.csdn.net/royzhang7/article/details/39317213)
       - 1.用来移动table到其他表空间
       - 2.用来减少table中的存储碎片，优化存储空间和性能

     ```mysql
     # 移动表空间
     alter table scott.change_tbs move tablespace roy;
     # 重建索引
     alter index scott.PK_1 rebuild online tablespace roy;
     ```

   - 怎么判断索引是否应该重建？

     - 一般看索引是否倾斜的严重，是否浪费了空间，对索引进行结构分析：

       ```mysql
       analyze index index_name validate structure;
       ```

     - 在相同的session中查询index_stats表

       当查询的height>=4（索引的深度，即从根到叶节点的高度）或DEL_LF_ROWS/LF_ROWS>0.2的情况下，就应该考虑重建该索引。

     ```mysql
     select height,DEL_LF_ROWS/LF_ROWS from index_stats;
     ```

   - 如何重建索引？

     - drop原索引，然后再创建索引，相当耗时，一般不建议使用。

       ```mysql
       drop index index_name;
       create index index_name on table_name (index_column);
       ```

     - 直接重建索引

       - rebuild是快速重建索引的一种有效的办法，因为它是一种使用现有索引项来重建新索引的方法。
       - 如果重建索引时有其他用户在对这个表操作，尽量使用带online参数来最大限度的减少索引重建时将会出现的任何加锁问题
       - 由于新旧索引在建立时同时存在，因此，使用这种重建方法需要有额外的磁盘空间可供临时使用，当索引建完后把老索引删除，如果没有成功，也不会影响原来的索引。利用这种办法可以用来将一个索引移到新的表空间。

       ```mysql
       alter index indexname rebuild;
       alter index indexname rebuild online;
       ```

1. MySQL的索引为什么用B+树?

   - B+树是在B树和索引顺序访问演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树
   - B+树索引在数据库中的一个特点就是高扇出性，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。

1. 联合索引的存储结构是什么？

   - 联合索引是指对表上的多个列进行索引，联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。
   - 从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2
   - ![](./legend/联合索引的存储结构.jpg)

1. 模糊查询语句中如何使用索引

   - 左模糊无法使用索引，建立需要左模糊查询的反转字段reverse_field（冗余列），再使用reverse_field like reverse("%xxx");

## 4.3 事务

1. 事务的理解

   - 事务是一个最小的不可在分的工作单元；通常一个事务对应一个完整的业务

   - 事务只和DML（insert、update、delete）语句有关，或者说DML语句才有事务。

   - 事务可以保证一组操作（SQL语句）要么都成功要么都失败。

   - 四大特性（ADIC）：

     - 原子性：一组sql语句要么全成功，要么全失败。操作的执行可撤销，状态可回归
     - 持久性：事务一旦提交，其结果就是永久性的，保证事务的可靠性。
     - 隔离性：多个事务之间相互隔离的，互不干扰。多个事务并发执行，各事务独立进行。通常使用锁来实现。
     - 一致性：保持逻辑的合理性，有增必有减。前三性（ADI）来保证一致性，一致性是目的，前三性是手段。

   - 事务可以分为以下几种类型：

     - 扁平事务：

       - 所有操作都处于同一层次，
       - 其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于这之间的操作是原子的，要么都执行，要么都回滚。

     - 带有保存点的的扁平事务：

       - 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态

       - 这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。

       - 保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。保存点只能使用在当前事务中。

       - ```mysql
         BEGIN;
         ...
         # 创建或覆盖同名保存点
         SAVEPOINT test;
         ...
         # 状态回滚到保存点
         ROLLBACK TO [SAVEPOINT] test;
         ...
         # 删除保存点
         RELEASE SAVEPOINT test;
         ...
         ```

     - 链事务

       - 上一个事务的提交操作和下一个事务的开始操作将合并为一个原子操作。
       - 这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。

     - 嵌套事务

       - 由一个顶层事务控制不同层次的事务。
       - 嵌套在顶层事务下的事务叫做子事务，它控制着每个局部的变化。
       - 子事务提交后，不会真正提交，而是等到父事务提交后才真正提交，父事务回滚，所有子事务都会回滚。
       - MySQL数据库不支持嵌套事务。

     - 分布式事务

       - 通常是一个在分布式环境下运行的扁平事务
       - 对于分布式事务，同样需要满足ACID特性

2. redo log、undo log、binlog

3. MVCC

4. Mysql主从同步

5. 隔离性实现原理

   - 隔离性追求的是并发情形下事务之间互不干扰，主要考虑最简单的读操作和写操作
   - 连个并发事务T1和T2
   - T1写对T2写的影响：锁机制保证隔离性
     - 隔离性要求同一时刻只能有一个事务对数据进行写操作，
     - InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。
     - 按照粒度，锁可以分为表锁、行锁（间隙锁，记录锁，临键锁），行锁并发性能好，但加锁本身需要消耗资源，所以锁住的数据较多的情况下，可以使用表锁
     - MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁
   - T1写对T2读的影响：MVCC保证隔离性。
     - InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题。
     - 它使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，
     - MVCC主要基于以下技术及数据结构
       - 额外隐藏字段：每行数据都有被隐藏的额外数据，包含本行数据的事务id、指向undo log的指针等
       - 基于undo log的版本链：
         - 每行数据的隐藏列中包含了指向undo log的指针，
         - 而每条undo log也会指向更早版本的undo log，从而形成一条版本链。
       - ReadView：通过隐藏列和版本链，数据可以追溯不同的版本。
         - 是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。
   - 

6. 隔离级别

   - 隔离机制的实现机制
     - READ UNCOMMITTED & READ COMMITTED：
       - 通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。
       - 而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。
     - REPEATABLE READ：
       - 使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据（MVCC），所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。
     - SERIALIZABLE：
       - 为每个读取操作加一个共享锁
   
   | 隔离级别                      | 脏读   | 不可重复读 | 幻读   |
   | ----------------------------- | ------ | ---------- | ------ |
   | read uncommitted              | 可能   | 可能       | 可能   |
   | read committed                | 不可能 | 可能       | 可能   |
   | repeatable read（InnoDB默认） | 不可能 | 不可能     | 可能   |
   | serializable                  | 不可能 | 不可能     | 不可能 |



## 4.4 锁

1. 锁的分类
   - 共享锁（读锁，可读不可写），排它锁（写锁，不可读不可写）
   - 按粒度分：表锁，行锁（记录锁，间隙锁，临键锁）
   - 悲观锁（先锁后修改），乐观锁（先写再冲突检查，MVCC）。
   - 具体参看mysql
2. 死锁
   - 死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。
   - 解决：
     - 超时机制：当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
     - 等待图检测机制：锁的信息链表、事务等待链表。链表如构成回路，就代表存在死锁，若存在死锁，选择回滚量最小的事务去回滚
3. 锁升级
   - 指将当前锁的粒度增大，eg：数据库可以把一个表的1000个行锁，升级为一个页锁，或者将页锁升级为表锁。
   - innoDB不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。
4. InnoDB中行级锁是怎么实现的
   - InnoDB行级锁是通过给索引上的索引项加锁来实现的。只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
   - 当表中锁定其中的某几行时，不同的事务可以使用不同的索引锁定不同的行。另外，不论使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。

## 4.5 优化

1. 数据库优化

   - MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。

   - 数据库优化分为四个纬度：硬件，系统配置，数据库表结构，SQL及索引

   - 硬件： CPU、内存、存储、网络设备等

   - 系统配置： 服务器系统、数据库服务参数等

   - 数据库表结构：高可用（避免单点服务，自动故障转移）、分库分表、读写分离、存储引擎、表设计等

   - Sql及索引： sql语句、索引使用等

   - 如：

     - 通过优化文件系统，提高磁盘I\O的读写速度；

     - 通过优化操作系统调度策略，提高MySQL在高负荷情况下的负载能力；
     - 优化表结构、索引、查询语句等使查询响应更快。

2. 优化mysql的查询

   - 合理使用索引，查看索引那一节
   - 优化子查询（会产生临时表），连接查询（不产生临时表）代替子查询

3. 如何插入数据更有效

   - 对于MyISAM：
     - 禁用索引：为大量插入数据建立索引，会降低插入的速度，所以可以在插入记录之前禁用索引，数据插入完毕后再开启。
     - 禁用唯一性校验：用业务代码保证需要插入的数据已是唯一的，然后在插入之前禁用唯一性校验，插入后再开启
     - 批量插入：insert插入多条记录
     - 使用LOAD DATA INFILE语句
   - 对于InnoDB的表
     - 禁用唯一性检查
     - 禁用外键检查
     - 禁用事务的自动提交：InnoDB数据库引擎是支持事务的，可以先禁用事务自动提交，等数据插入完成，再启用事务自动提交。

4. 表中包含几千万条数据该怎么办

   - 优化sql和索引
   - 增加缓存，如memcached、redis；
   - 读写分离，
     - 数据库写入效率要低于读取效率，一般系统中数据读取频率高于写入频率，单个数据库实例在写入的时候会影响读取性能，这是做读写分离的原因。
     - 实现方式主要基于mysql的主从复制，通过路由的方式使应用对数据库的写请求只在master上进行，读请求在slave上进行。
     - 在应用和数据库之间增加代理层，代理层接收应用对数据库的请求，根据不同请求类型转发到不同的实例，在实现读写分离的同时可以实现负载均衡。
   - 使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的
   - 分表：
     - 垂直拆分，水平拆分
     - 表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。

5. 慢查询优化

   - ```mysql
     SHOW VARIABLES LIKE '%slow%';
     SET GLOBAL log_slow_ queries = ON ;#开启慢查询日志
     
     SHOW VARIABLES LIKE '%long%';
     SET long_query_time = 0.5;#设置快慢的时间标准，long_query_time只影响当前session
     
     SHOW VARIABLES LIKE '%slow%';#这个语句也可以查看慢查询日志文件放在什么位置
     
     #在日志中找到查询慢的语句后，用explain分析语句sql语句
     EXPLAIN sql语句;
     ```

   - 常见慢查询优化：

     - 索引不起作用
     - 优化数据库结构
       - 字段较多的表，将使用频率低的字段分离出来形成新表，因为一个表的数据量很大的时候，会由于使用频率低的字段的存在而变慢。
       - 对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合（union）查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。
       - 分解关联查询，对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。
       - 优化LIMIT分页



# 5 设计模式

## 七大原则

1. 单一职责原则：粒度分解（类级别和方法级别）
2. 接口隔离原则：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
3. 依赖倒转原则：依赖抽象而不依赖细节，面向接口编程。
4. 里氏替换原则：指导如何使用继承的原则，子类尽量不要重写父类的方法，引用基类的地方可以使用子类透明的替换，尽量少使用继承。
5. 开闭原则ocp：扩展而不是修改已有细节
6. 迪米特法则：只与直接的朋友通信，最少知道原则。
7. 合成复用原则：尽量少使用继承，而使用组合和聚合的方式。

谐音记忆：丹姐依你，开底盒

## 创建型

- 单例模式：懒汉式，饿汉式，还要考虑线程安全的问题，双重检查（推荐）

  ```java
  //用到的时候创建
      public static Singleton getInstance(){
          if(instance==null){
              //加了线程同步排队synchronized
              synchronized(Singleton.class){
                  if(instance==null){
                      instance=new Singleton();
                  }
              }
          }
          //当第一次多线程A，B（或者更多）都通过了第一重检查，都进入排队阶段。
          //A先进入synchronized代码块，执行代码内容，使instance实例化。
          //B（或者更多）在排队等候后，同样再判断，但不执行实例化。
          //但是在之后线程访问中，在第一重检查就会拦下，直接执行返回
          //因为instance已经实例化，就不会再进入synchronized代码块，无需再执行排队等待操作。
          //效率提高
          return instance;
      }
  ```

- 工厂模式

  ```java
  //普通方式，在使用者里直接构造对象，违反了开闭原则，对使用者关闭修改，对开发者打开扩展
  
  //简单工厂
  // 使用者，通过简单工厂生产对象
  pizza = this.simpleFactory.createPizza(orderType);
  // 开发者，提供createPizza方法。
  
  //工厂方法，工厂方法将实例化推迟到了子类，
  public abstract class OrderPizza {
      abstract Pizza createPizza(String orderType);
      public OrderPizza() {
          pizza = createPizza(orderType); 
      }
  }
  public class BJOrderPizza extends OrderPizza {
      @Override
  	Pizza createPizza(String orderType) {	}
  
  }
  ```

- 抽象工厂模式

- 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象（拷贝）

- 建造者模式：

## 结构型

- 适配器模式
- 桥接模式
- 装饰模式
- 组合模式
- 外观模式
- 享元模式
- 代理模式

## 行为型

- 模板方法模式
- 命令模式
- 访问者模式
- 迭代器模式
- 观察者模式
- 中介者模式
- 备忘录模式
- 解释器模式
- 状态模式
- 策略模式
- 职责链模式

# 6 数据结构与算法

## 数据结构

程序=数据结构+算法

数据结构=逻辑结构+存储结构+数据的运算

逻辑结构：

- 线性结构（一对一）：线性表，栈，队列，串
- 非线性结构：树（一对多），图（多对多）

存储结构：

- 顺序存储：逻辑和存储都是相邻的
- 链式存储：强调元素之间的逻辑关系
- 索引存储：建立索引表
- 散列存储：hash存储

数据的运算：

- 运算的定义是针对逻辑结构的
- 运算的实现是针对存储结构的

## [排序](https://www.cxyxiaowu.com/725.html)

稳定性：就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。

不稳定：选择，希尔，快速，堆

![十大排序比较.png](./legend/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png)

1. 插入排序：找位置，腾位置，入座
   - @desc 插入法：如同打扑克摸牌，一边摸一边整理手上牌的顺序，手上的牌是有序的，将摸到的牌插入有序的牌中。
    - 由于是数组，分成三步，
    - 1.找到插入的位置，2.移动数组，3.插入
2. 希尔排序：分区间，跨区间，缩小区间。
   - 希尔排序：事先定义一个区间，通过区间对数组分组（就像排队报一二三，报到一的一个组，报到二的一个组，报到三的一个组，这里的三就是区间大小）
    - 在数组上从前至后，移动起始位置，以这个位置找组内元素。
    - 跨区间移值：将组内元素按照插入法的方式排序（在原数组上进行操作的话，就是将区间的两头进行比较，最后保证第一个元素的下标大于零，比较结束）
    - 然后区间逐渐缩小，直到gap=0
3. 归并排序：
   - 分而治之，将一个大问题分解成无数的小问题进行处理，处理之后再合并。
4. 快速排序
   - 分治
   - 把目标数组所有值都扫描一遍，以目标数组第一个值为std，以mark作为指针。
   - 一旦找到比std小的，就与mark指针所指的元素做交换，交换后，mark自加一。
   - 最后mark所指的位置就是左右序列的分界线（除数组第一个元素std外）
5. 计数排序：高考分数排名
   - 计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。
6. 桶排序：计数的坑里排序
   - 计数排序是一个坑一个数，桶排序是一个坑多个数，然后坑里再进行排序。
7. 基数排序：数字按位比较
   - 基数排序是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。

## 查找

查找算法分类：

- 动态查找和静态查找：有无插入和删除记录的操作
- 无序查找和有序查找：被查找数列是否有序

算法实现：

1. 顺序查找：
2. 二分查找：折半查找
3. 插值查找：区间自适应
4. 斐波那契查找：按照斐波那契序列的特点对有序表进行分割的
5. 树表查找：b树，b+树，红黑树
6. 分块查找：区间之间有序，区间内无序
7. 哈希查找：

## 基本算法思想

1. 分治
2. 贪心
3. 动态规划
4. 回溯
5. 递归与迭代。

## 树

二叉树：

- 平衡树：
  - 左右子树高度差（简称平衡因子）的绝对值不超过1
  - 左右子树都是AVL树
- 红黑树
  - 其最长路径中节点个数不会超过最短路径节点个数的两倍，因而是接近平衡的。

多路（多叉）

- [B树](https://blog.csdn.net/mhhhb/article/details/111856049)（B-树，Balance Tree）：是一种多路平衡查找树，m阶的B树
  - **根节点至少有两个子女.**
  - **每个中间节点都包含k-1个元素和k个孩子, 其中m/2 <= k <= m**
  - **每一个叶子节点都包含k-1个元素, 其中m/2 <= k <= m**
  - **所有的叶子节点都位于同一层**
  - **每个节点中的元素从小到大排列, 节点当中k-1个元素正好是k个孩子包含的元素的值域划分.**
- B+树
  - 有k个子树的中间节点包含有k个元素(B树中是k-1个元素), 每个元素不保存数据, 只用来索引, **所有数据都保存在叶子节点。**
  - 所有的叶子节点中包含了全部元素的信息, 及指向含这些元素记录的指针, 且叶子节点本身依关键字的大小自小而大顺序链接.
  - 所有的中间节点元素都同时存在于子节点, 在子节点元素中是最大(或最小)元素.

# shell

变量，程序结构，数组，函数，文本处理（grep，sed，awk）

# nginx



# gcc/make/gdb

## gcc

静态库和动态库

## gdb

```bash
gcc -g -o book113 book13.c
gdb book113

# 常用命令
# 查看相关
l,where，p，display，undisplay
# 断点相关
r, b,info
# 逐步调试
s,n

# 父子进程
set follow-fork-mode child
set detach-on-fork off
inferior 进程id	# 切换

# 线程
set scheduler-locking on
thread 线程id		# 切换

#调试core文件
#调试正在运行的程序，一旦调试，源程序阻塞，直到离开
gdb book -p 21495 # -p，进程号
#日志
```

## makefile

目标，依赖，命令，依赖链，自动推导（为.o自动找.c）

# 网络安全






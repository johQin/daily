# C

1. C语言因UNIX系统而生。
2. GNU（GNU's Not UNIX）项目始于1987年，是一个开发大量自由UNIX软件的集合。
3. GCC——GNU编译器集合（GNU Compiler Collection，GCC），
   - 其中包含GCC C编译器。
   - GCC有各种版本以适应不用硬件平台和操作系统，包括UNIX，LINUX，Windows
   - gcc命令便可调用GCC C编译器，许多系统都用cc作为gcc的别名
4. c语言优点
   - 高效性，快速
   - 可移植性，找到合适的编译器，就能在源代码的基础上，稍作修改或不修改就能在其他系统运行



# 0 绪论

## 0.1 C语言标准

1. 第一个C标准——ANSI/ISO 标准——C90，ANSI/ISO标准的最终版本通常叫做C89（ANSI于1989年批准该标准）或C90（ISO于1990年批准该标准）
2. C99——1999年
3. C11——2011年

## 0.2 编程机制

1. 源代码：在文本编辑器中，敲入的复合语法规范的代码
2. 预处理器：
   - 在c程序顶部的信息集合被称为头文件，头文件包含了编译器创建最终可执行程序要用到的信息。
   - `#include`这行代码就是一条预处理器指令
3. 编译器：
   - 编译器把源代码转换为中间代码（目标代码），链接器把中间代码和其他代码合并生成可执行代码。
   - 编译器可检测出不符合C语言规范的语法错误，无法检测出语义错误（也就是代码逻辑），报错的位置比真正错误滞后一行。
4. 链接器
   - 把目标代码、系统标准启动代码和库代码这三个部分合并成一个可执行文件
   - 目标代码只包含编译器为你编写的代码翻译的机器语言代码。
   - 可执行文件中还包含你编写的程序中使用库函数和启动代码的机器代码

![](./legend/编译器和链接器.jpeg)

## 0.3 HelloWorld

```c
#include<stdio.h>	/*头文件，预处理器指令，包含了编译器创建最终可执行程序要用到的信息*/
// c程序一定从main()函数开始执行
int main(void) {	// 花括号用于标记函数体和块
    
    int num1, num2 = 3; 
    
    // 声明变量，为变量创建和标识存储空间
    // int c语言关键字，关键字语言定义的单词，不能作他用。
    // num1是一个标识符，
    // 命名规则：
    // 首字符：下划线和字母
    // 非首字符：字母、数字、下划线
    
    num1 =1; // 赋值语句
    
    printf("The C Language is simple %d", num1); 
    // print + format，
    // %d 占位符，指明num1将以什么样的形式和位置出现
    
    // 调用函数看，称为回调函数
    butler();
    return 0; // 返回值
}
// 定义函数
void butler() {
    printf("you rang, sir?\n")
}
```

程序状态是在程序执行过程中，某给定点上所有变量的集合，它是计算机当前状态的一个快照。

## 0.4 关键字和保留字

![](./legend/C语言关键字和保留字.jpeg)

# 1 顺序结构

## 1.1 常量和变量

1. 常量：
   - 整型常量，eg：1,123，-345
   - 实型常量，包含两种形式，小数形式，指数形式，**按双精度处理**
   - 字符常量：
     - 普通字符（单引号括起来的单个字符）
     - 转义字符（以反斜杠开头的具有特殊意义的字符）
     - 字符串常量（双引号括起来的若干字符）
     - 符号常量
       - 用`#define`指令指定用一个符号名称代表一个常量，eg：`#define PI 3.1415`
2. 变量
   - 变量必须先声明后使用，并且尽量初始化。
   - 变量名实际上是一个名字代表的存储地址
3. 常变量（C99）
   * `const float pi=3.1415`
   * 有类型，占用存储单元，值不可变
4. 标识符：只能由字母、数字、下划线组成，并且以字母或下划线为首。

## 1.2 数据类型

1. 基本类型
   - 整型类型
     - 整型（int，2个or4个字节），无符号整型（unsigned int）
     - 短整型（short int，2个字节），无符号短整型（unsigned short int）
     - 长整型（long int，4个字节），双长整型（long long int，8个字节），无符号...
     - 字符型（char，1个字节），有符号（)，无符号（0~2^8）
     - 布尔型（bool）
   - 浮点类型（以小数或指数形式出现）
     - 单精度浮点型（float，4个字节）
     - 双精度浮点型（double，8个字节），长双精度（long double，8or 16个字节）
     - 复数浮点型（float_complex，double_complex， long long_comple)
2. 枚举类型（enum）
3. 空类型（void）
4. 构造类型
   - 数组（[ ]）
   - 结构体（struct）
   - 共用体（union）
5. 指针类型
6. 函数类型



构造类型、指针类型、函数类型也可以称作是派生类型

字符类型是按其代码（整数，ASCII码）形式存储的，因此C99把字符型数据作为整数类型的一种

```c
float a = 3.1415;
// 在进行编译时，对float变量分配4个字节，而实型常量3.1415会按照双精度处理
// warning:trunction from 'const double' to 'float'
// 可以在常量的末尾加专用字符，强制指定常量的类型
float a= 3.1415f;
long double b = 1.23L;
```

## 1.3 运算符

1. 算术运算符，`+ - * / % ++ --`
2. 关系运算符，`> < == >= <= !=`
3. 逻辑运算符，`! && || `
4. 位运算符，`<< >> ~ | ^ &`
5. 赋值运算符，`= += -=等`
6. 条件运算符（三目运算符），`cond ? t_exp : f_exp`
7. 逗号运算符
8. 指针运算符，`* &`
9. 字节数运算符，`sizeof`
10. 强制类型转换符，`(type_name) (exp)`
11. 成员运算符， `.->`

```c
// 1.算术运算符
// 取余%，两边的操作数必须为整型
// 自增自减，不能用于常量和表达式

// 自动类型转换：不同类型数据间的混合运算，往大容量数据类型转化
// 强制类型转换：将表达式的值转换成所需类型。
// 字符型数据（ASCII码，即数值）与整型数据进行运算。
(type_name) (expression);
(int) (x + y);
(float) (5 % 3);
```

## 1.4 数据的输入输出

c语言函数库中有一批“标准的输入输出函数”，它是以标准的输入输出设备（一般为终端设备）为输入输出对象。

其中有：

1. `putchar('输出字符')，getchar('输入字符'),`
2. ``printf(格式输出)，scanf(格式输入)`
3. `puts("输出字符串")，gets("输入字符串")`

### 1.4.1 printf

一般格式：

**printf("格式控制", 输出列表)**

格式声明：
   **% 修饰符 格式字符**

```c
printf("%d %d\n",a, b);
// 格式控制包括：
// %d 格式声明，做占位和格式指定
// 普通字符，原样输出
// 格式控制必须有
```

| 格式字符 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| **d，i** | 以十进制形式输出整数（正数无符号）                           |
| **o**    | 八进制（不输出前导符0）                                      |
| **x，X** | 十六进制（不输出前导符0x），x小写字母，X大写字母形式，输出a-f |
| **u**    | 以无符号输出整数                                             |
| **c**    | 以符号形式输出，只输出一个字符                               |
| **s**    | 输出字符串                                                   |
| **f**    | 以小数形式输出单双精度，默认输出6位小数                      |
| **e，E** | 以指数形式输出实数，                                         |
| **g，G** | 选用%f或%e格式中输出宽度较短的一种格式，不输出0              |

| 修饰符  | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| **l**   | 用于长整型整数，可在格式符d，o，x，u                         |
| **m.n** | m：指定数据占用的总位数。n：指定小数的位数，长度不够时，左端补空格 |
| **-**   | 数据长度不够时，数据向左靠，右端补空格                       |

```c
// %d
printf("%5d\n%5d\n",12,-345);
   12//前面有三个空格，指定数据能占用的总位数为5
 -345 //前面有一个空格

// %c
printf("%c",'a');
a
short b = 121;
printf("%c", b);
y
// 0~127 范围内的数字，在以%c的形式输出时，将会转化为ASCII码对应的字符
int c = 377;
printf("%c", c);
y
// %c只考虑一个字节，对于两字节的int，只看后一个字节的数据，即十进制的121，是ASCII码中的y
    
// %f
printf("%f\n",1/3);
0.333333 //默认6位小数
printf("%20.15f\n",1/3);
0.333333333333333 //15位小数，0前面还有3个空格
printf("%-20.15f\n",1/3);
0.333333333333333 //15位小数，最后一个3后面还有3个空格

// %e
printf("%e", 123.456);
1.234560e+002 // 默认小数为6位数，指数占5列，e为1列1 +为1列 002为3列
printf("%13.2e", 123.456);
1.23e+002 //1前面还有4个空格
```

如果想原样输出%号，需要连续使用两个%表示

### 1.4.2 scanf

一般形式：

**scanf("格式控制", 地址列表)**

注意：

1. 地址列表应当是变量的地址名，而不是变量名
2. 在输入数据时，应在对应的位置输入同样的字符
   - 输入数值时，在两个数值之间需要插入空格或其他分割符（回车，tab，不属于数值的字符），以使系统得以区分两个数值
   - 在连续输入字符时，在两个字符之间不要插入空格或其他分割符
3. 

| 格式字符       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **d，i**       | 用来输出有符号的十进制整数                                   |
| **u**          | 用来输入无符号的十进制整数                                   |
| **o**          | 用来输入无符号的八进制整数                                   |
| **x，X**       | 用来输入无符号的十六进制（不输出前导符0x），x小写字母，X大写字母形式，输出a-f |
| **c**          | 用来输入单个字符                                             |
| **s**          | 用来输入字符串，将字符串送到字符数组中，以非空白字符开始，以空白符结束，字符串以`\0`作为其最后一个字符 |
| **f**          | 用来输出实数，可以用小数形式或指数形式输入                   |
| **e，E，g，G** | 与f作用相同，e与f，g可以互相替换                             |

| 修饰符  | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| **l**   | 用于长整型数据（可用%ld，%lo，%lx，%lu）以及double型数据（用%lf或%le） |
| **h**   | 用于短整型数据（可用%ld，%lo，%lx）                          |
| **m.n** | 域宽                                                         |
| *****   | 表示本输入项在读入后不赋给相应的变量                         |

```c
#include<stdio.h>
#include<math.h>
int main() {
    double a,b,c,disc,x1,x2,p,q;
    scanf("%lf%lf%lf",&a,&b,&c); 
    // %lf,将输入的数值转化为浮点型。
    // 三个数的输入，之间用空格隔开，不能用逗号
    
    disc = b*b - 4*a*c;
    p = -b/(2.0*a);
    q = sqrt(disc) / 2.0*a;
    x1 = p+q;
    x2 = p-q;
    
    // %7.2f，指定数据占7列，小数占两列
    printf("x1=%7.2f\nx2=%7.2f\n",x1,x2);
}
```

### 1.4.3 putchar

putchar函数是输出字符的函数，它输出的是字符而不能输出整数。

对于0~127的整数，会输出对应ASCII值得字符

### 1.4.4 getchar

从终端获取一个字符。

注意：

getchar不仅可以从终端获取一个可显示的字符，而且可以获取在屏幕上无法显示的字符，例如回车

```c
#include<stdio.h>
int main() {
    char a,b,c;
    a = getchar();
    b = getchar();
    c = getchar();
    
    // 一定要在连续输入BOY之后再敲回车，否则回车会被下一个getchar捕获
    putchar(a);
    putchar(b);
    putchar(c);
    
    putchar('\n');
    return 0;
}
```

# 2 选择结构

## 2.1 if结构

```c
// 1 单判断，没有else
if(expr) 语句1;

// 2 双判断
if(expr) 语句1;
else 语句2;

// 3 多判断
if(expr1) 语句1;
else if(expr2) 语句2;
else if(expr3) 语句3;
...
else 语句n;
```

注意：

1. 如果语句是复合语句（多语句）需要用花括号括起来。
2. if语句可以嵌套

## 2.2 switch结构

```c
switch(expr){
    case constant1: 语句1;break;
    case constant2: 语句2;break;
    ...
    case constantn: 语句n;break;
    default: 语句n+1;
}
```

注意：

1. expr的值应为整数类型（包括字符型）
2. 每个case的常量必须互不相同
3. 可以没有default语句
4. case后面如果有多个语句可以不用花括号，因为通过case找到语句执行的入口后，后面会顺序执行。所以如果不想入口后面的case执行，就必须添加break
5. 多个case可以共用一个语句

## 2.3 关系与逻辑

运算符之间的优先级：

`！> 算术运算符 > 关系运算符 > && 和 || > 条件运算符（? :）> 赋值运算符`

在c编译系统中，

1. 在表示逻辑运算结果时，以数值1代表为真，以数值0代表为假
2. 在判断一个量时，以非0为真，以0为假。
3. 逻辑运算符两侧的运算对象不但可以是0和1，或者是0或非0，也可以是字符型、浮点型、枚举型或指针型

c99增加逻辑型_Bool变量，

```c
_Bool a;
// 如果使用头文件stdbool.h，bool定义为_Bool的同义词，同时定义了两个符号常量true（代表1）和false（代表0），
```

# 3 循环结构

## 3.1 while结构

```c
// while，当循环条件为真，就执行循环体;
// 先判断，后执行
int i = 1, sum = 0;
while(i <= 100) {
    sum = sum + i;
    i++;
}
// do...while
// 先执行，判断
int i = 1, sum = 0;
do{
    sum = sum + i;
    i++;
}while(i <= 100)
```

## 3.2 for结构

```c
for(expr1; expr2; expr3) {
    //expr1：设置初始条件，只执行一次，可以为0个，但其后的省略号不能省，可以为循环言变量设置初值，也可以是与循环变量无关的表达式
    //expr2: 循环条件表达式，先判断，后执行
    //expr3：循环调整，执行完循环体后执行
    
    //expr1和expr3可以是一个简单的表达式，也可以是逗号分割多个简单表达式。
}
```

## 3.3 循环中断

break：提前终止循环

continue：提前结束本次循环

# 4 数组

## 4.1 一维数组

**1 定义**

**type array_name[constants_expr]**

- constants_expr：可以包含常量和符号常量，不能包含变量

- constants_expr在函数中定义数组，其长度可以为变量或非常量表达式

  ```c
  int arr0[10];
  void func(int n) {
      int arr[2*n];// 此时称为可变长数组
      // 如果指定数组为静态存储方式，则不能用可变长数组
      // 错误eg: static int arr[2*n];
  }
  ```

**2 初始化**

**type array_name[constants_expr] = {initial_list}**

```c
int arr1[10] = {0,1,2,3,4,5,6,7,8,9};
int arr2[10] = {0,1,2,3,4,5}; // 其余5个元素自动赋初值0
int arr3[] = {1,2,3,4,5}; // 数据个数确定，此时可以不指定数组长度

// 如果初始值得个数大于数组长度，则会出现语法错误。如果小于，那些未被初始化的元素将会被自动初始化为默认值
// 如果在定义数值型数组时，指定了数组的长度并初始化（部分元素被初始化），那些未被初始化的元素（部分没有初始化），系统会自动把他们初始化为0。
// 如果是字符型数组，那些未被初始化的元素将被自动初始化为 '\0'
// 如果是指针型数组，那些未被初始化的元素将被自动初始化为 NULL
```

**3 引用**

**array_name[index]**

## 4.2 二维数组

**1 定义**

**`type array_name[constants_expr][constants_expr]`**

```c
float arr[3][4];
// arr[0],arr[1],arr[2]是包含4个元素的一维数组
// c语言，二维数组中元素排列顺序是按行排列的，在内存单元中是连续存放的，是线性的
```

**2 初始化**

```c
// 1.分行对二维数组进行初始化
int arr[3][4] = {
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12}
};
// 2.按内存顺序进行初始化
int arr[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
// 3. 对部分赋初值
int arr[3][4] = {{1}, {5}, {9}};
int arr[3][4] = {{1}, {5,6}, {9,10}};
int arr[3][4] = {{1}, {}, {9}};

// 4.如果对全部元素赋初值，可以不写第1维的长度，但第2维的长度不能省，系统会自动根据数据的个数与第2维的长度计算第1维的长度
int arr[][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
// 5.如果对部分元素赋初值，而省略第1维的长度，须按行赋初值
int arr[][4] = {{1}, {5}, {9}};

// 6.同样如果只初始化部分数组元素，那些未被初始化的元素将会被自动初始化
```

**3 引用**

**`array_name[dim1_index][dim2_index]`**

## 4.3 字符数组

```c
// 字符数组定义、初始化、引用都一样
char arr[10] = {'I', ' ', 'a', 'm', ' ', 'h', 'a', 'p', 'p', 'y'}; // 长度为10
char arr[] ={"I am happy"}; //长度为11，最后一个字符为'\0'，在ASCII码中是空操作符
char arr[] = "I am happy";//长度为11
// 字符数组的每个元素只能存放一个字符
// 如果初值的个数小于数组长度，剩余未被初始化的元素，将会被自动赋值为'\0'
```

### 字符串

C语言中，将字符串作为字符数组来处理。并且规定了一个“字符串结束标志”，以字符'\0'作为结束标志。

### 字符数组的输入输出

```c
char arr[] = "china";
printf("%s", arr);
china

// 如果scanf函数的输入项，如果是字符数组名，不要加地址符&，因为C语言中数组名代表了数组的起始地址。
char arr1[10];
scanf("%s", arr1);

//如果利用scanf输入多个字符，应在输入时以空格分割
char str1[5],str2[5],str3[5];
scanf("%s%s%s",str1,str2,str3);
```

### 字符串处理函数

```c
#include<string.h>
//1.输出字符串函数
puts(字符数组);
//2.输入字符串函数
gets(字符数组);
//3.字符串连接函数
strcat(字符数组1, 字符数组2);
//4.字符串复制函数
strcpy(字符数组, 字符串);//将字符串复制到字符数组中
strncpy(字符数组, 字符串, n); //将字符串中的前n个复制到字符数组中
//5.字符串比较函数
strcmp(字符串1，字符串2); // 两个字符串从左至右逐个字符相比（按ascii值比较），知道出现不同的字符或遇'\0'为止。
// = return 0
// > return +n
// < return -n
//6.字符串长度
strlen(字符串);
//7.大小写转换
strupr(字符串);
strlwr(字符串);

```

# 5 函数

## 5.1 定义函数

```c
#include<stdio.h>
int main(void) {
    //max函数声明
    int max(int x, int y);
    
    int c;
    c = 3 * max(1, 2);//实际参数
    printf("%d\n",c);
}
//1.定义无参函数
void hello() {//无返回值
    printf("你好");
}
int hello(void) {//返回值类型为int
    printf("你好");
    return 1;
}
//2.定义有参函数
int max(int x, int y) {//形式参数
    int z;
    z = x>y ? x : y;
    return z;
}
```

注意：

- 实参可以是常量，变量或表达式，在使用函数时，要求他们有确定的值
- 实参与形参的类型应相同或赋值兼容
- 对于不带返回值得函数，应当定义函数为"**void类型**"，此时在函数体重不能出现return语句
- 形参数组可以不指定大小

```c
float average(float arr[]){
    ...
}
```



## 5.2 函数声明和函数原型

在一个函数中调用另一个函数须具备以下条件：

- 被调函数已定义（是库函数或自定义的函数）
- 如果用到库函数，则需要**#include<*.h>**
- 如果自定义的函数在主调函数的后面（同一文件），则应该在主调函数中对被调用的函数做**声明**，

**声明的作用**：是把函数名、函数参数个数和类型等信息通知编译系统，以便在遇到函数调用时，编译系统能正确识别函数病检查调用是否合法。

函数的声明和函数定义的第1行（函数首部）基本相同，只是多了一个**";"**

函数的首行（部）被称作**函数原型**

函数声明基本有两种形式：

```c
// 形式1携带形参名，便于通过形参名了解函数的功能
函数类型 函数名(形参类型1 形参1, 形参类型2 形参2,,,形参类型n 形参n);
// 形式2不携带形参名
函数类型 函数名(形参类型1, 形参类型2,,,形参类型n);
```

如果已在函数的开头（所有函数之前），对本文件中所调用的函数进行了声明，则各函数中不必对其所调用的函数再做声明。

## 5.3 嵌套和递归

一个函数内不能再定义另一个函数，也就是不能嵌套定义函数，但可以嵌套调用函数。

**嵌套调用**——调用自身外的函数

**递归调用**——**直接或间接**地调用该函数本身

## 5.4 数组作为函数参数

数组中的元素作为函数的实参时，向形参传递的是值——传值

数组名作为函数的实参时，向形参传递的是数组的首元素地址——传址

形参数组可以不指定大小（一维），如果是多维，则必须指定其他高维的大小，而省略第1维的大小。

## 5.5 变量的作用域

空间角度观察变量分为

**局部变量**：

- 在函数内部定义对的变量都称作局部变量，只在本函数范围内有效
- 在函数体**程序块（花括号括起来的内容，也叫复合语句）**中定义变量，只在程序块中有效

**全局变量**：

- 在函数之外定义的变量是全局变量（也称外部变量），有效范围为从定义变量的位置开始到本源文件结束。
- c程序有个习惯，将全局变量的第一个字母大写。

如果局部变量和全局变量重名时，采用就近原则（局部变量的作用范围内，局部变量有效，而全局变量在此域内被屏蔽）

## 5.6 变量的生存期

存在时间（生存期）角度观察变量

也就是说，变量的存储方式（存储类别）有两种：

1. **静态存储方式**：程序运行的整个过程都是存在的
2. **动态存储方式**：调用其所在函数时才临时分配存储单元，调用结束后被释放

存储空间可以分为：程序区，静态存储区，动态存储区

变量和函数都有两个属性：数据类型（int，float等）和数据的存储类别

### 5.6.1 局部变量的存储类别

1. 自动变量（auto）
   - 函数调用结束时，就自动释放这些存储空间
   - 用关键字auto修饰，auto可省略，不写auto则隐含指定为"自动存储类别"
   - 存储在动态存储区
2. 静态局部变量（static）
   - 函数调用结束后不消失，而继续保留原值，即其占用的存储空间不释放，下一次调用函数时，该变量已有值
   - 用关键字static修饰
   - 存储在静态存储区
   - 静态局部变量在编译时赋初值，即只赋值一次，以后每次调用函数不在重新赋初值，而只是保留上次函数调用结束时的值。
3. 寄存器变量
   - 一些变量使用相当频繁，从内存中存取变量需要花费不少时间，为提高效率将局部变量的值放在cpu的寄存器中。
   - 用register修饰
   - 存储在cpu的寄存器中

```c
// 静态局部变量，计算n的阶乘
int main() {
    int fac(int n);
    for(int i=1;i<=5;i++) {
        printf("%d!=%d\n",i,fac(i));
    }
    return 1;
}
int fac(int n) {
    static int f=1;//在编译时赋初值，再次调用保留上次函数调用结束时的值
    f=f*n;
    return f;
}
```

### 5.6.2 全局变量的存储类别

1. 扩展外部变量作用域

   - 如果出于某种考虑，在**定义点之前的函数**需要引用该外部变量，则应该在引用之前用**extern**对该变量进行**声明**
   - 用extern声明外部变量时，**类型名可以省略**，因为它不是定义变量，可以不指定类型

2. 将外部变量的作用域**扩展到其他文件**

   - 如果出于某种考虑，多个文件间需要共用一个变量，而不会出现重复定义的情况
   - 做法：在任一一个文件中定义外部变量，而在另一文件中用extern对变量进行"外部变量的声明"
   - 实际上，在编译时遇到extern时，先在本文件找，如果找到，就在本文件扩展作用域，如果找不到，就在连接时其他文件找，依次向外找，找到就扩展作用域到本文件，如果再找不到就报错。

3. 将外部变量限制在本文件

   - 如果出于某种考虑，希望某些外部变量只限于本文件引用，这时可以加static声明
   - 加static声明，只能用于本文件的外部变量称为**静态外部变量**

   

   ```c
   // 扩展外部变量作用域到定义变量之前
   #include<stdio.h>
   int main() {
       int max();
       extern A,B,C;
       scanf("%d%d%d",&A,&B,&C);
       printf("max is %d\n",max());
   }
   int A,B,C;
   int max() {
       int m;
       m = A>B?A:B;
       if(m<C) m=C;
       return m;
   }
   
   //扩展变量作用域到其他文件
   // file1.c
   int A;
   int main() {
       
   }
   // file2.c
   extern A;
   int power() {
       int y;
       y = A;
   }
   
   //限制变量作用域在本文件内
   //file1.c
   static int A;
   int main(){
       ...
   }
   //file2.c
   extern A;
   void power() {
       int y;
       y = A;//将报错
   }
   ```


## 5.7 声明和定义

对于函数而言：

- 一般函数由两部分组成：声明部分和执行语句。
- 函数声明的作用是对有关标识符的属性进行声明（函数的原型），而函数的定义是对函数功能的定义。

对于变量而言：

- 声明出现的变量有两种情况，一种是需要建立存储空间的（如：int a），另一种是不需要建立存储空间的（如：extern a）
- 前者是**定义性声明**，后者是**引用性声明**，广义上来说是，声明包含定义，而并非所有声明都是定义
- 一般来说，建立存储空间的声明称定义，而把不需要建立存储空间的声明称为声明

## 5.8 函数的作用域

函数的本质是全局的。

一个函数的目的就是要被另外的函数调用，如果不加声明的话，一个文件得函数即可被本文件的函数调用，也可被其他文件得函数调用。

根据函数是否能被其他源文件调用，将函数分为**内部函数和外部函数**

1. 内部函数

   - ```c
     static type func_name(param1，params2...) {
         //
     }
     ```

   - 又称为静态函数

   - static的作用，使得函数的作用域局限于所在文件，而不能被其他文件调用

2. 外部函数

   - ```c
     extern type func_name(param1，params2...) {
         //
     }
     ```

   - 如果在定义函数时省略extern，则默认为外部函数

# 6 指针

## 6.1 直接与间接访问

1. 将3直接送到变量i所标志的单元，eg："**i = 3**"
2. 将3送到变量i_pointer所指向的单元（即变量i的存储单元），eg：“***i_pointer = 3**”，其中`*i_pointer表示i_pointer指向的对象`

<img src="./legend/直接访问与间接访问.png" style="zoom:50%;" />

直接访问：直接通过变量名**i**进行的访问

间接访问：将变量i的地址存放在**i_pointer**变量中，然后通过该变量来找到**变量i的地址**，从而访问变量i

指向通过地址来体现。

**一个变量的地址称为该变量的指针**，如果有一个变量专门用来存放另一个变量的地址，则称它为**指针变量**，指针变量的值是地址

**指针是一个地址，而指针变量存放地址的变量。**

## 6.2 指针变量

###  6.2.1 定义

**type *pointer_name;**

- type：**基类型**，用来指定指针变量可以指向的变量的类型
-  定义指针变量时必须指定基类型，因为要取出一个变量的数据，需要知道指定存储单元的地址和该变量的存储长度。
- 一个变量的指针含义包括两方面：
  - 存储单元编号表示的地址
  - 指向存储单元的数据类型
- 指针类型的表示：指向整型数据的指针类型表示为`int *`，当然还有其他指针类型的`float *, char *`
- 指针变量中只能存储地址，不要将一个整数赋给一个指针变量。

### 6.2.2 引用

两个运算符：

- **&**：取址运算符。
- *****：指针运算符（也称间接访问运算符），*p代表指针变量p指向的对象

```c
// p3是指向float型变量的指针变量，简称float指针
float *p3;

float a = 99.5, b = 10.6;
char c = '@', d = '#';
// 定义指针变量并初始化
float *p1 = &a;
char *p2 = &c;

// *p1代表指针变量p1指向的 a，此时输出99.5
printf("%f", *p1);

// 修改指针变量的值
p1 = &b;// &将b的地址取出给p1
p2 = &d;
```

### 6.2.3 指针变量作为函数的参数

函数的参数不仅可以是基本类型等数据，还可以是指针类型，他的作用是**将一个变量的地址传送给另一个变量**

C语言中实参和形参之间的数据传递是单向的"**值传递**"方式。用指针变量作为函数的参数同样遵循注意规则，**不可能通过执行函数来改变实参指针变量的值，但是可以改变实参指针变量所指变量的值。**

```c
#include<stdio.h>
int main() {
    void swap(int *p1,int *p2);
    int a,b;
    int *pointer_1,*pointer_2;
    printf("please enter a and b:");
    scanf("%d,%d", &a,&b);
    pointer_1 = &a;
    pointer_2 = &b;
    if(a<b) swap(pointer_1, pointer_2);
    printf("max=%d,min=%d\n", a,b);
}
// 交换a，b的值，而p1和p2的值不变
void swap(int *p1, int *p2){
    int temp;
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
```

## 6.3 指针引用数组

```c
int a[10] = {1,2,3,4,5,6,7,8,9,10};
int *p;
//引用1，取数组首元素的地址赋给p
p = &a[0];
//引用2，数组名代表数组中首元素的地址
p = a;
```

在指针指向数组时，可以对指针进行如下的运算：

1. `+i`：p+1，p+i指向p当前位置之后的第i个元素，`*(a+i), *(p+i), a[i]`
2. `-i`：p-1，p-i指向p当前位置之前的第i个元素
3. 自加：p++，++p
4. 自减：p--，--p
5. 同一数组两个指针相减：p1-p2，就知道他们所指元素的相隔几个数组元素。

注意：

1. 指针变量p可以指向数组以后的单元，在这个例子里：a的长度为10，最后一个元素是a[9]，但是可以引用`*(a+10)`,这样编译不会出错，但逻辑会出错
2. 指向数组的指针变量也可以使用下标，因为在程序编译时，**对p[i]的处理成`*(p+i)`**。如果p指的位置不是a的首元素，那么p[i]将不等于a[i]，如果p当前指向的是第3个数组元素，那么p[2]将等于a[3+2]
3. 指针运算符与自加自减运算符同优先级，结合方向自右而左。
   - `*p++等价与*(p++)，先引用p的值，实现*p的运算，然后再使p自增1`
   - `++(*p)，表示p所指向的元素值加1，而不是指针值加1`
4. `fun(int arr[], int n)等价于fun(int *arr,int n)`

### 6.3.1 指针引用多维数组

```c
int a[3][4] = {
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12}
}
```

主要把握两个点：

- `a+1 -> a[1] -> a[1][0]`
- ``a+1指向a[1]，a+1 = &a[1]，a[1] = *(a+1),`
- `a[1]指向a[1][0]，a[1] = &a[1][0]`

| 表示形式                              | 含义                   |
| ------------------------------------- | ---------------------- |
| a                                     | a -> a[0]              |
| `*a, *(a+0), a[0] `                   | a+0 -> a[0]，a -> a[0] |
| `a+1, &a[1]`                          | a+1 -> a[1]            |
| `*(a+1), a[1]`                        | a+1 -> a[1]            |
| `*(a+1) +2, a[1] +2, &a[1][2] `       | `a[1] + 2 -> a[1][2]`  |
| `*(*(a+1) + 2), *(a[1] + 2), a[1][2]` | `a[1] + 2 -> a[1][2]`  |

注意：

- a和a[0]的值虽然相同（都是地址2000），但由于指针类型不同，a指向一维数组a[0]，而a[0]指向第一行的列元素`a[0][0]`
- 二维数组名a是指向行的，一维数组名a[0]是指向行的列元素的

### 6.3.2 指向多维“数组元素”的指针变量

```c
#include<stdio.h>
int main() {
    int a[3][4] = {
        {1,2,3,4},
        {5,6,7,8},
        {9,10,11,12}
    };
    int *p;
    //注意这里的初值，p=a[0]
    for(p=a[0];p < a[0]+12; p++) {
        if((p-a[0])%4 ==0) printf("\n");
        printf("%4d", *p);
    }
    printf("\n")
}
```

p是一个int * 型的指针变量，它可以指向一般的整型变量，也可以指向整型的数组元素。

二维数组大小m x n，`a[i][j] = *(p + i*n + j)`

### 6.3.3 指向“一维数组”的指针变量

在二维数组中，调整p指向一个包含n个元素的一维数组。使得p+1指向a[1]，而不再是`a[0][1]`

```c
#include<stdio.h>
int main(){
   int a[3][4] = {
        {1,2,3,4},
        {5,6,7,8},
        {9,10,11,12}
    };
    int (*p)[4],i,j;
    p=a;
    printf("please enter row and column: ");
    scanf("%d,%d",&i,&j);
    printf("a[%d,%d]=%d\n", *(*(p+i)+j));
}
```

`int (*p)[4]`表示定义一个指针变量（可以同数组定义方式做比较，`int a[4]`，*p替代的是就是a，所以p指向一维数组），它指向包含4个整型元素的一维数组。`p -> a， a -> a[0]`

注意`*p`两侧的括号不能少，如果写成`int *p[4]`，由于[]运算级别较高，因此p先与4结合，再与`*`结合，*p[4]就是指针数组了。

```c
#include<stdio.h>
int main(){
    int a[4] = {1,2,3,4};
    int (*p)[4];
    //这里不能写成p=a，因为这样写表示p的值是&a[0]。
    // p=&a，表示p指向一维数组行，*p=a，(*p)[3]=a[4];
    p = &a;
    printf("%d\n", (*p)[3]);
    return 0;
}
```





![](./legend/指针指向一维数组.png)

这里p的类型是不是`int *`型，而是`int (*)[4]`型，p被定义为指向一维整型数组的指针，一维数组有4个元素，因此p的基类型是一维数组，其长度为16字节。

### 6.3.4 指向数组的指针做函数参数

```c
#include<stdio.h>
int main() {
    void average(float *p, int n);
    void search(float (*p)[4], int n);
	//3个学生，4门功课的成绩数组
    float score[3][4] = {
        {65,67,70,60},
        {80,87,90,81},
        {90,99,100,98}
    };
    average(*score, 12);//求12个数的平均分
    search(score, 2);// 求序号为2的学生的成绩
}
void average(float *p, int n) {
    float *p_end;
    float sum=0,aver;
    p_end = p+n -1;
    for(;p<=p_end;p++) {
        sum = sum + (*p);
    }
    aver = sum/n;
    printf("average=%5.2f\n", aver);
}
void search(float (*p)[4], int n) {
    int i;
    printf("the score of No.%d is:\n",n);
    for(i=0; i<4; i++) {
        printf("%5.2f",*(*(p+n) + i));
    }
    printf("\n");
}
```

## 6.4 指针引用字符串

```c
char string[] = "i love china";
printf("%s",string);//"i love china"
// 字符指针变量指向一个字符串常量
// string指向了字符串的第一个字符
char *string = "i love china";
printf("%s",string);//"i love china"

#include<stdio.h>
int main() {
    char a[] = "i am a boy", b[20], *p1, *p2;
    p1=a;
    p2=b;
    for(;*p1!='\0';p1++,p2++) {
        *p2=*p1;
    }
    *p2='\0';
    printf("string a is:%s\n",a);
    printf("string b is:%s\n",b);
}
```

**调用函数时实参形参的类型都可以是字符数组名和字符指针变量**

### 字符指针变量和字符数组

```c
//1.可以对字符指针变量赋值，但不能对数组名赋值
char *a;
a = "i love china";// 合法，将字符串首地址赋给指针变量
char str[20];
str = "i love china"; //非法，数组名是地址，是常量，不能赋值。

//2.初始化的含义
char *a = "china";
//等价
char *a;
a = "china";
//而
char str[14] = "china";
//不等价，并且出错
char str[14];
str[] = "china";

//3.指针变量的值可以改变，而数组名的值不能改变（代表一个固定的值，数组首元素的地址）
int *p = "i love china";
p = p+7;
printf("%s",p);//china
//而
char str[]= "i love china";
str = str + 7;//报错

//4.字符数组中各元素的值是可以改变的（可以对他们再赋值），但字符指针变量指向的字符串常量中的内容是不可以改变（不能再对他们赋值）
char a[]="house";
char *b="house";
a[2]='r';
b[2]='r';//非法，字符串常量不可改变

//5.存储单元的内容，编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量只分配一个存储单元
char *a;
scanf("%s",a);//错误，a的值为一个地址，而这个地址并未具体指向某一个对象，如果指向内存的有用空间，可能会造成系统的破坏。
// 而
char *a,str[10];
a=str;
scanf("%s",a);//正确
```

## 6.5 指向函数的指针

**在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址称为这个函数的指针。**

```c
#include<stdio.h>
int main() {
    int max(int, int);
    int (*p)(int, int);
    int a,b,c;
    // 将函数max入口地址赋给p
    p=max;
    printf("please enter a and b:");
    scanf("%d,%d",&a, &b);
    // *p = max
    c = (*p)(a,b);
    printf("a=%d\nb=%d\nmax=%d\n",a,b,c);
    return 0;
}
int max(int x,int y){
    int z;
    if(x>y)z=y;
    else z=x;
    return z;
}
```

1. 指向函数的指针变量，在定义后，只能指向在定义时**“指定的类型”**的函数，如`int (*p)(int,int)`，这个指针变量p只能指向返回值为整型，参数数目相同且参数类型为整型的函数。一个指针变量可以先后指向同类型的不同函数。
2. 指针变量调用函数比较灵活，可以根据不同情况，先后调用同类型的不同函数。

### 6.5.1 指向函数的指针作为函数的参数

指向函数的指针变量的一个重要用途是把函数的地址作为参数传递到其他函数。

```c
#include<stdio.h>
int main() {
    int fun(int x,int y,int (*p)(int, int));
    int max(int,int);
    int min(int,int);
    int add(int,int);
    int a=34,b=-21,n;
    printf("please choose 1,2 or 3\n");
    scanf("%d",&n);
    if(n == 1) fun(a,b,max);
    else if fun(a,b,min);
    else if fun(a,b,sum);
    return 0;
}
int fun(int x,int y,int (*p)(int, int)){
    int result;
    result=(*p)(x,y);
    return result;
}
int max(int x,int y){
    int z;
    if(x>y) z=x;
    else z=y;
    printf("max=%d\n",z);
    return z;
}
int min(int x,int y){
    int z;
    if(x<y) z=x;
    else z=y;
    printf("min=%d\n",z);
    return z;
}
int add(int x,int y){
    int z;
    z = x+y;
    printf("sum=%d\n",z);
    return z;
}
```

## 6.6 返回指针值的函数

`int *a(int x, int y);`，a是函数名，调用它后，能得到一个方`int*`型（指向整型数据）的指针，即整型数据的地址

```c
//3个学生，4门课的成绩，打印第k个学生的成绩
#include<stdio.h>
int main() {
    float *search(float (*p)[4], int n);
    float score[][4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};
    float *p;
    int i,k;
    printf("enter the number of student:\n");
    scanf("%d",&k);
    printf("the scores of No.%d are :\n", k);
    p=search(score,k);
    for(i=0;i<4;i++){
        printf("5.2f\t",*(p+i));
    }
    printf("\n");
    return 0;
}

float *search(float (*p)[4], int n){
    float *pt;
    pt=*(p+n);
    return pt;
}
```

## 6.7 指针数组和多重指针

一个数组，若其元素均为指针型数据，则称之为**指针数组**

`int *p[4]`

由于`[]`比`*`的优先级高，p先与[4]结合，形成p[4]形式（数组形式），表示p数组有4个元素。然后在于p前面的`*`结合，`*`表示此数组是指针类型的，**每个数组元素都可以指向一个整型变量**

也可以同数组（**int a[4]**）的定义方式对比，`int *`是数组元素的类型。

```c
#include<stdio.h>
#include<string.h>
int main() {
    void sort(char *name[], int n);
    void print(char *name[], int n);
    // 每个数组元素都指向字符串的首字符的地址，指针变量指向字符串：char *string="abcde"
    char *name[]={"Follow me", "BASIC", "Greate Wall", "FORTRAN", "Computer design"};
    
    int n = 5;
    sort(name, n);
    print(name, n);
    return 0;
}
void sort(char *name[], int n){
    char *temp;
    
    // 选择法排序
    int i,j,k;
    for(i=0;i<n-1;i++){
        k=i;
        for(j=i+1;j<n;j++) {
            if(strcmp(name[k],name[i])>0) k=i;
        }
        if(k!=i) {
            temp = name[i];
            name[i] = name[k];
            name[k] = temp;
        }
    }
}
void print(char *name[], int n){
    int i;
    for(i=0;i<n;i++) {
        printf("%s\n",name[i]);
    }
}
```



<img src="./legend/指针数组排序.png" style="zoom:60%;" />

### 6.7.1 指向指针数据的指针

`char **p`

`p前面有两个*号，*号的结合性从右向左，因此**p相当于*(*p)`

`可以把它分为两部分来看：char * 和 (*p)，后面的(*p)表示p是指针变量，前面的char*表示p指向的是char *型的数据`

<img src="./legend/多重指针.png" style="zoom:67%;" />



```c
#include<stdio.h>
int main() {
    char *name[]={"Follow me", "BASIC", "Greate Wall", "FORTRAN", "Computer design"};
    char **p;
    int i;
    for(i=0;i<5;i++){
        p = name +i;
        printf("%s\n",*p);
    }
    return 0;
}
```

### 6.7.2 main函数的形参

`int main (int argc, char *argv[])`

- argc，参数个数
- argv，参数字符串指针数组
- 通常main函数和其他函数组成一个文件模块，有一个文件名（文件路径+文件名）。对这个文件进行编译和连接，得到一个可执行文件exe，用户执行这个可执行文件，操作系统就调用main函数，从而实现程序的功能。

执行可执行文件，是通过命令行的形式：

- `命令名 param1, param2,...paramn`
- 命令名：文件路径 + 可执行文件名，
- 执行，eg：`file1 china beijing`
- ![](./legend/main函数参数argv指针数组.png)

## 6.8 动态分配

全局变量分配在内存中的静态存储区。

局部变量（非静态）分配在内存中的动态存储区，这个区域叫做**栈**

C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不需要在程序的声明部分定义，也不必等到函数结束时才释放，随时开辟，随时释放，这些数据临时存放在一个特别的自由存储区，这个区域叫做**堆**

**堆区**可以根据需要向系统申请所需大小的空间。由于未在声明部分定义他们为变量或数组，因此不能通过变量名或数组名引用这些数据，**只能通过指针来引用**

### 6.8.1 void 指针类型

c99允许使用基类型为void的指针类型。

可以定义一个基类型为void的指针变量（即**`void *`**型变量），它不指向任何类型的数据。

**不要**把“**指向void类型**”理解为能指向任何类型的数据，**而应**理解为**"指向空类型"或”不指向确定的类型“**的数据。

**它仅提供一个纯地址，而不能指向任何具体的对象**

在将它的值赋给另一指针变量时，由系统对它进行类型转换，使之适合于被赋值的变量的类型。

```c
int a=3;
int *p1=&a;
char *p2;
void *p3;
// 可以省略强制类型转换
p3 = (void *) p1;// 可以写为 p3 = p1;
p2 = (char *) p3;// 可以写为 p2 = p3;
printf("%d", *p1);
p3 = &a;
printf("%d", *p3);
```

**当把void指针赋值给不同基类型的指针变量，或者不同基类型的指针变量赋值给void指针时，编译系统会自动进行转换，不必用户自己进行强制转换。**

### 6.8.2 建立内存的动态分配

对内存的动态分配是通过系统提供的库函数（**`#include<stdlib.h>`**）来实现的，主要有`malloc, calloc, free, realloc`这4个函数。

除free外的3个函数都是返回值为指针的函数，它们的返回值都是void类型的指针。

1. malloc
   - 函数原型：`void *mall(unsigned int size);`
   - 作用：在内存的动态存储区中分配一个长度为**size（单位：字节）的连续空间**
   - 返回值：该分配域的开头位置（第1个字节的地址）
   - 如果此函数未能成功（eg：内存空间不足）地执行，则返回空指针（NULL）
2. calloc
   - 函数原型：`void *calloc(unsigned n, unsigned int size);`
   - 作用：在内存的动态存储区中分配**n个长度为size的连续空间**，calloc函数可以为一维数组开辟动态存储空间，n为数组元素的个数，每个元素长度为size，这就是动态数组
   - 执行失败，返回NULL
3. free
   - 函数原型：`void  free(void *p)`
   - 作用：**释放**指针变量p所指向的动态空间，p应是malloc或calloc的返回值
4. realloc
   - 函数原型：`void *realloc(void *p, unsigned int size);`
   - 作用：如果已经通过malloc函数或call函数获得动态空间，想改变其大小，可以用realloc函数进行**重新分配空间**

```c
#include<stdlib.h>
#include<stdio.h>
int main(){
    void check(int *);
    int *p1,i;
    p1 =(int *) malloc(5 * sizeof(int));
    for(i=0;i<5;i++){
        scanf("%d", p1+i);
    }
    check(p1);
    return 0;
}
void check(int *p) {
    int i;
    printf("they are fail:");
    for(i=0;i<5;i++) {
        if(p[i]<60) printf("%d",p[i]);
    }
    printf("\n");
}
```

## 6.8 指针小结

**指针就是地址。凡是出现指针的地方，都可以用”地址“代替。**

指针变量就是用来存放地址的变量。

`void *`指针**仅提供纯地址**，而**不指向**任何具体的对象。

| 变量的定义       | 类型表示       | 含义                                                         |
| ---------------- | -------------- | ------------------------------------------------------------ |
| **int i;**       | **int**        | 定义整型变量i                                                |
| **int *p;**      | **int ***      | 定义p为指向整型数据的指针变量                                |
| **int a[5];**    | **int [5]**    | 定义一个整型数组a，                                          |
| **int *p[4];**   | **int * [4]**  | 定义指针数组p，它由4个指向整型数据的指针元素组成<br />[]与*，前者优先级高<br />p先与[4]结合，p[4]，int * 变量p[4]的数组元素为指向整型数组的指针<br /> |
| **int (*p)[4];** | **int (*)[4]** | p为指向包含4个元素的一维数组的指针变量                       |
| **int fun();**   | **int  ()**    | fun为返回整型函数值的函数                                    |
| **int *p();**    | **int * ()**   | p为返回指针值的函数，该指针指向整型数据                      |
| **int (*p)();**  | **int (*)()**  | p为指向函数的指针，该函数返回指针值                          |
| **`int **p;`**   | **`int **`**   | `*(*p)`，双重指针，指向一个指向整型数据的指针变量            |
| **void *p;**     | **void ***     | p是一个指针变量，基类型为void（空类型），不指向任何具体的对象 |

**指针变量可以有空值，即该指针变量不指向任何变量**，

- `p=NULL`，NULL是一个符号常量，代表整数0，在stdio.h里面（`#define NULL 0`）

# 7 自建数据类型

